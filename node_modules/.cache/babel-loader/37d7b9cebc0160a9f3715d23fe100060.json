{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto_1 = require(\"@iov/crypto\");\n\nconst encoding_1 = require(\"@iov/encoding\");\n\nconst pako_1 = __importDefault(require(\"pako\"));\n\nconst builder_1 = require(\"./builder\");\n\nconst cosmwasmclient_1 = require(\"./cosmwasmclient\");\n\nconst encoding_2 = require(\"./encoding\");\n\nconst logs_1 = require(\"./logs\");\n\nconst restclient_1 = require(\"./restclient\");\n\nfunction singleAmount(amount, denom) {\n  return [{\n    amount: amount.toString(),\n    denom: denom\n  }];\n}\n\nfunction prepareBuilder(buider) {\n  if (buider === undefined) {\n    return \"\"; // normalization needed by backend\n  } else {\n    if (!builder_1.isValidBuilder(buider)) throw new Error(\"The builder (Docker Hub image with tag) is not valid\");\n    return buider;\n  }\n}\n\nconst defaultFees = {\n  upload: {\n    amount: singleAmount(250000, \"uscrt\"),\n    gas: String(1000000)\n  },\n  init: {\n    amount: singleAmount(125000, \"uscrt\"),\n    gas: String(500000)\n  },\n  exec: {\n    amount: singleAmount(50000, \"uscrt\"),\n    gas: String(200000)\n  },\n  send: {\n    amount: singleAmount(20000, \"uscrt\"),\n    gas: String(80000)\n  }\n};\n\nclass SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {\n  /**\n   * Creates a new client with signing capability to interact with a CosmWasm blockchain. This is the bigger brother of CosmWasmClient.\n   *\n   * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n   * for the lifetime of your application. When switching backends, a new instance must be created.\n   *\n   * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n   * @param senderAddress The address that will sign and send transactions using this instance\n   * @param signer An asynchronous callback to create a signature for a given transaction. This can be implemented using secure key stores that require user interaction. Or a newer OfflineSigner type that handles that stuff\n   * @param seedOrEnigmaUtils\n   * @param customFees The fees that are paid for transactions\n   * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n   */\n  constructor(apiUrl, senderAddress, signer, seedOrEnigmaUtils, customFees) {\n    let broadcastMode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : restclient_1.BroadcastMode.Block;\n\n    if (seedOrEnigmaUtils instanceof Uint8Array) {\n      super(apiUrl, seedOrEnigmaUtils, broadcastMode);\n    } else {\n      super(apiUrl, undefined, broadcastMode);\n    }\n\n    this.anyValidAddress = senderAddress;\n    this.senderAddress = senderAddress; //this.signCallback = signCallback ? signCallback : undefined;\n\n    this.signer = signer;\n\n    if (seedOrEnigmaUtils && !(seedOrEnigmaUtils instanceof Uint8Array)) {\n      this.restClient.enigmautils = seedOrEnigmaUtils;\n    }\n\n    this.fees = Object.assign(Object.assign({}, defaultFees), customFees || {}); // // Setup contract->hash cache\n    // // This is only needed here and not in CosmWasmClient because we\n    // // need code hashes before sending txs\n    // this.restClient.listCodeInfo().then(async (codes) => {\n    //   for (const code of codes) {\n    //     this.restClient.codeHashCache.set(code.id, code.data_hash);\n    //     const contracts = await this.restClient.listContractsByCodeId(code.id);\n    //     for (const contract of contracts) {\n    //       this.restClient.codeHashCache.set(contract.address, code.data_hash);\n    //     }\n    //   }\n    // });\n  }\n\n  async getNonce(address) {\n    return super.getNonce(address || this.senderAddress);\n  }\n\n  async getAccount(address) {\n    return super.getAccount(address || this.senderAddress);\n  }\n\n  async signAdapter(msgs, fee, chainId, memo, accountNumber, sequence) {\n    // offline signer interface\n    if (\"sign\" in this.signer) {\n      const signResponse = await this.signer.sign(this.senderAddress, {\n        chain_id: chainId,\n        account_number: String(accountNumber),\n        sequence: String(sequence),\n        fee: fee,\n        msgs: msgs,\n        memo: memo\n      });\n      return {\n        msg: msgs,\n        fee: signResponse.signed.fee,\n        memo: signResponse.signed.memo,\n        signatures: [signResponse.signature]\n      };\n    } else {\n      // legacy interface\n      const signBytes = encoding_2.makeSignBytes(msgs, fee, chainId, memo, accountNumber, sequence);\n      const signature = await this.signer(signBytes);\n      return {\n        msg: msgs,\n        fee: fee,\n        memo: memo,\n        signatures: [signature]\n      };\n    }\n  }\n  /** Uploads code and returns a receipt, including the code ID */\n\n\n  async upload(wasmCode) {\n    let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    let fee = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.fees.upload;\n    const source = meta.source || \"\";\n    const builder = prepareBuilder(meta.builder);\n    const compressed = pako_1.default.gzip(wasmCode, {\n      level: 9\n    });\n    const storeCodeMsg = {\n      type: \"wasm/MsgStoreCode\",\n      value: {\n        sender: this.senderAddress,\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        wasm_byte_code: encoding_1.Encoding.toBase64(compressed),\n        source: source,\n        builder: builder\n      }\n    };\n    const {\n      accountNumber,\n      sequence\n    } = await this.getNonce();\n    const chainId = await this.getChainId();\n    const signedTx = await this.signAdapter([storeCodeMsg], fee, chainId, memo, accountNumber, sequence);\n    const result = await this.postTx(signedTx);\n    const codeIdAttr = logs_1.findAttribute(result.logs, \"message\", \"code_id\");\n    return {\n      originalSize: wasmCode.length,\n      originalChecksum: encoding_1.Encoding.toHex(new crypto_1.Sha256(wasmCode).digest()),\n      compressedSize: compressed.length,\n      compressedChecksum: encoding_1.Encoding.toHex(new crypto_1.Sha256(compressed).digest()),\n      codeId: Number.parseInt(codeIdAttr.value, 10),\n      logs: result.logs,\n      transactionHash: result.transactionHash\n    };\n  }\n\n  async instantiate(codeId, initMsg, label) {\n    let memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    let transferAmount = arguments.length > 4 ? arguments[4] : undefined;\n    let fee = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.fees.init;\n    let contractCodeHash = arguments.length > 6 ? arguments[6] : undefined;\n\n    var _a;\n\n    if (!contractCodeHash) {\n      contractCodeHash = await this.restClient.getCodeHashByCodeId(codeId);\n    } else {\n      this.restClient.codeHashCache.set(codeId, contractCodeHash);\n    }\n\n    if (!memo) {\n      memo = \"\";\n    }\n\n    const instantiateMsg = {\n      type: \"wasm/MsgInstantiateContract\",\n      value: {\n        sender: this.senderAddress,\n        code_id: codeId.toString(),\n        label: label,\n        callback_code_hash: \"\",\n        init_msg: encoding_1.Encoding.toBase64(await this.restClient.enigmautils.encrypt(contractCodeHash, initMsg)),\n        init_funds: transferAmount !== null && transferAmount !== void 0 ? transferAmount : [],\n        callback_sig: null\n      }\n    };\n    const {\n      accountNumber,\n      sequence\n    } = await this.getNonce();\n    const chainId = await this.getChainId();\n    const signedTx = await this.signAdapter([instantiateMsg], fee, chainId, memo, accountNumber, sequence);\n    const nonce = encoding_1.Encoding.fromBase64(instantiateMsg.value.init_msg).slice(0, 32);\n    let result;\n\n    try {\n      result = await this.postTx(signedTx);\n    } catch (err) {\n      try {\n        const errorMessageRgx = /contract failed: encrypted: (.+?): failed to execute message; message index: 0/g;\n        const rgxMatches = errorMessageRgx.exec(err.message);\n\n        if (rgxMatches == null || rgxMatches.length != 2) {\n          throw err;\n        }\n\n        const errorCipherB64 = rgxMatches[1];\n        const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n        const errorPlainBz = await this.restClient.enigmautils.decrypt(errorCipherBz, nonce);\n        err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n      } catch (decryptionError) {\n        throw new Error(`Failed to decrypt the following error message: ${err.message}. Decryption error of the error message: ${decryptionError.message}`);\n      }\n\n      throw err;\n    }\n\n    let contractAddress = \"\";\n\n    if (this.restClient.broadcastMode == restclient_1.BroadcastMode.Block) {\n      contractAddress = (_a = logs_1.findAttribute(result.logs, \"message\", \"contract_address\")) === null || _a === void 0 ? void 0 : _a.value;\n    }\n\n    const logs = await this.restClient.decryptLogs(result.logs, [nonce]);\n    return {\n      contractAddress,\n      logs: logs,\n      transactionHash: result.transactionHash,\n      data: result.data\n    };\n  }\n\n  async multiExecute(inputMsgs) {\n    let memo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let totalFee = arguments.length > 2 ? arguments[2] : undefined;\n\n    var _a;\n\n    if (!memo) {\n      memo = \"\";\n    }\n\n    const msgs = [];\n\n    for (const inputMsg of inputMsgs) {\n      let {\n        contractCodeHash\n      } = inputMsg;\n\n      if (!contractCodeHash) {\n        contractCodeHash = await this.restClient.getCodeHashByContractAddr(inputMsg.contractAddress);\n      } else {\n        this.restClient.codeHashCache.set(inputMsg.contractAddress, contractCodeHash);\n      }\n\n      const msg = {\n        type: \"wasm/MsgExecuteContract\",\n        value: {\n          sender: this.senderAddress,\n          contract: inputMsg.contractAddress,\n          callback_code_hash: \"\",\n          msg: encoding_1.Encoding.toBase64(await this.restClient.enigmautils.encrypt(contractCodeHash, inputMsg.handleMsg)),\n          sent_funds: (_a = inputMsg.transferAmount, _a !== null && _a !== void 0 ? _a : []),\n          callback_sig: null\n        }\n      };\n      msgs.push(msg);\n    }\n\n    const {\n      accountNumber,\n      sequence\n    } = await this.getNonce();\n    const fee = totalFee !== null && totalFee !== void 0 ? totalFee : {\n      gas: String(Number(this.fees.exec.gas) * inputMsgs.length),\n      amount: this.fees.exec.amount\n    };\n    const chainId = await this.getChainId();\n    const signedTx = await this.signAdapter(msgs, fee, chainId, memo, accountNumber, sequence);\n    let result;\n\n    try {\n      result = await this.postTx(signedTx);\n    } catch (err) {\n      try {\n        const errorMessageRgx = /contract failed: encrypted: (.+?): failed to execute message; message index: (\\d+)/g;\n        const rgxMatches = errorMessageRgx.exec(err.message);\n\n        if (rgxMatches == null || rgxMatches.length != 3) {\n          throw err;\n        }\n\n        const errorCipherB64 = rgxMatches[1];\n        const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n        const msgIndex = Number(rgxMatches[2]);\n        const nonce = encoding_1.Encoding.fromBase64(msgs[msgIndex].value.msg).slice(0, 32);\n        const errorPlainBz = await this.restClient.enigmautils.decrypt(errorCipherBz, nonce);\n        err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n      } catch (decryptionError) {\n        throw new Error(`Failed to decrypt the following error message: ${err.message}. Decryption error of the error message: ${decryptionError.message}`);\n      }\n\n      throw err;\n    }\n\n    const nonces = msgs.map(msg => encoding_1.Encoding.fromBase64(msg.value.msg).slice(0, 32));\n    const data = await this.restClient.decryptDataField(result.data, nonces);\n    const logs = await this.restClient.decryptLogs(result.logs, nonces);\n    return {\n      logs: logs,\n      transactionHash: result.transactionHash,\n      data: data\n    };\n  }\n\n  async execute(contractAddress, handleMsg) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    let transferAmount = arguments.length > 3 ? arguments[3] : undefined;\n    let fee = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.fees.exec;\n    let contractCodeHash = arguments.length > 5 ? arguments[5] : undefined;\n\n    if (!contractCodeHash) {\n      contractCodeHash = await this.restClient.getCodeHashByContractAddr(contractAddress);\n    } else {\n      this.restClient.codeHashCache.set(contractAddress, contractCodeHash);\n    }\n\n    if (!memo) {\n      memo = \"\";\n    }\n\n    const executeMsg = {\n      type: \"wasm/MsgExecuteContract\",\n      value: {\n        sender: this.senderAddress,\n        contract: contractAddress,\n        callback_code_hash: \"\",\n        msg: encoding_1.Encoding.toBase64(await this.restClient.enigmautils.encrypt(contractCodeHash, handleMsg)),\n        sent_funds: transferAmount !== null && transferAmount !== void 0 ? transferAmount : [],\n        callback_sig: null\n      }\n    };\n    const {\n      accountNumber,\n      sequence\n    } = await this.getNonce();\n    const chainId = await this.getChainId();\n    const signedTx = await this.signAdapter([executeMsg], fee, chainId, memo, accountNumber, sequence);\n    const nonce = encoding_1.Encoding.fromBase64(executeMsg.value.msg).slice(0, 32);\n    let result;\n\n    try {\n      result = await this.postTx(signedTx);\n    } catch (err) {\n      try {\n        const errorMessageRgx = /contract failed: encrypted: (.+?): failed to execute message; message index: 0/g;\n        const rgxMatches = errorMessageRgx.exec(err.message);\n\n        if (rgxMatches == null || rgxMatches.length != 2) {\n          throw err;\n        }\n\n        const errorCipherB64 = rgxMatches[1];\n        const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n        const errorPlainBz = await this.restClient.enigmautils.decrypt(errorCipherBz, nonce);\n        err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n      } catch (decryptionError) {\n        throw new Error(`Failed to decrypt the following error message: ${err.message}. Decryption error of the error message: ${decryptionError.message}`);\n      }\n\n      throw err;\n    }\n\n    const data = await this.restClient.decryptDataField(result.data, [nonce]);\n    const logs = await this.restClient.decryptLogs(result.logs, [nonce]);\n    return {\n      logs: logs,\n      transactionHash: result.transactionHash,\n      data: data\n    };\n  }\n\n  async sendTokens(recipientAddress, transferAmount) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    let fee = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.fees.send;\n    const sendMsg = {\n      type: \"cosmos-sdk/MsgSend\",\n      value: {\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        from_address: this.senderAddress,\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        to_address: recipientAddress,\n        amount: transferAmount\n      }\n    };\n\n    if (!memo) {\n      memo = \"\";\n    }\n\n    const {\n      accountNumber,\n      sequence\n    } = await this.getNonce();\n    const chainId = await this.getChainId();\n    const signedTx = await this.signAdapter([sendMsg], fee, chainId, memo, accountNumber, sequence);\n    return this.postTx(signedTx);\n  }\n\n}\n\nexports.SigningCosmWasmClient = SigningCosmWasmClient;","map":{"version":3,"sources":["../src/signingcosmwasmclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"@iov/crypto\");\nconst encoding_1 = require(\"@iov/encoding\");\nconst pako_1 = __importDefault(require(\"pako\"));\nconst builder_1 = require(\"./builder\");\nconst cosmwasmclient_1 = require(\"./cosmwasmclient\");\nconst encoding_2 = require(\"./encoding\");\nconst logs_1 = require(\"./logs\");\nconst restclient_1 = require(\"./restclient\");\nfunction singleAmount(amount, denom) {\n    return [{ amount: amount.toString(), denom: denom }];\n}\nfunction prepareBuilder(buider) {\n    if (buider === undefined) {\n        return \"\"; // normalization needed by backend\n    }\n    else {\n        if (!builder_1.isValidBuilder(buider))\n            throw new Error(\"The builder (Docker Hub image with tag) is not valid\");\n        return buider;\n    }\n}\nconst defaultFees = {\n    upload: {\n        amount: singleAmount(250000, \"uscrt\"),\n        gas: String(1000000),\n    },\n    init: {\n        amount: singleAmount(125000, \"uscrt\"),\n        gas: String(500000),\n    },\n    exec: {\n        amount: singleAmount(50000, \"uscrt\"),\n        gas: String(200000),\n    },\n    send: {\n        amount: singleAmount(20000, \"uscrt\"),\n        gas: String(80000),\n    },\n};\nclass SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {\n    /**\n     * Creates a new client with signing capability to interact with a CosmWasm blockchain. This is the bigger brother of CosmWasmClient.\n     *\n     * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n     * for the lifetime of your application. When switching backends, a new instance must be created.\n     *\n     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n     * @param senderAddress The address that will sign and send transactions using this instance\n     * @param signer An asynchronous callback to create a signature for a given transaction. This can be implemented using secure key stores that require user interaction. Or a newer OfflineSigner type that handles that stuff\n     * @param seedOrEnigmaUtils\n     * @param customFees The fees that are paid for transactions\n     * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n     */\n    constructor(apiUrl, senderAddress, signer, seedOrEnigmaUtils, customFees, broadcastMode = restclient_1.BroadcastMode.Block) {\n        if (seedOrEnigmaUtils instanceof Uint8Array) {\n            super(apiUrl, seedOrEnigmaUtils, broadcastMode);\n        }\n        else {\n            super(apiUrl, undefined, broadcastMode);\n        }\n        this.anyValidAddress = senderAddress;\n        this.senderAddress = senderAddress;\n        //this.signCallback = signCallback ? signCallback : undefined;\n        this.signer = signer;\n        if (seedOrEnigmaUtils && !(seedOrEnigmaUtils instanceof Uint8Array)) {\n            this.restClient.enigmautils = seedOrEnigmaUtils;\n        }\n        this.fees = Object.assign(Object.assign({}, defaultFees), (customFees || {}));\n        // // Setup contract->hash cache\n        // // This is only needed here and not in CosmWasmClient because we\n        // // need code hashes before sending txs\n        // this.restClient.listCodeInfo().then(async (codes) => {\n        //   for (const code of codes) {\n        //     this.restClient.codeHashCache.set(code.id, code.data_hash);\n        //     const contracts = await this.restClient.listContractsByCodeId(code.id);\n        //     for (const contract of contracts) {\n        //       this.restClient.codeHashCache.set(contract.address, code.data_hash);\n        //     }\n        //   }\n        // });\n    }\n    async getNonce(address) {\n        return super.getNonce(address || this.senderAddress);\n    }\n    async getAccount(address) {\n        return super.getAccount(address || this.senderAddress);\n    }\n    async signAdapter(msgs, fee, chainId, memo, accountNumber, sequence) {\n        // offline signer interface\n        if (\"sign\" in this.signer) {\n            const signResponse = await this.signer.sign(this.senderAddress, {\n                chain_id: chainId,\n                account_number: String(accountNumber),\n                sequence: String(sequence),\n                fee: fee,\n                msgs: msgs,\n                memo: memo,\n            });\n            return {\n                msg: msgs,\n                fee: signResponse.signed.fee,\n                memo: signResponse.signed.memo,\n                signatures: [signResponse.signature],\n            };\n        }\n        else {\n            // legacy interface\n            const signBytes = encoding_2.makeSignBytes(msgs, fee, chainId, memo, accountNumber, sequence);\n            const signature = await this.signer(signBytes);\n            return {\n                msg: msgs,\n                fee: fee,\n                memo: memo,\n                signatures: [signature],\n            };\n        }\n    }\n    /** Uploads code and returns a receipt, including the code ID */\n    async upload(wasmCode, meta = {}, memo = \"\", fee = this.fees.upload) {\n        const source = meta.source || \"\";\n        const builder = prepareBuilder(meta.builder);\n        const compressed = pako_1.default.gzip(wasmCode, { level: 9 });\n        const storeCodeMsg = {\n            type: \"wasm/MsgStoreCode\",\n            value: {\n                sender: this.senderAddress,\n                // eslint-disable-next-line @typescript-eslint/camelcase\n                wasm_byte_code: encoding_1.Encoding.toBase64(compressed),\n                source: source,\n                builder: builder,\n            },\n        };\n        const { accountNumber, sequence } = await this.getNonce();\n        const chainId = await this.getChainId();\n        const signedTx = await this.signAdapter([storeCodeMsg], fee, chainId, memo, accountNumber, sequence);\n        const result = await this.postTx(signedTx);\n        const codeIdAttr = logs_1.findAttribute(result.logs, \"message\", \"code_id\");\n        return {\n            originalSize: wasmCode.length,\n            originalChecksum: encoding_1.Encoding.toHex(new crypto_1.Sha256(wasmCode).digest()),\n            compressedSize: compressed.length,\n            compressedChecksum: encoding_1.Encoding.toHex(new crypto_1.Sha256(compressed).digest()),\n            codeId: Number.parseInt(codeIdAttr.value, 10),\n            logs: result.logs,\n            transactionHash: result.transactionHash,\n        };\n    }\n    async instantiate(codeId, initMsg, label, memo = \"\", transferAmount, fee = this.fees.init, contractCodeHash) {\n        var _a;\n        if (!contractCodeHash) {\n            contractCodeHash = await this.restClient.getCodeHashByCodeId(codeId);\n        }\n        else {\n            this.restClient.codeHashCache.set(codeId, contractCodeHash);\n        }\n        if (!memo) {\n            memo = \"\";\n        }\n        const instantiateMsg = {\n            type: \"wasm/MsgInstantiateContract\",\n            value: {\n                sender: this.senderAddress,\n                code_id: codeId.toString(),\n                label: label,\n                callback_code_hash: \"\",\n                init_msg: encoding_1.Encoding.toBase64(await this.restClient.enigmautils.encrypt(contractCodeHash, initMsg)),\n                init_funds: (transferAmount !== null && transferAmount !== void 0 ? transferAmount : []),\n                callback_sig: null,\n            },\n        };\n        const { accountNumber, sequence } = await this.getNonce();\n        const chainId = await this.getChainId();\n        const signedTx = await this.signAdapter([instantiateMsg], fee, chainId, memo, accountNumber, sequence);\n        const nonce = encoding_1.Encoding.fromBase64(instantiateMsg.value.init_msg).slice(0, 32);\n        let result;\n        try {\n            result = await this.postTx(signedTx);\n        }\n        catch (err) {\n            try {\n                const errorMessageRgx = /contract failed: encrypted: (.+?): failed to execute message; message index: 0/g;\n                const rgxMatches = errorMessageRgx.exec(err.message);\n                if (rgxMatches == null || rgxMatches.length != 2) {\n                    throw err;\n                }\n                const errorCipherB64 = rgxMatches[1];\n                const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n                const errorPlainBz = await this.restClient.enigmautils.decrypt(errorCipherBz, nonce);\n                err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n            }\n            catch (decryptionError) {\n                throw new Error(`Failed to decrypt the following error message: ${err.message}. Decryption error of the error message: ${decryptionError.message}`);\n            }\n            throw err;\n        }\n        let contractAddress = \"\";\n        if (this.restClient.broadcastMode == restclient_1.BroadcastMode.Block) {\n            contractAddress = (_a = logs_1.findAttribute(result.logs, \"message\", \"contract_address\")) === null || _a === void 0 ? void 0 : _a.value;\n        }\n        const logs = await this.restClient.decryptLogs(result.logs, [nonce]);\n        return {\n            contractAddress,\n            logs: logs,\n            transactionHash: result.transactionHash,\n            data: result.data,\n        };\n    }\n    async multiExecute(inputMsgs, memo = \"\", totalFee) {\n        var _a;\n        if (!memo) {\n            memo = \"\";\n        }\n        const msgs = [];\n        for (const inputMsg of inputMsgs) {\n            let { contractCodeHash } = inputMsg;\n            if (!contractCodeHash) {\n                contractCodeHash = await this.restClient.getCodeHashByContractAddr(inputMsg.contractAddress);\n            }\n            else {\n                this.restClient.codeHashCache.set(inputMsg.contractAddress, contractCodeHash);\n            }\n            const msg = {\n                type: \"wasm/MsgExecuteContract\",\n                value: {\n                    sender: this.senderAddress,\n                    contract: inputMsg.contractAddress,\n                    callback_code_hash: \"\",\n                    msg: encoding_1.Encoding.toBase64(await this.restClient.enigmautils.encrypt(contractCodeHash, inputMsg.handleMsg)),\n                    sent_funds: (_a = inputMsg.transferAmount, (_a !== null && _a !== void 0 ? _a : [])),\n                    callback_sig: null,\n                },\n            };\n            msgs.push(msg);\n        }\n        const { accountNumber, sequence } = await this.getNonce();\n        const fee = (totalFee !== null && totalFee !== void 0 ? totalFee : {\n            gas: String(Number(this.fees.exec.gas) * inputMsgs.length),\n            amount: this.fees.exec.amount,\n        });\n        const chainId = await this.getChainId();\n        const signedTx = await this.signAdapter(msgs, fee, chainId, memo, accountNumber, sequence);\n        let result;\n        try {\n            result = await this.postTx(signedTx);\n        }\n        catch (err) {\n            try {\n                const errorMessageRgx = /contract failed: encrypted: (.+?): failed to execute message; message index: (\\d+)/g;\n                const rgxMatches = errorMessageRgx.exec(err.message);\n                if (rgxMatches == null || rgxMatches.length != 3) {\n                    throw err;\n                }\n                const errorCipherB64 = rgxMatches[1];\n                const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n                const msgIndex = Number(rgxMatches[2]);\n                const nonce = encoding_1.Encoding.fromBase64(msgs[msgIndex].value.msg).slice(0, 32);\n                const errorPlainBz = await this.restClient.enigmautils.decrypt(errorCipherBz, nonce);\n                err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n            }\n            catch (decryptionError) {\n                throw new Error(`Failed to decrypt the following error message: ${err.message}. Decryption error of the error message: ${decryptionError.message}`);\n            }\n            throw err;\n        }\n        const nonces = msgs.map((msg) => encoding_1.Encoding.fromBase64(msg.value.msg).slice(0, 32));\n        const data = await this.restClient.decryptDataField(result.data, nonces);\n        const logs = await this.restClient.decryptLogs(result.logs, nonces);\n        return {\n            logs: logs,\n            transactionHash: result.transactionHash,\n            data: data,\n        };\n    }\n    async execute(contractAddress, handleMsg, memo = \"\", transferAmount, fee = this.fees.exec, contractCodeHash) {\n        if (!contractCodeHash) {\n            contractCodeHash = await this.restClient.getCodeHashByContractAddr(contractAddress);\n        }\n        else {\n            this.restClient.codeHashCache.set(contractAddress, contractCodeHash);\n        }\n        if (!memo) {\n            memo = \"\";\n        }\n        const executeMsg = {\n            type: \"wasm/MsgExecuteContract\",\n            value: {\n                sender: this.senderAddress,\n                contract: contractAddress,\n                callback_code_hash: \"\",\n                msg: encoding_1.Encoding.toBase64(await this.restClient.enigmautils.encrypt(contractCodeHash, handleMsg)),\n                sent_funds: (transferAmount !== null && transferAmount !== void 0 ? transferAmount : []),\n                callback_sig: null,\n            },\n        };\n        const { accountNumber, sequence } = await this.getNonce();\n        const chainId = await this.getChainId();\n        const signedTx = await this.signAdapter([executeMsg], fee, chainId, memo, accountNumber, sequence);\n        const nonce = encoding_1.Encoding.fromBase64(executeMsg.value.msg).slice(0, 32);\n        let result;\n        try {\n            result = await this.postTx(signedTx);\n        }\n        catch (err) {\n            try {\n                const errorMessageRgx = /contract failed: encrypted: (.+?): failed to execute message; message index: 0/g;\n                const rgxMatches = errorMessageRgx.exec(err.message);\n                if (rgxMatches == null || rgxMatches.length != 2) {\n                    throw err;\n                }\n                const errorCipherB64 = rgxMatches[1];\n                const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n                const errorPlainBz = await this.restClient.enigmautils.decrypt(errorCipherBz, nonce);\n                err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n            }\n            catch (decryptionError) {\n                throw new Error(`Failed to decrypt the following error message: ${err.message}. Decryption error of the error message: ${decryptionError.message}`);\n            }\n            throw err;\n        }\n        const data = await this.restClient.decryptDataField(result.data, [nonce]);\n        const logs = await this.restClient.decryptLogs(result.logs, [nonce]);\n        return {\n            logs: logs,\n            transactionHash: result.transactionHash,\n            data: data,\n        };\n    }\n    async sendTokens(recipientAddress, transferAmount, memo = \"\", fee = this.fees.send) {\n        const sendMsg = {\n            type: \"cosmos-sdk/MsgSend\",\n            value: {\n                // eslint-disable-next-line @typescript-eslint/camelcase\n                from_address: this.senderAddress,\n                // eslint-disable-next-line @typescript-eslint/camelcase\n                to_address: recipientAddress,\n                amount: transferAmount,\n            },\n        };\n        if (!memo) {\n            memo = \"\";\n        }\n        const { accountNumber, sequence } = await this.getNonce();\n        const chainId = await this.getChainId();\n        const signedTx = await this.signAdapter([sendMsg], fee, chainId, memo, accountNumber, sequence);\n        return this.postTx(signedTx);\n    }\n}\nexports.SigningCosmWasmClient = SigningCosmWasmClient;\n//# sourceMappingURL=signingcosmwasmclient.js.map"]},"metadata":{},"sourceType":"script"}