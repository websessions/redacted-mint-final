{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nconst prefixes = {\n  string: \"string:\",\n  bytes: \"bytes:\"\n};\n/**\n * Encodes non-circular JavaScript objects and primitives into JSON.\n * Used for encoding/decoding transactions but works for kind of data consisting of the supported types.\n *\n * Supported types:\n * - boolean\n * - number\n * - null\n * - object\n * - Array\n * - string\n * - Uint8Array\n */\n\nclass TransactionEncoder {\n  static toJson(data) {\n    if (typeof data === \"number\" || typeof data === \"boolean\") {\n      return data;\n    }\n\n    if (data === null) {\n      return null;\n    }\n\n    if (typeof data === \"string\") {\n      return `${prefixes.string}${data}`;\n    }\n\n    if (utils_1.isUint8Array(data)) {\n      return `${prefixes.bytes}${encoding_1.toHex(data)}`;\n    }\n\n    if (Array.isArray(data)) {\n      return data.map(TransactionEncoder.toJson);\n    } // Exclude special kind of objects like Array, Date or Uint8Array\n    // Object.prototype.toString() returns a specified value:\n    // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring\n\n\n    if (typeof data === \"object\" && data !== null && Object.prototype.toString.call(data) === \"[object Object]\") {\n      const out = {};\n\n      for (const key of Object.keys(data)) {\n        const value = data[key]; // Skip dictionary entries with value `undefined`, just like native JSON:\n        // > JSON.stringify({ foo: undefined })\n        // '{}'\n\n        if (value === undefined) continue; // tslint:disable-next-line: no-object-mutation\n\n        out[key] = TransactionEncoder.toJson(value);\n      }\n\n      return out;\n    }\n\n    throw new Error(\"Cannot encode type to JSON\");\n  }\n\n  static fromJson(data) {\n    if (typeof data === \"number\" || typeof data === \"boolean\") {\n      return data;\n    }\n\n    if (data === null) {\n      return null;\n    }\n\n    if (typeof data === \"string\") {\n      if (data.startsWith(prefixes.string)) {\n        return data.slice(prefixes.string.length);\n      }\n\n      if (data.startsWith(prefixes.bytes)) {\n        return encoding_1.fromHex(data.slice(prefixes.bytes.length));\n      }\n\n      throw new Error(\"Found string with unknown prefix\");\n    }\n\n    if (Array.isArray(data)) {\n      return data.map(TransactionEncoder.fromJson);\n    } // Exclude special kind of objects like Array, Date or Uint8Array\n    // Object.prototype.toString() returns a specified value:\n    // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring\n\n\n    if (typeof data === \"object\" && data !== null && Object.prototype.toString.call(data) === \"[object Object]\") {\n      const out = {};\n\n      for (const key of Object.keys(data)) {\n        // tslint:disable-next-line: no-object-mutation\n        out[key] = TransactionEncoder.fromJson(data[key]);\n      }\n\n      return out;\n    }\n\n    throw new Error(\"Cannot decode type from JSON\");\n  }\n\n}\n\nexports.TransactionEncoder = TransactionEncoder;","map":{"version":3,"sources":["../src/transactionencoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst prefixes = {\n    string: \"string:\",\n    bytes: \"bytes:\",\n};\n/**\n * Encodes non-circular JavaScript objects and primitives into JSON.\n * Used for encoding/decoding transactions but works for kind of data consisting of the supported types.\n *\n * Supported types:\n * - boolean\n * - number\n * - null\n * - object\n * - Array\n * - string\n * - Uint8Array\n */\nclass TransactionEncoder {\n    static toJson(data) {\n        if (typeof data === \"number\" || typeof data === \"boolean\") {\n            return data;\n        }\n        if (data === null) {\n            return null;\n        }\n        if (typeof data === \"string\") {\n            return `${prefixes.string}${data}`;\n        }\n        if (utils_1.isUint8Array(data)) {\n            return `${prefixes.bytes}${encoding_1.toHex(data)}`;\n        }\n        if (Array.isArray(data)) {\n            return data.map(TransactionEncoder.toJson);\n        }\n        // Exclude special kind of objects like Array, Date or Uint8Array\n        // Object.prototype.toString() returns a specified value:\n        // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring\n        if (typeof data === \"object\" &&\n            data !== null &&\n            Object.prototype.toString.call(data) === \"[object Object]\") {\n            const out = {};\n            for (const key of Object.keys(data)) {\n                const value = data[key];\n                // Skip dictionary entries with value `undefined`, just like native JSON:\n                // > JSON.stringify({ foo: undefined })\n                // '{}'\n                if (value === undefined)\n                    continue;\n                // tslint:disable-next-line: no-object-mutation\n                out[key] = TransactionEncoder.toJson(value);\n            }\n            return out;\n        }\n        throw new Error(\"Cannot encode type to JSON\");\n    }\n    static fromJson(data) {\n        if (typeof data === \"number\" || typeof data === \"boolean\") {\n            return data;\n        }\n        if (data === null) {\n            return null;\n        }\n        if (typeof data === \"string\") {\n            if (data.startsWith(prefixes.string)) {\n                return data.slice(prefixes.string.length);\n            }\n            if (data.startsWith(prefixes.bytes)) {\n                return encoding_1.fromHex(data.slice(prefixes.bytes.length));\n            }\n            throw new Error(\"Found string with unknown prefix\");\n        }\n        if (Array.isArray(data)) {\n            return data.map(TransactionEncoder.fromJson);\n        }\n        // Exclude special kind of objects like Array, Date or Uint8Array\n        // Object.prototype.toString() returns a specified value:\n        // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring\n        if (typeof data === \"object\" &&\n            data !== null &&\n            Object.prototype.toString.call(data) === \"[object Object]\") {\n            const out = {};\n            for (const key of Object.keys(data)) {\n                // tslint:disable-next-line: no-object-mutation\n                out[key] = TransactionEncoder.fromJson(data[key]);\n            }\n            return out;\n        }\n        throw new Error(\"Cannot decode type from JSON\");\n    }\n}\nexports.TransactionEncoder = TransactionEncoder;\n//# sourceMappingURL=transactionencoder.js.map"]},"metadata":{},"sourceType":"script"}