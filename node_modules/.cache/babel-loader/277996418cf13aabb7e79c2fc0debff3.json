{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst encoding_1 = require(\"@iov/encoding\");\n\nconst axios_1 = __importDefault(require(\"axios\"));\n\nconst enigmautils_1 = __importDefault(require(\"./enigmautils\"));\n\nfunction normalizeArray(backend) {\n  return backend || [];\n}\n/**\n * The mode used to send transaction\n *\n * @see https://cosmos.network/rpc/#/Transactions/post_txs\n */\n\n\nvar BroadcastMode;\n\n(function (BroadcastMode) {\n  /** Return after tx commit */\n  BroadcastMode[\"Block\"] = \"block\";\n  /** Return afer CheckTx */\n\n  BroadcastMode[\"Sync\"] = \"sync\";\n  /** Return right away */\n\n  BroadcastMode[\"Async\"] = \"async\";\n})(BroadcastMode = exports.BroadcastMode || (exports.BroadcastMode = {}));\n\nfunction isWasmError(resp) {\n  return resp.error !== undefined;\n}\n\nfunction unwrapWasmResponse(response) {\n  if (isWasmError(response)) {\n    throw new Error(response.error);\n  }\n\n  return response.result;\n} // We want to get message data from 500 errors\n// https://stackoverflow.com/questions/56577124/how-to-handle-500-error-message-with-axios\n// this should be chained to catch one error and throw a more informative one\n\n\nfunction parseAxiosError(err) {\n  var _a; // use the error message sent from server, not default 500 msg\n\n\n  if ((_a = err.response) === null || _a === void 0 ? void 0 : _a.data) {\n    let errorText;\n    const data = err.response.data; // expect { error: string }, but otherwise dump\n\n    if (data.error && typeof data.error === \"string\") {\n      errorText = data.error;\n    } else if (typeof data === \"string\") {\n      errorText = data;\n    } else {\n      errorText = JSON.stringify(data);\n    }\n\n    throw new Error(`${errorText} (HTTP ${err.response.status})`);\n  } else {\n    throw err;\n  }\n}\n\nclass RestClient {\n  /**\n   * Creates a new client to interact with a Cosmos SDK light client daemon.\n   * This class tries to be a direct mapping onto the API. Some basic decoding and normalizatin is done\n   * but things like caching are done at a higher level.\n   *\n   * When building apps, you should not need to use this class directly. If you do, this indicates a missing feature\n   * in higher level components. Feel free to raise an issue in this case.\n   *\n   * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n   * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n   * @param seed - The seed used to generate sender TX encryption key. If empty will generate random new one\n   */\n  constructor(apiUrl) {\n    let broadcastMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BroadcastMode.Block;\n    let seed = arguments.length > 2 ? arguments[2] : undefined;\n    const headers = {\n      post: {\n        \"Content-Type\": \"application/json\"\n      }\n    };\n    this.client = axios_1.default.create({\n      baseURL: apiUrl,\n      headers: headers\n    });\n    this.broadcastMode = broadcastMode;\n    this.enigmautils = new enigmautils_1.default(apiUrl, seed);\n    this.codeHashCache = new Map();\n  }\n\n  async get(path) {\n    const {\n      data\n    } = await this.client.get(path).catch(parseAxiosError);\n\n    if (data === null) {\n      throw new Error(\"Received null response from server\");\n    }\n\n    return data;\n  }\n\n  async post(path, params) {\n    if (!encoding_1.isNonNullObject(params)) throw new Error(\"Got unexpected type of params. Expected object.\");\n    const {\n      data\n    } = await this.client.post(path, params).catch(parseAxiosError);\n\n    if (data === null) {\n      throw new Error(\"Received null response from server\");\n    }\n\n    return data;\n  } // The /auth endpoints\n\n\n  async authAccounts(address) {\n    const path = `/auth/accounts/${address}`;\n    const responseData = await this.get(path);\n\n    if (responseData.result.type !== \"cosmos-sdk/Account\") {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return responseData;\n  } // The /blocks endpoints\n\n\n  async blocksLatest() {\n    const responseData = await this.get(\"/blocks/latest\");\n\n    if (!responseData.block) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return responseData;\n  }\n\n  async blocks(height) {\n    const responseData = await this.get(`/blocks/${height}`);\n\n    if (!responseData.block) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return responseData;\n  } // The /node_info endpoint\n\n\n  async nodeInfo() {\n    const responseData = await this.get(\"/node_info\");\n\n    if (!responseData.node_info) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return responseData;\n  } // The /txs endpoints\n\n\n  async txById(id) {\n    let tryToDecrypt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const responseData = await this.get(`/txs/${id}`);\n\n    if (!responseData.tx) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    if (tryToDecrypt) {\n      return this.decryptTxsResponse(responseData);\n    } else {\n      return responseData;\n    }\n  }\n\n  async txsQuery(query) {\n    const responseData = await this.get(`/txs?${query}`);\n\n    if (!responseData.txs) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    const resp = responseData;\n\n    for (let i = 0; i < resp.txs.length; i++) {\n      resp.txs[i] = await this.decryptTxsResponse(resp.txs[i]);\n    }\n\n    return resp;\n  }\n  /** returns the amino-encoding of the transaction performed by the server */\n\n\n  async encodeTx(tx) {\n    const responseData = await this.post(\"/txs/encode\", tx);\n\n    if (!responseData.tx) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return encoding_1.Encoding.fromBase64(responseData.tx);\n  }\n  /**\n   * Broadcasts a signed transaction to into the transaction pool.\n   * Depending on the RestClient's broadcast mode, this might or might\n   * wait for checkTx or deliverTx to be executed before returning.\n   *\n   * @param tx a signed transaction as StdTx (i.e. not wrapped in type/value container)\n   */\n\n\n  async postTx(tx) {\n    const params = {\n      tx: tx,\n      mode: this.broadcastMode\n    };\n    const responseData = await this.post(\"/txs\", params);\n\n    if (!responseData.txhash) {\n      throw new Error(\"Unexpected response data format\");\n    }\n\n    return responseData;\n  } // The /wasm endpoints\n  // wasm rest queries are listed here: https://github.com/cosmwasm/wasmd/blob/master/x/wasm/client/rest/query.go#L19-L27\n\n\n  async listCodeInfo() {\n    const path = `/wasm/code`;\n    const responseData = await this.get(path);\n    return normalizeArray(await unwrapWasmResponse(responseData));\n  } // this will download the original wasm bytecode by code id\n  // throws error if no code with this id\n\n\n  async getCode(id) {\n    const path = `/wasm/code/${id}`;\n    const responseData = await this.get(path);\n    return await unwrapWasmResponse(responseData);\n  }\n\n  async listContractsByCodeId(id) {\n    const path = `/wasm/code/${id}/contracts`;\n    const responseData = await this.get(path);\n    return normalizeArray(await unwrapWasmResponse(responseData));\n  }\n\n  async getCodeHashByCodeId(id) {\n    const codeHashFromCache = this.codeHashCache.get(id);\n\n    if (typeof codeHashFromCache === \"string\") {\n      return codeHashFromCache;\n    }\n\n    const path = `/wasm/code/${id}/hash`;\n    const responseData = await this.get(path);\n    this.codeHashCache.set(id, responseData.result);\n    return responseData.result;\n  }\n\n  async getCodeHashByContractAddr(addr) {\n    const codeHashFromCache = this.codeHashCache.get(addr);\n\n    if (typeof codeHashFromCache === \"string\") {\n      return codeHashFromCache;\n    }\n\n    const path = `/wasm/contract/${addr}/code-hash`;\n    const responseData = await this.get(path);\n    this.codeHashCache.set(addr, responseData.result);\n    return responseData.result;\n  }\n  /**\n   * Returns null when contract was not found at this address.\n   */\n\n\n  async getContractInfo(address) {\n    const path = `/wasm/contract/${address}`;\n    const response = await this.get(path);\n    return await unwrapWasmResponse(response);\n  }\n  /**\n   * Makes a smart query on the contract and parses the reponse as JSON.\n   * Throws error if no such contract exists, the query format is invalid or the response is invalid.\n   */\n\n\n  async queryContractSmart(contractAddress, query, addedParams, contractCodeHash) {\n    if (!contractCodeHash) {\n      contractCodeHash = await this.getCodeHashByContractAddr(contractAddress);\n    } else {\n      this.codeHashCache.set(contractAddress, contractCodeHash);\n    }\n\n    const encrypted = await this.enigmautils.encrypt(contractCodeHash, query);\n    const nonce = encrypted.slice(0, 32);\n    const encoded = encoding_1.Encoding.toHex(encoding_1.Encoding.toUtf8(encoding_1.Encoding.toBase64(encrypted))); // @ts-ignore\n\n    const paramString = new URLSearchParams(addedParams).toString();\n    const path = `/wasm/contract/${contractAddress}/query/${encoded}?encoding=hex&${paramString}`;\n    let responseData;\n\n    try {\n      responseData = await this.get(path);\n    } catch (err) {\n      try {\n        const errorMessageRgx = /contract failed: encrypted: (.+?) \\(HTTP 500\\)/g;\n        const rgxMatches = errorMessageRgx.exec(err.message);\n\n        if (rgxMatches == null || rgxMatches.length != 2) {\n          throw err;\n        }\n\n        const errorCipherB64 = rgxMatches[1];\n        const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n        const errorPlainBz = await this.enigmautils.decrypt(errorCipherBz, nonce);\n        err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n      } catch (decryptionError) {\n        throw new Error(`Failed to decrypt the following error message: ${err.message}.`);\n      }\n\n      throw err;\n    }\n\n    if (isWasmError(responseData)) {\n      throw new Error(JSON.stringify(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(responseData.error), nonce)));\n    } // By convention, smart queries must return a valid JSON document (see https://github.com/CosmWasm/cosmwasm/issues/144)\n\n\n    return JSON.parse(encoding_1.Encoding.fromUtf8(encoding_1.Encoding.fromBase64(encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(responseData.result.smart), nonce)))));\n  }\n  /**\n   * Get the consensus keypair for IO encryption\n   */\n\n\n  async getMasterCerts(address, query) {\n    return this.get(\"/register/master-cert\");\n  }\n\n  async decryptDataField() {\n    let dataField = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let nonces = arguments.length > 1 ? arguments[1] : undefined;\n    const wasmOutputDataCipherBz = encoding_1.Encoding.fromHex(dataField);\n    let error;\n\n    for (const nonce of nonces) {\n      try {\n        const data = encoding_1.Encoding.fromBase64(encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(wasmOutputDataCipherBz, nonce)));\n        return data;\n      } catch (e) {\n        error = e;\n      }\n    }\n\n    throw error;\n  }\n\n  async decryptLogs(logs, nonces) {\n    for (const l of logs) {\n      for (const e of l.events) {\n        if (e.type === \"wasm\") {\n          for (const nonce of nonces) {\n            let nonceOk = false;\n\n            for (const a of e.attributes) {\n              try {\n                a.key = encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(a.key), nonce));\n                nonceOk = true;\n              } catch (e) {}\n\n              try {\n                a.value = encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(a.value), nonce));\n                nonceOk = true;\n              } catch (e) {}\n            }\n\n            if (nonceOk) {\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    return logs;\n  }\n\n  async decryptTxsResponse(txsResponse) {\n    for (let i = 0; i < txsResponse.tx.value.msg.length; i++) {\n      const msg = txsResponse.tx.value.msg[i];\n      let inputMsgEncrypted;\n\n      if (msg.type === \"wasm/MsgExecuteContract\") {\n        inputMsgEncrypted = encoding_1.Encoding.fromBase64(msg.value.msg);\n      } else if (msg.type === \"wasm/MsgInstantiateContract\") {\n        inputMsgEncrypted = encoding_1.Encoding.fromBase64(msg.value.init_msg);\n      } else {\n        continue;\n      }\n\n      const inputMsgPubkey = inputMsgEncrypted.slice(32, 64);\n\n      if (encoding_1.Encoding.toBase64(await this.enigmautils.getPubkey()) === encoding_1.Encoding.toBase64(inputMsgPubkey)) {\n        // my pubkey, can decrypt\n        const nonce = inputMsgEncrypted.slice(0, 32); // decrypt input\n\n        const inputMsg = encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(inputMsgEncrypted.slice(64), nonce));\n\n        if (msg.type === \"wasm/MsgExecuteContract\") {\n          // decrypt input\n          txsResponse.tx.value.msg[i].value.msg = inputMsg; // decrypt output\n          // stupid workaround because only 1st message data is returned\n\n          if (i == 0 && txsResponse.data) {\n            txsResponse.data = await this.decryptDataField(txsResponse.data, [nonce]);\n          }\n        } else if (msg.type === \"wasm/MsgInstantiateContract\") {\n          // decrypt input\n          txsResponse.tx.value.msg[i].value.init_msg = inputMsg;\n        } // decrypt output logs\n\n\n        let logs;\n\n        if (txsResponse.logs) {\n          logs = await this.decryptLogs(txsResponse.logs, [nonce]);\n          txsResponse = Object.assign({}, txsResponse, {\n            logs: logs\n          });\n        } // decrypt error\n\n\n        const errorMessageRgx = /contract failed: encrypted: (.+?): failed to execute message/g;\n        const rgxMatches = errorMessageRgx.exec(txsResponse.raw_log);\n\n        if (Array.isArray(rgxMatches) && rgxMatches.length === 2) {\n          const errorCipherB64 = rgxMatches[1];\n          const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n          const errorPlainBz = await this.enigmautils.decrypt(errorCipherBz, nonce);\n          txsResponse.raw_log = txsResponse.raw_log.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n        }\n      }\n    }\n\n    return txsResponse;\n  }\n\n}\n\nexports.RestClient = RestClient;","map":{"version":3,"sources":["../src/restclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst encoding_1 = require(\"@iov/encoding\");\nconst axios_1 = __importDefault(require(\"axios\"));\nconst enigmautils_1 = __importDefault(require(\"./enigmautils\"));\nfunction normalizeArray(backend) {\n    return backend || [];\n}\n/**\n * The mode used to send transaction\n *\n * @see https://cosmos.network/rpc/#/Transactions/post_txs\n */\nvar BroadcastMode;\n(function (BroadcastMode) {\n    /** Return after tx commit */\n    BroadcastMode[\"Block\"] = \"block\";\n    /** Return afer CheckTx */\n    BroadcastMode[\"Sync\"] = \"sync\";\n    /** Return right away */\n    BroadcastMode[\"Async\"] = \"async\";\n})(BroadcastMode = exports.BroadcastMode || (exports.BroadcastMode = {}));\nfunction isWasmError(resp) {\n    return resp.error !== undefined;\n}\nfunction unwrapWasmResponse(response) {\n    if (isWasmError(response)) {\n        throw new Error(response.error);\n    }\n    return response.result;\n}\n// We want to get message data from 500 errors\n// https://stackoverflow.com/questions/56577124/how-to-handle-500-error-message-with-axios\n// this should be chained to catch one error and throw a more informative one\nfunction parseAxiosError(err) {\n    var _a;\n    // use the error message sent from server, not default 500 msg\n    if ((_a = err.response) === null || _a === void 0 ? void 0 : _a.data) {\n        let errorText;\n        const data = err.response.data;\n        // expect { error: string }, but otherwise dump\n        if (data.error && typeof data.error === \"string\") {\n            errorText = data.error;\n        }\n        else if (typeof data === \"string\") {\n            errorText = data;\n        }\n        else {\n            errorText = JSON.stringify(data);\n        }\n        throw new Error(`${errorText} (HTTP ${err.response.status})`);\n    }\n    else {\n        throw err;\n    }\n}\nclass RestClient {\n    /**\n     * Creates a new client to interact with a Cosmos SDK light client daemon.\n     * This class tries to be a direct mapping onto the API. Some basic decoding and normalizatin is done\n     * but things like caching are done at a higher level.\n     *\n     * When building apps, you should not need to use this class directly. If you do, this indicates a missing feature\n     * in higher level components. Feel free to raise an issue in this case.\n     *\n     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n     * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n     * @param seed - The seed used to generate sender TX encryption key. If empty will generate random new one\n     */\n    constructor(apiUrl, broadcastMode = BroadcastMode.Block, seed) {\n        const headers = {\n            post: { \"Content-Type\": \"application/json\" },\n        };\n        this.client = axios_1.default.create({\n            baseURL: apiUrl,\n            headers: headers,\n        });\n        this.broadcastMode = broadcastMode;\n        this.enigmautils = new enigmautils_1.default(apiUrl, seed);\n        this.codeHashCache = new Map();\n    }\n    async get(path) {\n        const { data } = await this.client.get(path).catch(parseAxiosError);\n        if (data === null) {\n            throw new Error(\"Received null response from server\");\n        }\n        return data;\n    }\n    async post(path, params) {\n        if (!encoding_1.isNonNullObject(params))\n            throw new Error(\"Got unexpected type of params. Expected object.\");\n        const { data } = await this.client.post(path, params).catch(parseAxiosError);\n        if (data === null) {\n            throw new Error(\"Received null response from server\");\n        }\n        return data;\n    }\n    // The /auth endpoints\n    async authAccounts(address) {\n        const path = `/auth/accounts/${address}`;\n        const responseData = await this.get(path);\n        if (responseData.result.type !== \"cosmos-sdk/Account\") {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return responseData;\n    }\n    // The /blocks endpoints\n    async blocksLatest() {\n        const responseData = await this.get(\"/blocks/latest\");\n        if (!responseData.block) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return responseData;\n    }\n    async blocks(height) {\n        const responseData = await this.get(`/blocks/${height}`);\n        if (!responseData.block) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return responseData;\n    }\n    // The /node_info endpoint\n    async nodeInfo() {\n        const responseData = await this.get(\"/node_info\");\n        if (!responseData.node_info) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return responseData;\n    }\n    // The /txs endpoints\n    async txById(id, tryToDecrypt = true) {\n        const responseData = await this.get(`/txs/${id}`);\n        if (!responseData.tx) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        if (tryToDecrypt) {\n            return this.decryptTxsResponse(responseData);\n        }\n        else {\n            return responseData;\n        }\n    }\n    async txsQuery(query) {\n        const responseData = await this.get(`/txs?${query}`);\n        if (!responseData.txs) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        const resp = responseData;\n        for (let i = 0; i < resp.txs.length; i++) {\n            resp.txs[i] = await this.decryptTxsResponse(resp.txs[i]);\n        }\n        return resp;\n    }\n    /** returns the amino-encoding of the transaction performed by the server */\n    async encodeTx(tx) {\n        const responseData = await this.post(\"/txs/encode\", tx);\n        if (!responseData.tx) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return encoding_1.Encoding.fromBase64(responseData.tx);\n    }\n    /**\n     * Broadcasts a signed transaction to into the transaction pool.\n     * Depending on the RestClient's broadcast mode, this might or might\n     * wait for checkTx or deliverTx to be executed before returning.\n     *\n     * @param tx a signed transaction as StdTx (i.e. not wrapped in type/value container)\n     */\n    async postTx(tx) {\n        const params = {\n            tx: tx,\n            mode: this.broadcastMode,\n        };\n        const responseData = await this.post(\"/txs\", params);\n        if (!responseData.txhash) {\n            throw new Error(\"Unexpected response data format\");\n        }\n        return responseData;\n    }\n    // The /wasm endpoints\n    // wasm rest queries are listed here: https://github.com/cosmwasm/wasmd/blob/master/x/wasm/client/rest/query.go#L19-L27\n    async listCodeInfo() {\n        const path = `/wasm/code`;\n        const responseData = (await this.get(path));\n        return normalizeArray(await unwrapWasmResponse(responseData));\n    }\n    // this will download the original wasm bytecode by code id\n    // throws error if no code with this id\n    async getCode(id) {\n        const path = `/wasm/code/${id}`;\n        const responseData = (await this.get(path));\n        return await unwrapWasmResponse(responseData);\n    }\n    async listContractsByCodeId(id) {\n        const path = `/wasm/code/${id}/contracts`;\n        const responseData = (await this.get(path));\n        return normalizeArray(await unwrapWasmResponse(responseData));\n    }\n    async getCodeHashByCodeId(id) {\n        const codeHashFromCache = this.codeHashCache.get(id);\n        if (typeof codeHashFromCache === \"string\") {\n            return codeHashFromCache;\n        }\n        const path = `/wasm/code/${id}/hash`;\n        const responseData = (await this.get(path));\n        this.codeHashCache.set(id, responseData.result);\n        return responseData.result;\n    }\n    async getCodeHashByContractAddr(addr) {\n        const codeHashFromCache = this.codeHashCache.get(addr);\n        if (typeof codeHashFromCache === \"string\") {\n            return codeHashFromCache;\n        }\n        const path = `/wasm/contract/${addr}/code-hash`;\n        const responseData = (await this.get(path));\n        this.codeHashCache.set(addr, responseData.result);\n        return responseData.result;\n    }\n    /**\n     * Returns null when contract was not found at this address.\n     */\n    async getContractInfo(address) {\n        const path = `/wasm/contract/${address}`;\n        const response = (await this.get(path));\n        return await unwrapWasmResponse(response);\n    }\n    /**\n     * Makes a smart query on the contract and parses the reponse as JSON.\n     * Throws error if no such contract exists, the query format is invalid or the response is invalid.\n     */\n    async queryContractSmart(contractAddress, query, addedParams, contractCodeHash) {\n        if (!contractCodeHash) {\n            contractCodeHash = await this.getCodeHashByContractAddr(contractAddress);\n        }\n        else {\n            this.codeHashCache.set(contractAddress, contractCodeHash);\n        }\n        const encrypted = await this.enigmautils.encrypt(contractCodeHash, query);\n        const nonce = encrypted.slice(0, 32);\n        const encoded = encoding_1.Encoding.toHex(encoding_1.Encoding.toUtf8(encoding_1.Encoding.toBase64(encrypted)));\n        // @ts-ignore\n        const paramString = new URLSearchParams(addedParams).toString();\n        const path = `/wasm/contract/${contractAddress}/query/${encoded}?encoding=hex&${paramString}`;\n        let responseData;\n        try {\n            responseData = (await this.get(path));\n        }\n        catch (err) {\n            try {\n                const errorMessageRgx = /contract failed: encrypted: (.+?) \\(HTTP 500\\)/g;\n                const rgxMatches = errorMessageRgx.exec(err.message);\n                if (rgxMatches == null || rgxMatches.length != 2) {\n                    throw err;\n                }\n                const errorCipherB64 = rgxMatches[1];\n                const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n                const errorPlainBz = await this.enigmautils.decrypt(errorCipherBz, nonce);\n                err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n            }\n            catch (decryptionError) {\n                throw new Error(`Failed to decrypt the following error message: ${err.message}.`);\n            }\n            throw err;\n        }\n        if (isWasmError(responseData)) {\n            throw new Error(JSON.stringify(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(responseData.error), nonce)));\n        }\n        // By convention, smart queries must return a valid JSON document (see https://github.com/CosmWasm/cosmwasm/issues/144)\n        return JSON.parse(encoding_1.Encoding.fromUtf8(encoding_1.Encoding.fromBase64(encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(responseData.result.smart), nonce)))));\n    }\n    /**\n     * Get the consensus keypair for IO encryption\n     */\n    async getMasterCerts(address, query) {\n        return this.get(\"/register/master-cert\");\n    }\n    async decryptDataField(dataField = \"\", nonces) {\n        const wasmOutputDataCipherBz = encoding_1.Encoding.fromHex(dataField);\n        let error;\n        for (const nonce of nonces) {\n            try {\n                const data = encoding_1.Encoding.fromBase64(encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(wasmOutputDataCipherBz, nonce)));\n                return data;\n            }\n            catch (e) {\n                error = e;\n            }\n        }\n        throw error;\n    }\n    async decryptLogs(logs, nonces) {\n        for (const l of logs) {\n            for (const e of l.events) {\n                if (e.type === \"wasm\") {\n                    for (const nonce of nonces) {\n                        let nonceOk = false;\n                        for (const a of e.attributes) {\n                            try {\n                                a.key = encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(a.key), nonce));\n                                nonceOk = true;\n                            }\n                            catch (e) { }\n                            try {\n                                a.value = encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(encoding_1.Encoding.fromBase64(a.value), nonce));\n                                nonceOk = true;\n                            }\n                            catch (e) { }\n                        }\n                        if (nonceOk) {\n                            continue;\n                        }\n                    }\n                }\n            }\n        }\n        return logs;\n    }\n    async decryptTxsResponse(txsResponse) {\n        for (let i = 0; i < txsResponse.tx.value.msg.length; i++) {\n            const msg = txsResponse.tx.value.msg[i];\n            let inputMsgEncrypted;\n            if (msg.type === \"wasm/MsgExecuteContract\") {\n                inputMsgEncrypted = encoding_1.Encoding.fromBase64(msg.value.msg);\n            }\n            else if (msg.type === \"wasm/MsgInstantiateContract\") {\n                inputMsgEncrypted = encoding_1.Encoding.fromBase64(msg.value.init_msg);\n            }\n            else {\n                continue;\n            }\n            const inputMsgPubkey = inputMsgEncrypted.slice(32, 64);\n            if (encoding_1.Encoding.toBase64(await this.enigmautils.getPubkey()) === encoding_1.Encoding.toBase64(inputMsgPubkey)) {\n                // my pubkey, can decrypt\n                const nonce = inputMsgEncrypted.slice(0, 32);\n                // decrypt input\n                const inputMsg = encoding_1.Encoding.fromUtf8(await this.enigmautils.decrypt(inputMsgEncrypted.slice(64), nonce));\n                if (msg.type === \"wasm/MsgExecuteContract\") {\n                    // decrypt input\n                    txsResponse.tx.value.msg[i].value.msg = inputMsg;\n                    // decrypt output\n                    // stupid workaround because only 1st message data is returned\n                    if (i == 0 && txsResponse.data) {\n                        txsResponse.data = await this.decryptDataField(txsResponse.data, [nonce]);\n                    }\n                }\n                else if (msg.type === \"wasm/MsgInstantiateContract\") {\n                    // decrypt input\n                    txsResponse.tx.value.msg[i].value.init_msg = inputMsg;\n                }\n                // decrypt output logs\n                let logs;\n                if (txsResponse.logs) {\n                    logs = await this.decryptLogs(txsResponse.logs, [nonce]);\n                    txsResponse = Object.assign({}, txsResponse, { logs: logs });\n                }\n                // decrypt error\n                const errorMessageRgx = /contract failed: encrypted: (.+?): failed to execute message/g;\n                const rgxMatches = errorMessageRgx.exec(txsResponse.raw_log);\n                if (Array.isArray(rgxMatches) && rgxMatches.length === 2) {\n                    const errorCipherB64 = rgxMatches[1];\n                    const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);\n                    const errorPlainBz = await this.enigmautils.decrypt(errorCipherBz, nonce);\n                    txsResponse.raw_log = txsResponse.raw_log.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));\n                }\n            }\n        }\n        return txsResponse;\n    }\n}\nexports.RestClient = RestClient;\n//# sourceMappingURL=restclient.js.map"]},"metadata":{},"sourceType":"script"}