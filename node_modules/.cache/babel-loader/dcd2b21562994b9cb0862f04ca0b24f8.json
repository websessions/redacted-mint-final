{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar encoding_1 = require(\"@iov/encoding\");\n\nvar pubkey_1 = require(\"./pubkey\");\n\nvar types_1 = require(\"./types\");\n/**\n * Takes a binary pubkey and signature to create a signature object\n *\n * @param pubkey a compressed secp256k1 public key\n * @param signature a 64 byte fixed length representation of secp256k1 signature components r and s\n */\n\n\nfunction encodeSecp256k1Signature(pubkey, signature) {\n  if (signature.length !== 64) {\n    throw new Error(\"Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.\");\n  }\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/camelcase\n    pub_key: pubkey_1.encodeSecp256k1Pubkey(pubkey),\n    signature: encoding_1.Encoding.toBase64(signature)\n  };\n}\n\nexports.encodeSecp256k1Signature = encodeSecp256k1Signature;\n\nfunction decodeSignature(signature) {\n  switch (signature.pub_key.type) {\n    // Note: please don't add cases here without writing additional unit tests\n    case types_1.pubkeyType.secp256k1:\n      return {\n        pubkey: encoding_1.Encoding.fromBase64(signature.pub_key.value),\n        signature: encoding_1.Encoding.fromBase64(signature.signature)\n      };\n\n    default:\n      throw new Error(\"Unsupported pubkey type\");\n  }\n}\n\nexports.decodeSignature = decodeSignature;","map":{"version":3,"sources":["../src/signature.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,UAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA;;;;;AAKG;;;AACH,SAAgB,wBAAhB,CAAyC,MAAzC,EAA6D,SAA7D,EAAkF;AAChF,MAAI,SAAS,CAAC,MAAV,KAAqB,EAAzB,EAA6B;AAC3B,UAAM,IAAI,KAAJ,CACJ,kIADI,CAAN;AAGD;;AAED,SAAO;AACL;AACA,IAAA,OAAO,EAAE,QAAA,CAAA,qBAAA,CAAsB,MAAtB,CAFJ;AAGL,IAAA,SAAS,EAAE,UAAA,CAAA,QAAA,CAAS,QAAT,CAAkB,SAAlB;AAHN,GAAP;AAKD;;AAZD,OAAA,CAAA,wBAAA,GAAA,wBAAA;;AAcA,SAAgB,eAAhB,CACE,SADF,EACyB;AAEvB,UAAQ,SAAS,CAAC,OAAV,CAAkB,IAA1B;AACE;AACA,SAAK,OAAA,CAAA,UAAA,CAAW,SAAhB;AACE,aAAO;AACL,QAAA,MAAM,EAAE,UAAA,CAAA,QAAA,CAAS,UAAT,CAAoB,SAAS,CAAC,OAAV,CAAkB,KAAtC,CADH;AAEL,QAAA,SAAS,EAAE,UAAA,CAAA,QAAA,CAAS,UAAT,CAAoB,SAAS,CAAC,SAA9B;AAFN,OAAP;;AAIF;AACE,YAAM,IAAI,KAAJ,CAAU,yBAAV,CAAN;AARJ;AAUD;;AAbD,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst encoding_1 = require(\"@iov/encoding\");\nconst pubkey_1 = require(\"./pubkey\");\nconst types_1 = require(\"./types\");\n/**\n * Takes a binary pubkey and signature to create a signature object\n *\n * @param pubkey a compressed secp256k1 public key\n * @param signature a 64 byte fixed length representation of secp256k1 signature components r and s\n */\nfunction encodeSecp256k1Signature(pubkey, signature) {\n    if (signature.length !== 64) {\n        throw new Error(\"Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.\");\n    }\n    return {\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        pub_key: pubkey_1.encodeSecp256k1Pubkey(pubkey),\n        signature: encoding_1.Encoding.toBase64(signature),\n    };\n}\nexports.encodeSecp256k1Signature = encodeSecp256k1Signature;\nfunction decodeSignature(signature) {\n    switch (signature.pub_key.type) {\n        // Note: please don't add cases here without writing additional unit tests\n        case types_1.pubkeyType.secp256k1:\n            return {\n                pubkey: encoding_1.Encoding.fromBase64(signature.pub_key.value),\n                signature: encoding_1.Encoding.fromBase64(signature.signature),\n            };\n        default:\n            throw new Error(\"Unsupported pubkey type\");\n    }\n}\nexports.decodeSignature = decodeSignature;\n//# sourceMappingURL=signature.js.map"]},"metadata":{},"sourceType":"script"}