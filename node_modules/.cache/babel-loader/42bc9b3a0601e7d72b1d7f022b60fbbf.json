{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016-2017 Dmitry Chestnykh, Tony Arcieri\n// MIT License. See LICENSE file for details.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst block_1 = require(\"../internals/block\");\n\nconst xor_1 = require(\"../internals/xor\");\n/**\n * The AES-CMAC message authentication code\n */\n\n\nclass CMAC {\n  constructor(_cipher, _subkey1, _subkey2) {\n    this._cipher = _cipher;\n    this._subkey1 = _subkey1;\n    this._subkey2 = _subkey2;\n    this._bufferPos = 0;\n    this._finished = false;\n    this._buffer = new block_1.default();\n  }\n  /** Create a new CMAC instance from the given key */\n\n\n  static importKey(provider, keyData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const cipher = yield provider.importBlockCipherKey(keyData); // Generate subkeys.\n\n      const subkey1 = new block_1.default();\n      yield cipher.encryptBlock(subkey1);\n      subkey1.dbl();\n      const subkey2 = subkey1.clone();\n      subkey2.dbl();\n      return new CMAC(cipher, subkey1, subkey2);\n    });\n  }\n\n  reset() {\n    this._buffer.clear();\n\n    this._bufferPos = 0;\n    this._finished = false;\n    return this;\n  }\n\n  clear() {\n    this.reset();\n\n    this._subkey1.clear();\n\n    this._subkey2.clear();\n  }\n\n  update(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const left = block_1.default.SIZE - this._bufferPos;\n      let dataPos = 0;\n      let dataLength = data.length;\n\n      if (dataLength > left) {\n        for (let i = 0; i < left; i++) {\n          this._buffer.data[this._bufferPos + i] ^= data[i];\n        }\n\n        dataLength -= left;\n        dataPos += left;\n        yield this._cipher.encryptBlock(this._buffer);\n        this._bufferPos = 0;\n      } // TODO: use AES-CBC with a span of multiple blocks instead of encryptBlock\n      // to encrypt many blocks in a single call to the WebCrypto API\n\n\n      while (dataLength > block_1.default.SIZE) {\n        for (let i = 0; i < block_1.default.SIZE; i++) {\n          this._buffer.data[i] ^= data[dataPos + i];\n        }\n\n        dataLength -= block_1.default.SIZE;\n        dataPos += block_1.default.SIZE;\n        yield this._cipher.encryptBlock(this._buffer);\n      }\n\n      for (let i = 0; i < dataLength; i++) {\n        this._buffer.data[this._bufferPos++] ^= data[dataPos + i];\n      }\n\n      return this;\n    });\n  }\n\n  finish() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._finished) {\n        // Select which subkey to use.\n        const subkey = this._bufferPos < block_1.default.SIZE ? this._subkey2 : this._subkey1; // XOR in the subkey.\n\n        xor_1.xor(this._buffer.data, subkey.data); // Pad if needed.\n\n        if (this._bufferPos < block_1.default.SIZE) {\n          this._buffer.data[this._bufferPos] ^= 0x80;\n        } // Encrypt buffer to get the final digest.\n\n\n        yield this._cipher.encryptBlock(this._buffer); // Set finished flag.\n\n        this._finished = true;\n      }\n\n      return this._buffer.clone().data;\n    });\n  }\n\n}\n\nexports.CMAC = CMAC;","map":{"version":3,"sources":["/Users/aidansalzmann/redacted-mint/node_modules/miscreant/release/mac/cmac.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","block_1","require","xor_1","CMAC","constructor","_cipher","_subkey1","_subkey2","_bufferPos","_finished","_buffer","default","importKey","provider","keyData","cipher","importBlockCipherKey","subkey1","encryptBlock","dbl","subkey2","clone","reset","clear","update","data","left","SIZE","dataPos","dataLength","length","i","finish","subkey","xor"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright (C) 2016-2017 Dmitry Chestnykh, Tony Arcieri\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst block_1 = require(\"../internals/block\");\nconst xor_1 = require(\"../internals/xor\");\n/**\n * The AES-CMAC message authentication code\n */\nclass CMAC {\n    constructor(_cipher, _subkey1, _subkey2) {\n        this._cipher = _cipher;\n        this._subkey1 = _subkey1;\n        this._subkey2 = _subkey2;\n        this._bufferPos = 0;\n        this._finished = false;\n        this._buffer = new block_1.default();\n    }\n    /** Create a new CMAC instance from the given key */\n    static importKey(provider, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cipher = yield provider.importBlockCipherKey(keyData);\n            // Generate subkeys.\n            const subkey1 = new block_1.default();\n            yield cipher.encryptBlock(subkey1);\n            subkey1.dbl();\n            const subkey2 = subkey1.clone();\n            subkey2.dbl();\n            return new CMAC(cipher, subkey1, subkey2);\n        });\n    }\n    reset() {\n        this._buffer.clear();\n        this._bufferPos = 0;\n        this._finished = false;\n        return this;\n    }\n    clear() {\n        this.reset();\n        this._subkey1.clear();\n        this._subkey2.clear();\n    }\n    update(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const left = block_1.default.SIZE - this._bufferPos;\n            let dataPos = 0;\n            let dataLength = data.length;\n            if (dataLength > left) {\n                for (let i = 0; i < left; i++) {\n                    this._buffer.data[this._bufferPos + i] ^= data[i];\n                }\n                dataLength -= left;\n                dataPos += left;\n                yield this._cipher.encryptBlock(this._buffer);\n                this._bufferPos = 0;\n            }\n            // TODO: use AES-CBC with a span of multiple blocks instead of encryptBlock\n            // to encrypt many blocks in a single call to the WebCrypto API\n            while (dataLength > block_1.default.SIZE) {\n                for (let i = 0; i < block_1.default.SIZE; i++) {\n                    this._buffer.data[i] ^= data[dataPos + i];\n                }\n                dataLength -= block_1.default.SIZE;\n                dataPos += block_1.default.SIZE;\n                yield this._cipher.encryptBlock(this._buffer);\n            }\n            for (let i = 0; i < dataLength; i++) {\n                this._buffer.data[this._bufferPos++] ^= data[dataPos + i];\n            }\n            return this;\n        });\n    }\n    finish() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._finished) {\n                // Select which subkey to use.\n                const subkey = (this._bufferPos < block_1.default.SIZE) ? this._subkey2 : this._subkey1;\n                // XOR in the subkey.\n                xor_1.xor(this._buffer.data, subkey.data);\n                // Pad if needed.\n                if (this._bufferPos < block_1.default.SIZE) {\n                    this._buffer.data[this._bufferPos] ^= 0x80;\n                }\n                // Encrypt buffer to get the final digest.\n                yield this._cipher.encryptBlock(this._buffer);\n                // Set finished flag.\n                this._finished = true;\n            }\n            return this._buffer.clone().data;\n        });\n    }\n}\nexports.CMAC = CMAC;\n"]},"metadata":{},"sourceType":"script"}