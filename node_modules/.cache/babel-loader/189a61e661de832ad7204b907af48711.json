{"ast":null,"code":"\"use strict\"; // Copyright (C) 2017 Tony Arcieri\n// MIT License. See LICENSE file for details.\n\nvar _regeneratorRuntime = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar block_1 = require(\"../../internals/block\");\n/**\n * WebCrypto-based implementation of the AES block cipher.\n *\n * This implementation (ab)uses AES-CBC mode to implement AES-ECB. This is\n * likely to be rather slow, as it requires an async call per block, and\n * discards half the buffer.\n *\n * In theory it should be constant time due to the use of WebCrypto (provided\n * the browser's implementation is constant time), but it could probably benefit\n * from some clever optimization work, or improvements to the WebCrypto API.\n *\n * Some WebCrypto implementations (e.g. node-webcrypto-ossl) support ECB mode\n * natively, so we could take advantage of that to potentially encrypt multiple\n * blocks in a single invocation.\n *\n * Key size: 16 or 32 bytes, block size: 16 bytes.\n */\n\n\nvar WebCryptoAes = /*#__PURE__*/function () {\n  function WebCryptoAes(_crypto, _key) {\n    _classCallCheck(this, WebCryptoAes);\n\n    this._crypto = _crypto;\n    this._key = _key; // An initialization vector of all zeros, exposing the raw AES function\n\n    this._iv = new block_1.default();\n    this._emptyPromise = Promise.resolve(this);\n  }\n  /**\n   * Create a new WebCryptoAes instance\n   *\n   * @param {Crypto} crypto - the Web Cryptography provider\n   * @param {Uint8Array} keyData - the AES secret key\n   * @returns {Promise<WebCryptoAes}\n   */\n\n\n  _createClass(WebCryptoAes, [{\n    key: \"clear\",\n    value:\n    /**\n     * Cleans expanded keys from memory, setting them to zeros.\n     */\n    function clear() {\n      // TODO: perhaps we should clear something, but what, and how?\n      return this;\n    }\n    /**\n     * Encrypt a single AES block. While ordinarily this might let us see penguins, we're using it safely\n     *\n     * @param {Block} block - block to be encrypted in-place\n     * @returns {Promise<this>}\n     */\n\n  }, {\n    key: \"encryptBlock\",\n    value: function encryptBlock(block) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var params, ctBlock;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                params = {\n                  name: \"AES-CBC\",\n                  iv: this._iv.data\n                };\n                _context.next = 3;\n                return this._crypto.subtle.encrypt(params, this._key, block.data);\n\n              case 3:\n                ctBlock = _context.sent;\n                // TODO: a more efficient way to do in-place encryption?\n                block.data.set(new Uint8Array(ctBlock, 0, block_1.default.SIZE));\n                return _context.abrupt(\"return\", this._emptyPromise);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }], [{\n    key: \"importKey\",\n    value: function importKey(crypto, keyData) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var key;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(keyData.length !== 16 && keyData.length !== 32)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Miscreant: invalid key length: \".concat(keyData.length, \" (expected 16 or 32 bytes)\"));\n\n              case 2:\n                _context2.next = 4;\n                return crypto.subtle.importKey(\"raw\", keyData, \"AES-CBC\", false, [\"encrypt\"]);\n\n              case 4:\n                key = _context2.sent;\n                return _context2.abrupt(\"return\", new WebCryptoAes(crypto, key));\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }\n  }]);\n\n  return WebCryptoAes;\n}();\n\nexports.default = WebCryptoAes;","map":{"version":3,"sources":["/Users/aidansalzmann/redacted-mint/node_modules/miscreant/release/providers/webcrypto/aes.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","block_1","require","WebCryptoAes","_crypto","_key","_iv","default","_emptyPromise","block","params","name","iv","data","subtle","encrypt","ctBlock","set","Uint8Array","SIZE","crypto","keyData","length","Error","importKey","key"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright (C) 2017 Tony Arcieri\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst block_1 = require(\"../../internals/block\");\n/**\n * WebCrypto-based implementation of the AES block cipher.\n *\n * This implementation (ab)uses AES-CBC mode to implement AES-ECB. This is\n * likely to be rather slow, as it requires an async call per block, and\n * discards half the buffer.\n *\n * In theory it should be constant time due to the use of WebCrypto (provided\n * the browser's implementation is constant time), but it could probably benefit\n * from some clever optimization work, or improvements to the WebCrypto API.\n *\n * Some WebCrypto implementations (e.g. node-webcrypto-ossl) support ECB mode\n * natively, so we could take advantage of that to potentially encrypt multiple\n * blocks in a single invocation.\n *\n * Key size: 16 or 32 bytes, block size: 16 bytes.\n */\nclass WebCryptoAes {\n    constructor(_crypto, _key) {\n        this._crypto = _crypto;\n        this._key = _key;\n        // An initialization vector of all zeros, exposing the raw AES function\n        this._iv = new block_1.default();\n        this._emptyPromise = Promise.resolve(this);\n    }\n    /**\n     * Create a new WebCryptoAes instance\n     *\n     * @param {Crypto} crypto - the Web Cryptography provider\n     * @param {Uint8Array} keyData - the AES secret key\n     * @returns {Promise<WebCryptoAes}\n     */\n    static importKey(crypto, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Only AES-128 and AES-256 supported. AES-192 is not.\n            if (keyData.length !== 16 && keyData.length !== 32) {\n                throw new Error(`Miscreant: invalid key length: ${keyData.length} (expected 16 or 32 bytes)`);\n            }\n            const key = yield crypto.subtle.importKey(\"raw\", keyData, \"AES-CBC\", false, [\"encrypt\"]);\n            return new WebCryptoAes(crypto, key);\n        });\n    }\n    /**\n     * Cleans expanded keys from memory, setting them to zeros.\n     */\n    clear() {\n        // TODO: perhaps we should clear something, but what, and how?\n        return this;\n    }\n    /**\n     * Encrypt a single AES block. While ordinarily this might let us see penguins, we're using it safely\n     *\n     * @param {Block} block - block to be encrypted in-place\n     * @returns {Promise<this>}\n     */\n    encryptBlock(block) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const params = { name: \"AES-CBC\", iv: this._iv.data };\n            const ctBlock = yield this._crypto.subtle.encrypt(params, this._key, block.data);\n            // TODO: a more efficient way to do in-place encryption?\n            block.data.set(new Uint8Array(ctBlock, 0, block_1.default.SIZE));\n            return this._emptyPromise;\n        });\n    }\n}\nexports.default = WebCryptoAes;\n"]},"metadata":{},"sourceType":"script"}