{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016-2017 Dmitry Chestnykh, Tony Arcieri\n// MIT License. See LICENSE file for details.\n\nvar _regeneratorRuntime = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar block_1 = require(\"../internals/block\");\n\nvar xor_1 = require(\"../internals/xor\");\n/**\n * The AES-CMAC message authentication code\n */\n\n\nvar CMAC = /*#__PURE__*/function () {\n  function CMAC(_cipher, _subkey1, _subkey2) {\n    _classCallCheck(this, CMAC);\n\n    this._cipher = _cipher;\n    this._subkey1 = _subkey1;\n    this._subkey2 = _subkey2;\n    this._bufferPos = 0;\n    this._finished = false;\n    this._buffer = new block_1.default();\n  }\n  /** Create a new CMAC instance from the given key */\n\n\n  _createClass(CMAC, [{\n    key: \"reset\",\n    value: function reset() {\n      this._buffer.clear();\n\n      this._bufferPos = 0;\n      this._finished = false;\n      return this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.reset();\n\n      this._subkey1.clear();\n\n      this._subkey2.clear();\n    }\n  }, {\n    key: \"update\",\n    value: function update(data) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var left, dataPos, dataLength, i, _i, _i2;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                left = block_1.default.SIZE - this._bufferPos;\n                dataPos = 0;\n                dataLength = data.length;\n\n                if (!(dataLength > left)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                for (i = 0; i < left; i++) {\n                  this._buffer.data[this._bufferPos + i] ^= data[i];\n                }\n\n                dataLength -= left;\n                dataPos += left;\n                _context.next = 9;\n                return this._cipher.encryptBlock(this._buffer);\n\n              case 9:\n                this._bufferPos = 0;\n\n              case 10:\n                if (!(dataLength > block_1.default.SIZE)) {\n                  _context.next = 18;\n                  break;\n                }\n\n                for (_i = 0; _i < block_1.default.SIZE; _i++) {\n                  this._buffer.data[_i] ^= data[dataPos + _i];\n                }\n\n                dataLength -= block_1.default.SIZE;\n                dataPos += block_1.default.SIZE;\n                _context.next = 16;\n                return this._cipher.encryptBlock(this._buffer);\n\n              case 16:\n                _context.next = 10;\n                break;\n\n              case 18:\n                for (_i2 = 0; _i2 < dataLength; _i2++) {\n                  this._buffer.data[this._bufferPos++] ^= data[dataPos + _i2];\n                }\n\n                return _context.abrupt(\"return\", this);\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var subkey;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this._finished) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                // Select which subkey to use.\n                subkey = this._bufferPos < block_1.default.SIZE ? this._subkey2 : this._subkey1; // XOR in the subkey.\n\n                xor_1.xor(this._buffer.data, subkey.data); // Pad if needed.\n\n                if (this._bufferPos < block_1.default.SIZE) {\n                  this._buffer.data[this._bufferPos] ^= 0x80;\n                } // Encrypt buffer to get the final digest.\n\n\n                _context2.next = 6;\n                return this._cipher.encryptBlock(this._buffer);\n\n              case 6:\n                // Set finished flag.\n                this._finished = true;\n\n              case 7:\n                return _context2.abrupt(\"return\", this._buffer.clone().data);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }], [{\n    key: \"importKey\",\n    value: function importKey(provider, keyData) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var cipher, subkey1, subkey2;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return provider.importBlockCipherKey(keyData);\n\n              case 2:\n                cipher = _context3.sent;\n                // Generate subkeys.\n                subkey1 = new block_1.default();\n                _context3.next = 6;\n                return cipher.encryptBlock(subkey1);\n\n              case 6:\n                subkey1.dbl();\n                subkey2 = subkey1.clone();\n                subkey2.dbl();\n                return _context3.abrupt(\"return\", new CMAC(cipher, subkey1, subkey2));\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n    }\n  }]);\n\n  return CMAC;\n}();\n\nexports.CMAC = CMAC;","map":{"version":3,"sources":["/Users/aidansalzmann/redacted-mint/node_modules/miscreant/release/mac/cmac.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","block_1","require","xor_1","CMAC","_cipher","_subkey1","_subkey2","_bufferPos","_finished","_buffer","default","clear","reset","data","left","SIZE","dataPos","dataLength","length","i","encryptBlock","subkey","xor","clone","provider","keyData","importBlockCipherKey","cipher","subkey1","dbl","subkey2"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright (C) 2016-2017 Dmitry Chestnykh, Tony Arcieri\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst block_1 = require(\"../internals/block\");\nconst xor_1 = require(\"../internals/xor\");\n/**\n * The AES-CMAC message authentication code\n */\nclass CMAC {\n    constructor(_cipher, _subkey1, _subkey2) {\n        this._cipher = _cipher;\n        this._subkey1 = _subkey1;\n        this._subkey2 = _subkey2;\n        this._bufferPos = 0;\n        this._finished = false;\n        this._buffer = new block_1.default();\n    }\n    /** Create a new CMAC instance from the given key */\n    static importKey(provider, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cipher = yield provider.importBlockCipherKey(keyData);\n            // Generate subkeys.\n            const subkey1 = new block_1.default();\n            yield cipher.encryptBlock(subkey1);\n            subkey1.dbl();\n            const subkey2 = subkey1.clone();\n            subkey2.dbl();\n            return new CMAC(cipher, subkey1, subkey2);\n        });\n    }\n    reset() {\n        this._buffer.clear();\n        this._bufferPos = 0;\n        this._finished = false;\n        return this;\n    }\n    clear() {\n        this.reset();\n        this._subkey1.clear();\n        this._subkey2.clear();\n    }\n    update(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const left = block_1.default.SIZE - this._bufferPos;\n            let dataPos = 0;\n            let dataLength = data.length;\n            if (dataLength > left) {\n                for (let i = 0; i < left; i++) {\n                    this._buffer.data[this._bufferPos + i] ^= data[i];\n                }\n                dataLength -= left;\n                dataPos += left;\n                yield this._cipher.encryptBlock(this._buffer);\n                this._bufferPos = 0;\n            }\n            // TODO: use AES-CBC with a span of multiple blocks instead of encryptBlock\n            // to encrypt many blocks in a single call to the WebCrypto API\n            while (dataLength > block_1.default.SIZE) {\n                for (let i = 0; i < block_1.default.SIZE; i++) {\n                    this._buffer.data[i] ^= data[dataPos + i];\n                }\n                dataLength -= block_1.default.SIZE;\n                dataPos += block_1.default.SIZE;\n                yield this._cipher.encryptBlock(this._buffer);\n            }\n            for (let i = 0; i < dataLength; i++) {\n                this._buffer.data[this._bufferPos++] ^= data[dataPos + i];\n            }\n            return this;\n        });\n    }\n    finish() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._finished) {\n                // Select which subkey to use.\n                const subkey = (this._bufferPos < block_1.default.SIZE) ? this._subkey2 : this._subkey1;\n                // XOR in the subkey.\n                xor_1.xor(this._buffer.data, subkey.data);\n                // Pad if needed.\n                if (this._bufferPos < block_1.default.SIZE) {\n                    this._buffer.data[this._bufferPos] ^= 0x80;\n                }\n                // Encrypt buffer to get the final digest.\n                yield this._cipher.encryptBlock(this._buffer);\n                // Set finished flag.\n                this._finished = true;\n            }\n            return this._buffer.clone().data;\n        });\n    }\n}\nexports.CMAC = CMAC;\n"]},"metadata":{},"sourceType":"script"}