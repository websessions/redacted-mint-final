{"ast":null,"code":"\"use strict\";\n/** Type which represents AES blocks */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst constant_time_1 = require(\"./constant-time\");\n\nconst wipe_1 = require(\"./wipe\");\n/** An AES block (128-bits) */\n\n\nclass Block {\n  constructor() {\n    this.data = new Uint8Array(Block.SIZE);\n  }\n  /**\n   * Clear the given array by setting its values to zero.\n   *\n   * WARNING: The fact that it sets bytes to zero can be relied on.\n   *\n   * There is no guarantee that this function makes data disappear from memory,\n   * as runtime implementation can, for example, have copying garbage collector\n   * that will make copies of sensitive data before we wipe it. Or that an\n   * operating system will write our data to swap or sleep image. Another thing\n   * is that an optimizing compiler can remove calls to this function or make it\n   * no-op. There's nothing we can do with it, so we just do our best and hope\n   * that everything will be okay and good will triumph over evil.\n   */\n\n\n  clear() {\n    wipe_1.wipe(this.data);\n  }\n  /**\n   * Make a copy of this block, returning a new block\n   */\n\n\n  clone() {\n    const ret = new Block();\n    ret.copy(this);\n    return ret;\n  }\n  /** Copy the contents of another block into this one */\n\n\n  copy(other) {\n    this.data.set(other.data);\n  }\n  /**\n   * Double a value over GF(2^128):\n   *\n   *     a<<1 if firstbit(a)=0\n   *     (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n   */\n\n\n  dbl() {\n    let carry = 0;\n\n    for (let i = Block.SIZE - 1; i >= 0; i--) {\n      const b = this.data[i] >>> 7 & 0xff;\n      this.data[i] = this.data[i] << 1 | carry;\n      carry = b;\n    }\n\n    this.data[Block.SIZE - 1] ^= constant_time_1.select(carry, Block.R, 0);\n    carry = 0;\n  }\n\n}\n/** Size of a block as used by the AES cipher */\n\n\nBlock.SIZE = 16;\n/** Minimal irreducible polynomial for a 128-bit block size */\n\nBlock.R = 0x87;\nexports.default = Block;","map":{"version":3,"sources":["/Users/aidansalzmann/redacted-mint/node_modules/miscreant/release/internals/block.js"],"names":["Object","defineProperty","exports","value","constant_time_1","require","wipe_1","Block","constructor","data","Uint8Array","SIZE","clear","wipe","clone","ret","copy","other","set","dbl","carry","i","b","select","R","default"],"mappings":"AAAA;AACA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,eAAe,GAAGC,OAAO,CAAC,iBAAD,CAA/B;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;AACA;;;AACA,MAAME,KAAN,CAAY;AACRC,EAAAA,WAAW,GAAG;AACV,SAAKC,IAAL,GAAY,IAAIC,UAAJ,CAAeH,KAAK,CAACI,IAArB,CAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,KAAK,GAAG;AACJN,IAAAA,MAAM,CAACO,IAAP,CAAY,KAAKJ,IAAjB;AACH;AACD;AACJ;AACA;;;AACIK,EAAAA,KAAK,GAAG;AACJ,UAAMC,GAAG,GAAG,IAAIR,KAAJ,EAAZ;AACAQ,IAAAA,GAAG,CAACC,IAAJ,CAAS,IAAT;AACA,WAAOD,GAAP;AACH;AACD;;;AACAC,EAAAA,IAAI,CAACC,KAAD,EAAQ;AACR,SAAKR,IAAL,CAAUS,GAAV,CAAcD,KAAK,CAACR,IAApB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIU,EAAAA,GAAG,GAAG;AACF,QAAIC,KAAK,GAAG,CAAZ;;AACA,SAAK,IAAIC,CAAC,GAAGd,KAAK,CAACI,IAAN,GAAa,CAA1B,EAA6BU,CAAC,IAAI,CAAlC,EAAqCA,CAAC,EAAtC,EAA0C;AACtC,YAAMC,CAAC,GAAI,KAAKb,IAAL,CAAUY,CAAV,MAAiB,CAAlB,GAAuB,IAAjC;AACA,WAAKZ,IAAL,CAAUY,CAAV,IAAgB,KAAKZ,IAAL,CAAUY,CAAV,KAAgB,CAAjB,GAAsBD,KAArC;AACAA,MAAAA,KAAK,GAAGE,CAAR;AACH;;AACD,SAAKb,IAAL,CAAUF,KAAK,CAACI,IAAN,GAAa,CAAvB,KAA6BP,eAAe,CAACmB,MAAhB,CAAuBH,KAAvB,EAA8Bb,KAAK,CAACiB,CAApC,EAAuC,CAAvC,CAA7B;AACAJ,IAAAA,KAAK,GAAG,CAAR;AACH;;AA/CO;AAiDZ;;;AACAb,KAAK,CAACI,IAAN,GAAa,EAAb;AACA;;AACAJ,KAAK,CAACiB,CAAN,GAAU,IAAV;AACAtB,OAAO,CAACuB,OAAR,GAAkBlB,KAAlB","sourcesContent":["\"use strict\";\n/** Type which represents AES blocks */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constant_time_1 = require(\"./constant-time\");\nconst wipe_1 = require(\"./wipe\");\n/** An AES block (128-bits) */\nclass Block {\n    constructor() {\n        this.data = new Uint8Array(Block.SIZE);\n    }\n    /**\n     * Clear the given array by setting its values to zero.\n     *\n     * WARNING: The fact that it sets bytes to zero can be relied on.\n     *\n     * There is no guarantee that this function makes data disappear from memory,\n     * as runtime implementation can, for example, have copying garbage collector\n     * that will make copies of sensitive data before we wipe it. Or that an\n     * operating system will write our data to swap or sleep image. Another thing\n     * is that an optimizing compiler can remove calls to this function or make it\n     * no-op. There's nothing we can do with it, so we just do our best and hope\n     * that everything will be okay and good will triumph over evil.\n     */\n    clear() {\n        wipe_1.wipe(this.data);\n    }\n    /**\n     * Make a copy of this block, returning a new block\n     */\n    clone() {\n        const ret = new Block();\n        ret.copy(this);\n        return ret;\n    }\n    /** Copy the contents of another block into this one */\n    copy(other) {\n        this.data.set(other.data);\n    }\n    /**\n     * Double a value over GF(2^128):\n     *\n     *     a<<1 if firstbit(a)=0\n     *     (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n     */\n    dbl() {\n        let carry = 0;\n        for (let i = Block.SIZE - 1; i >= 0; i--) {\n            const b = (this.data[i] >>> 7) & 0xff;\n            this.data[i] = (this.data[i] << 1) | carry;\n            carry = b;\n        }\n        this.data[Block.SIZE - 1] ^= constant_time_1.select(carry, Block.R, 0);\n        carry = 0;\n    }\n}\n/** Size of a block as used by the AES cipher */\nBlock.SIZE = 16;\n/** Minimal irreducible polynomial for a 128-bit block size */\nBlock.R = 0x87;\nexports.default = Block;\n"]},"metadata":{},"sourceType":"script"}