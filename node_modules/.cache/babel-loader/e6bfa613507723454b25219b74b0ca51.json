{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto_1 = require(\"@iov/crypto\");\n\nconst encoding_1 = require(\"@iov/encoding\");\n\nconst logs_1 = require(\"./logs\");\n\nconst pubkey_1 = require(\"./pubkey\");\n\nconst restclient_1 = require(\"./restclient\");\n\nfunction isSearchByIdQuery(query) {\n  return query.id !== undefined;\n}\n\nfunction isSearchByHeightQuery(query) {\n  return query.height !== undefined;\n}\n\nfunction isSearchBySentFromOrToQuery(query) {\n  return query.sentFromOrTo !== undefined;\n}\n\nfunction isSearchByTagsQuery(query) {\n  return query.tags !== undefined;\n}\n\nclass CosmWasmClient {\n  /**\n   * Creates a new client to interact with a CosmWasm blockchain.\n   *\n   * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n   * for the lifetime of your application. When switching backends, a new instance must be created.\n   *\n   * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n   * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n   */\n  constructor(apiUrl, seed) {\n    let broadcastMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : restclient_1.BroadcastMode.Block;\n    this.codesCache = new Map();\n    this.restClient = new restclient_1.RestClient(apiUrl, broadcastMode, seed);\n  }\n\n  async getChainId() {\n    if (!this.chainId) {\n      const response = await this.restClient.nodeInfo();\n      const chainId = response.node_info.network;\n      if (!chainId) throw new Error(\"Chain ID must not be empty\");\n      this.chainId = chainId;\n    }\n\n    return this.chainId;\n  }\n\n  async getHeight() {\n    if (this.anyValidAddress) {\n      const {\n        height\n      } = await this.restClient.authAccounts(this.anyValidAddress);\n      return parseInt(height, 10);\n    } else {\n      // Note: this gets inefficient when blocks contain a lot of transactions since it\n      // requires downloading and deserializing all transactions in the block.\n      const latest = await this.restClient.blocksLatest();\n      return parseInt(latest.block.header.height, 10);\n    }\n  }\n  /**\n   * Returns a 32 byte upper-case hex transaction hash (typically used as the transaction ID)\n   */\n\n\n  async getIdentifier(tx) {\n    // We consult the REST API because we don't have a local amino encoder\n    const bytes = await this.restClient.encodeTx(tx);\n    const hash = new crypto_1.Sha256(bytes).digest();\n    return encoding_1.Encoding.toHex(hash).toUpperCase();\n  }\n  /**\n   * Returns account number and sequence.\n   *\n   * Throws if the account does not exist on chain.\n   *\n   * @param address returns data for this address. When unset, the client's sender adddress is used.\n   */\n\n\n  async getNonce(address) {\n    const account = await this.getAccount(address);\n\n    if (!account) {\n      throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query nonces.\");\n    }\n\n    return {\n      accountNumber: account.accountNumber,\n      sequence: account.sequence\n    };\n  }\n\n  async getAccount(address) {\n    const account = await this.restClient.authAccounts(address);\n    const value = account.result.value;\n\n    if (value.address === \"\") {\n      return undefined;\n    } else {\n      this.anyValidAddress = value.address;\n      return {\n        address: value.address,\n        balance: value.coins,\n        pubkey: value.public_key ? pubkey_1.decodeBech32Pubkey(value.public_key) : undefined,\n        accountNumber: value.account_number,\n        sequence: value.sequence\n      };\n    }\n  }\n  /**\n   * Gets block header and meta\n   *\n   * @param height The height of the block. If undefined, the latest height is used.\n   */\n\n\n  async getBlock(height) {\n    const response = height !== undefined ? await this.restClient.blocks(height) : await this.restClient.blocksLatest();\n    return {\n      id: response.block_id.hash,\n      header: {\n        version: response.block.header.version,\n        time: response.block.header.time,\n        height: parseInt(response.block.header.height, 10),\n        chainId: response.block.header.chain_id\n      },\n      txs: (response.block.data.txs || []).map(encoded => encoding_1.Encoding.fromBase64(encoded))\n    };\n  }\n\n  async searchTx(query) {\n    let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const minHeight = filter.minHeight || 0;\n    const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n    if (maxHeight < minHeight) return []; // optional optimization\n\n    function withFilters(originalQuery) {\n      return `${originalQuery}&tx.minheight=${minHeight}&tx.maxheight=${maxHeight}`;\n    }\n\n    let txs;\n\n    if (isSearchByIdQuery(query)) {\n      txs = await this.txsQuery(`tx.hash=${query.id}`);\n    } else if (isSearchByHeightQuery(query)) {\n      // optional optimization to avoid network request\n      if (query.height < minHeight || query.height > maxHeight) {\n        txs = [];\n      } else {\n        txs = await this.txsQuery(`tx.height=${query.height}`);\n      }\n    } else if (isSearchBySentFromOrToQuery(query)) {\n      // We cannot get both in one request (see https://github.com/cosmos/gaia/issues/75)\n      const sentQuery = withFilters(`message.module=bank&message.sender=${query.sentFromOrTo}`);\n      const receivedQuery = withFilters(`message.module=bank&transfer.recipient=${query.sentFromOrTo}`);\n      const sent = await this.txsQuery(sentQuery);\n      const received = await this.txsQuery(receivedQuery);\n      const sentHashes = sent.map(t => t.hash);\n      txs = [...sent, ...received.filter(t => !sentHashes.includes(t.hash))];\n    } else if (isSearchByTagsQuery(query)) {\n      const rawQuery = withFilters(query.tags.map(t => `${t.key}=${t.value}`).join(\"&\"));\n      txs = await this.txsQuery(rawQuery);\n    } else {\n      throw new Error(\"Unknown query type\");\n    } // backend sometimes messes up with min/max height filtering\n\n\n    const filtered = txs.filter(tx => tx.height >= minHeight && tx.height <= maxHeight);\n    return filtered;\n  }\n\n  async postTx(tx) {\n    const result = await this.restClient.postTx(tx);\n\n    if (!result.txhash.match(/^([0-9A-F][0-9A-F])+$/)) {\n      throw new Error(\"Received ill-formatted txhash. Must be non-empty upper-case hex\");\n    }\n\n    if (result.code) {\n      throw new Error(`Error when posting tx ${result.txhash}. Code: ${result.code}; Raw log: ${result.raw_log}`);\n    }\n\n    return {\n      logs: result.logs ? logs_1.parseLogs(result.logs) : [],\n      rawLog: result.raw_log || \"\",\n      transactionHash: result.txhash,\n      data: result.data || \"\"\n    };\n  }\n\n  async getCodes() {\n    const result = await this.restClient.listCodeInfo();\n    return result.map(entry => {\n      this.anyValidAddress = entry.creator;\n      return {\n        id: entry.id,\n        creator: entry.creator,\n        checksum: encoding_1.Encoding.toHex(encoding_1.Encoding.fromHex(entry.data_hash)),\n        source: entry.source || undefined,\n        builder: entry.builder || undefined\n      };\n    });\n  }\n\n  async getCodeDetails(codeId) {\n    const cached = this.codesCache.get(codeId);\n    if (cached) return cached;\n    const getCodeResult = await this.restClient.getCode(codeId);\n    const codeDetails = {\n      id: getCodeResult.id,\n      creator: getCodeResult.creator,\n      checksum: encoding_1.Encoding.toHex(encoding_1.Encoding.fromHex(getCodeResult.data_hash)),\n      source: getCodeResult.source || undefined,\n      builder: getCodeResult.builder || undefined,\n      data: encoding_1.Encoding.fromBase64(getCodeResult.data)\n    };\n    this.codesCache.set(codeId, codeDetails);\n    return codeDetails;\n  }\n\n  async getContracts(codeId) {\n    const result = await this.restClient.listContractsByCodeId(codeId);\n    return result.map(entry => ({\n      address: entry.address,\n      codeId: entry.code_id,\n      creator: entry.creator,\n      label: entry.label\n    }));\n  }\n  /**\n   * Throws an error if no contract was found at the address\n   */\n\n\n  async getContract(address) {\n    const result = await this.restClient.getContractInfo(address);\n    if (!result) throw new Error(`No contract found at address \"${address}\"`);\n    return {\n      address: result.address,\n      codeId: result.code_id,\n      creator: result.creator,\n      label: result.label,\n      initMsg: result.init_msg\n    };\n  }\n  /**\n   * Makes a smart query on the contract, returns the parsed JSON document.\n   *\n   * Promise is rejected when contract does not exist.\n   * Promise is rejected for invalid query format.\n   * Promise is rejected for invalid response format.\n   *\n   * Note: addedParams allows for query string additions such as \"&height=1234567\"\n   */\n\n\n  async queryContractSmart(contractAddress, queryMsg, addedParams, contractCodeHash) {\n    try {\n      return await this.restClient.queryContractSmart(contractAddress, queryMsg, addedParams, contractCodeHash);\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.message.startsWith(\"not found: contract\")) {\n          throw new Error(`No contract found at address \"${contractAddress}\"`);\n        } else {\n          throw error;\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async txsQuery(query) {\n    // TODO: we need proper pagination support\n    const limit = 100;\n    const result = await this.restClient.txsQuery(`${query}&limit=${limit}`);\n    const pages = parseInt(result.page_total, 10);\n\n    if (pages > 1) {\n      throw new Error(`Found more results on the backend than we can process currently. Results: ${result.total_count}, supported: ${limit}`);\n    }\n\n    return result.txs.map(restItem => ({\n      height: parseInt(restItem.height, 10),\n      hash: restItem.txhash,\n      code: restItem.code || 0,\n      rawLog: restItem.raw_log,\n      logs: logs_1.parseLogs(restItem.logs || []),\n      tx: restItem.tx,\n      timestamp: restItem.timestamp\n    }));\n  }\n\n  getCodeHashByCodeId(id) {\n    return this.restClient.getCodeHashByCodeId(id);\n  }\n\n  getCodeHashByContractAddr(addr) {\n    return this.restClient.getCodeHashByContractAddr(addr);\n  }\n\n  async getNonceByTxId(txhash) {\n    const txResponse = await this.restClient.txById(txhash, false);\n    const msgs = txResponse.tx.value.msg;\n    const result = [];\n\n    for (const msg of msgs) {\n      let nonce;\n\n      if (msg.type === \"wasm/MsgExecuteContract\") {\n        nonce = encoding_1.Encoding.fromBase64(msg.value.msg).slice(0, 32);\n      } else if (msg.type === \"wasm/MsgInstantiateContract\") {\n        nonce = encoding_1.Encoding.fromBase64(msg.value.init_msg).slice(0, 32);\n      } else {\n        nonce = null;\n      }\n\n      result.push(nonce);\n    }\n\n    return result;\n  }\n\n}\n\nexports.CosmWasmClient = CosmWasmClient;","map":{"version":3,"sources":["../src/cosmwasmclient.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAEA,MAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AA4DA,SAAS,iBAAT,CAA2B,KAA3B,EAA+C;AAC7C,SAAQ,KAAyB,CAAC,EAA1B,KAAiC,SAAzC;AACD;;AAED,SAAS,qBAAT,CAA+B,KAA/B,EAAmD;AACjD,SAAQ,KAA6B,CAAC,MAA9B,KAAyC,SAAjD;AACD;;AAED,SAAS,2BAAT,CAAqC,KAArC,EAAyD;AACvD,SAAQ,KAAmC,CAAC,YAApC,KAAqD,SAA7D;AACD;;AAED,SAAS,mBAAT,CAA6B,KAA7B,EAAiD;AAC/C,SAAQ,KAA2B,CAAC,IAA5B,KAAqC,SAA7C;AACD;;AA6ED,MAAa,cAAb,CAA2B;AAQzB;;;;;;;;AAQG;AACH,EAAA,WAAA,CAAmB,MAAnB,EAAmC,IAAnC,EAAyF;AAAA,QAAnC,aAAmC,uEAAnB,YAAA,CAAA,aAAA,CAAc,KAAK;AAZxE,SAAA,UAAA,GAAa,IAAI,GAAJ,EAAb;AAaf,SAAK,UAAL,GAAkB,IAAI,YAAA,CAAA,UAAJ,CAAe,MAAf,EAAuB,aAAvB,EAAsC,IAAtC,CAAlB;AACD;;AAEsB,QAAV,UAAU,GAAA;AACrB,QAAI,CAAC,KAAK,OAAV,EAAmB;AACjB,YAAM,QAAQ,GAAG,MAAM,KAAK,UAAL,CAAgB,QAAhB,EAAvB;AACA,YAAM,OAAO,GAAG,QAAQ,CAAC,SAAT,CAAmB,OAAnC;AACA,UAAI,CAAC,OAAL,EAAc,MAAM,IAAI,KAAJ,CAAU,4BAAV,CAAN;AACd,WAAK,OAAL,GAAe,OAAf;AACD;;AAED,WAAO,KAAK,OAAZ;AACD;;AAEqB,QAAT,SAAS,GAAA;AACpB,QAAI,KAAK,eAAT,EAA0B;AACxB,YAAM;AAAE,QAAA;AAAF,UAAa,MAAM,KAAK,UAAL,CAAgB,YAAhB,CAA6B,KAAK,eAAlC,CAAzB;AACA,aAAO,QAAQ,CAAC,MAAD,EAAS,EAAT,CAAf;AACD,KAHD,MAGO;AACL;AACA;AACA,YAAM,MAAM,GAAG,MAAM,KAAK,UAAL,CAAgB,YAAhB,EAArB;AACA,aAAO,QAAQ,CAAC,MAAM,CAAC,KAAP,CAAa,MAAb,CAAoB,MAArB,EAA6B,EAA7B,CAAf;AACD;AACF;AAED;;AAEG;;;AACuB,QAAb,aAAa,CAAC,EAAD,EAAgB;AACxC;AACA,UAAM,KAAK,GAAG,MAAM,KAAK,UAAL,CAAgB,QAAhB,CAAyB,EAAzB,CAApB;AACA,UAAM,IAAI,GAAG,IAAI,QAAA,CAAA,MAAJ,CAAW,KAAX,EAAkB,MAAlB,EAAb;AACA,WAAO,UAAA,CAAA,QAAA,CAAS,KAAT,CAAe,IAAf,EAAqB,WAArB,EAAP;AACD;AAED;;;;;;AAMG;;;AACkB,QAAR,QAAQ,CAAC,OAAD,EAAgB;AACnC,UAAM,OAAO,GAAG,MAAM,KAAK,UAAL,CAAgB,OAAhB,CAAtB;;AACA,QAAI,CAAC,OAAL,EAAc;AACZ,YAAM,IAAI,KAAJ,CACJ,wFADI,CAAN;AAGD;;AACD,WAAO;AACL,MAAA,aAAa,EAAE,OAAO,CAAC,aADlB;AAEL,MAAA,QAAQ,EAAE,OAAO,CAAC;AAFb,KAAP;AAID;;AAEsB,QAAV,UAAU,CAAC,OAAD,EAAgB;AACrC,UAAM,OAAO,GAAG,MAAM,KAAK,UAAL,CAAgB,YAAhB,CAA6B,OAA7B,CAAtB;AACA,UAAM,KAAK,GAAG,OAAO,CAAC,MAAR,CAAe,KAA7B;;AACA,QAAI,KAAK,CAAC,OAAN,KAAkB,EAAtB,EAA0B;AACxB,aAAO,SAAP;AACD,KAFD,MAEO;AACL,WAAK,eAAL,GAAuB,KAAK,CAAC,OAA7B;AACA,aAAO;AACL,QAAA,OAAO,EAAE,KAAK,CAAC,OADV;AAEL,QAAA,OAAO,EAAE,KAAK,CAAC,KAFV;AAGL,QAAA,MAAM,EAAE,KAAK,CAAC,UAAN,GAAmB,QAAA,CAAA,kBAAA,CAAmB,KAAK,CAAC,UAAzB,CAAnB,GAA0D,SAH7D;AAIL,QAAA,aAAa,EAAE,KAAK,CAAC,cAJhB;AAKL,QAAA,QAAQ,EAAE,KAAK,CAAC;AALX,OAAP;AAOD;AACF;AAED;;;;AAIG;;;AACkB,QAAR,QAAQ,CAAC,MAAD,EAAgB;AACnC,UAAM,QAAQ,GACZ,MAAM,KAAK,SAAX,GAAuB,MAAM,KAAK,UAAL,CAAgB,MAAhB,CAAuB,MAAvB,CAA7B,GAA8D,MAAM,KAAK,UAAL,CAAgB,YAAhB,EADtE;AAGA,WAAO;AACL,MAAA,EAAE,EAAE,QAAQ,CAAC,QAAT,CAAkB,IADjB;AAEL,MAAA,MAAM,EAAE;AACN,QAAA,OAAO,EAAE,QAAQ,CAAC,KAAT,CAAe,MAAf,CAAsB,OADzB;AAEN,QAAA,IAAI,EAAE,QAAQ,CAAC,KAAT,CAAe,MAAf,CAAsB,IAFtB;AAGN,QAAA,MAAM,EAAE,QAAQ,CAAC,QAAQ,CAAC,KAAT,CAAe,MAAf,CAAsB,MAAvB,EAA+B,EAA/B,CAHV;AAIN,QAAA,OAAO,EAAE,QAAQ,CAAC,KAAT,CAAe,MAAf,CAAsB;AAJzB,OAFH;AAQL,MAAA,GAAG,EAAE,CAAC,QAAQ,CAAC,KAAT,CAAe,IAAf,CAAoB,GAApB,IAA2B,EAA5B,EAAgC,GAAhC,CAAqC,OAAD,IAAa,UAAA,CAAA,QAAA,CAAS,UAAT,CAAoB,OAApB,CAAjD;AARA,KAAP;AAUD;;AAEoB,QAAR,QAAQ,CAAC,KAAD,EAAkD;AAAA,QAA3B,MAA2B,uEAAF,EAAE;AACrE,UAAM,SAAS,GAAG,MAAM,CAAC,SAAP,IAAoB,CAAtC;AACA,UAAM,SAAS,GAAG,MAAM,CAAC,SAAP,IAAoB,MAAM,CAAC,gBAA7C;AAEA,QAAI,SAAS,GAAG,SAAhB,EAA2B,OAAO,EAAP,CAJ0C,CAI/B;;AAEtC,aAAS,WAAT,CAAqB,aAArB,EAA0C;AACxC,aAAO,GAAG,aAAa,iBAAiB,SAAS,iBAAiB,SAAS,EAA3E;AACD;;AAED,QAAI,GAAJ;;AACA,QAAI,iBAAiB,CAAC,KAAD,CAArB,EAA8B;AAC5B,MAAA,GAAG,GAAG,MAAM,KAAK,QAAL,CAAc,WAAW,KAAK,CAAC,EAAE,EAAjC,CAAZ;AACD,KAFD,MAEO,IAAI,qBAAqB,CAAC,KAAD,CAAzB,EAAkC;AACvC;AACA,UAAI,KAAK,CAAC,MAAN,GAAe,SAAf,IAA4B,KAAK,CAAC,MAAN,GAAe,SAA/C,EAA0D;AACxD,QAAA,GAAG,GAAG,EAAN;AACD,OAFD,MAEO;AACL,QAAA,GAAG,GAAG,MAAM,KAAK,QAAL,CAAc,aAAa,KAAK,CAAC,MAAM,EAAvC,CAAZ;AACD;AACF,KAPM,MAOA,IAAI,2BAA2B,CAAC,KAAD,CAA/B,EAAwC;AAC7C;AACA,YAAM,SAAS,GAAG,WAAW,CAAC,sCAAsC,KAAK,CAAC,YAAY,EAAzD,CAA7B;AACA,YAAM,aAAa,GAAG,WAAW,CAAC,0CAA0C,KAAK,CAAC,YAAY,EAA7D,CAAjC;AACA,YAAM,IAAI,GAAG,MAAM,KAAK,QAAL,CAAc,SAAd,CAAnB;AACA,YAAM,QAAQ,GAAG,MAAM,KAAK,QAAL,CAAc,aAAd,CAAvB;AAEA,YAAM,UAAU,GAAG,IAAI,CAAC,GAAL,CAAU,CAAD,IAAO,CAAC,CAAC,IAAlB,CAAnB;AACA,MAAA,GAAG,GAAG,CAAC,GAAG,IAAJ,EAAU,GAAG,QAAQ,CAAC,MAAT,CAAiB,CAAD,IAAO,CAAC,UAAU,CAAC,QAAX,CAAoB,CAAC,CAAC,IAAtB,CAAxB,CAAb,CAAN;AACD,KATM,MASA,IAAI,mBAAmB,CAAC,KAAD,CAAvB,EAAgC;AACrC,YAAM,QAAQ,GAAG,WAAW,CAAC,KAAK,CAAC,IAAN,CAAW,GAAX,CAAgB,CAAD,IAAO,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,KAAK,EAAzC,EAA6C,IAA7C,CAAkD,GAAlD,CAAD,CAA5B;AACA,MAAA,GAAG,GAAG,MAAM,KAAK,QAAL,CAAc,QAAd,CAAZ;AACD,KAHM,MAGA;AACL,YAAM,IAAI,KAAJ,CAAU,oBAAV,CAAN;AACD,KAlCoE,CAoCrE;;;AACA,UAAM,QAAQ,GAAG,GAAG,CAAC,MAAJ,CAAY,EAAD,IAAQ,EAAE,CAAC,MAAH,IAAa,SAAb,IAA0B,EAAE,CAAC,MAAH,IAAa,SAA1D,CAAjB;AAEA,WAAO,QAAP;AACD;;AAEkB,QAAN,MAAM,CAAC,EAAD,EAAU;AAC3B,UAAM,MAAM,GAAG,MAAM,KAAK,UAAL,CAAgB,MAAhB,CAAuB,EAAvB,CAArB;;AACA,QAAI,CAAC,MAAM,CAAC,MAAP,CAAc,KAAd,CAAoB,uBAApB,CAAL,EAAmD;AACjD,YAAM,IAAI,KAAJ,CAAU,iEAAV,CAAN;AACD;;AAED,QAAI,MAAM,CAAC,IAAX,EAAiB;AACf,YAAM,IAAI,KAAJ,CACJ,yBAAyB,MAAM,CAAC,MAAM,WAAW,MAAM,CAAC,IAAI,cAAc,MAAM,CAAC,OAAO,EADpF,CAAN;AAGD;;AAED,WAAO;AACL,MAAA,IAAI,EAAE,MAAM,CAAC,IAAP,GAAc,MAAA,CAAA,SAAA,CAAU,MAAM,CAAC,IAAjB,CAAd,GAAuC,EADxC;AAEL,MAAA,MAAM,EAAE,MAAM,CAAC,OAAP,IAAkB,EAFrB;AAGL,MAAA,eAAe,EAAE,MAAM,CAAC,MAHnB;AAIL,MAAA,IAAI,EAAE,MAAM,CAAC,IAAP,IAAe;AAJhB,KAAP;AAMD;;AAEoB,QAAR,QAAQ,GAAA;AACnB,UAAM,MAAM,GAAG,MAAM,KAAK,UAAL,CAAgB,YAAhB,EAArB;AACA,WAAO,MAAM,CAAC,GAAP,CACJ,KAAD,IAAgB;AACd,WAAK,eAAL,GAAuB,KAAK,CAAC,OAA7B;AACA,aAAO;AACL,QAAA,EAAE,EAAE,KAAK,CAAC,EADL;AAEL,QAAA,OAAO,EAAE,KAAK,CAAC,OAFV;AAGL,QAAA,QAAQ,EAAE,UAAA,CAAA,QAAA,CAAS,KAAT,CAAe,UAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,KAAK,CAAC,SAAvB,CAAf,CAHL;AAIL,QAAA,MAAM,EAAE,KAAK,CAAC,MAAN,IAAgB,SAJnB;AAKL,QAAA,OAAO,EAAE,KAAK,CAAC,OAAN,IAAiB;AALrB,OAAP;AAOD,KAVI,CAAP;AAYD;;AAE0B,QAAd,cAAc,CAAC,MAAD,EAAe;AACxC,UAAM,MAAM,GAAG,KAAK,UAAL,CAAgB,GAAhB,CAAoB,MAApB,CAAf;AACA,QAAI,MAAJ,EAAY,OAAO,MAAP;AAEZ,UAAM,aAAa,GAAG,MAAM,KAAK,UAAL,CAAgB,OAAhB,CAAwB,MAAxB,CAA5B;AACA,UAAM,WAAW,GAAgB;AAC/B,MAAA,EAAE,EAAE,aAAa,CAAC,EADa;AAE/B,MAAA,OAAO,EAAE,aAAa,CAAC,OAFQ;AAG/B,MAAA,QAAQ,EAAE,UAAA,CAAA,QAAA,CAAS,KAAT,CAAe,UAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,aAAa,CAAC,SAA/B,CAAf,CAHqB;AAI/B,MAAA,MAAM,EAAE,aAAa,CAAC,MAAd,IAAwB,SAJD;AAK/B,MAAA,OAAO,EAAE,aAAa,CAAC,OAAd,IAAyB,SALH;AAM/B,MAAA,IAAI,EAAE,UAAA,CAAA,QAAA,CAAS,UAAT,CAAoB,aAAa,CAAC,IAAlC;AANyB,KAAjC;AAQA,SAAK,UAAL,CAAgB,GAAhB,CAAoB,MAApB,EAA4B,WAA5B;AACA,WAAO,WAAP;AACD;;AAEwB,QAAZ,YAAY,CAAC,MAAD,EAAe;AACtC,UAAM,MAAM,GAAG,MAAM,KAAK,UAAL,CAAgB,qBAAhB,CAAsC,MAAtC,CAArB;AACA,WAAO,MAAM,CAAC,GAAP,CACJ,KAAD,KAAsB;AACpB,MAAA,OAAO,EAAE,KAAK,CAAC,OADK;AAEpB,MAAA,MAAM,EAAE,KAAK,CAAC,OAFM;AAGpB,MAAA,OAAO,EAAE,KAAK,CAAC,OAHK;AAIpB,MAAA,KAAK,EAAE,KAAK,CAAC;AAJO,KAAtB,CADK,CAAP;AAQD;AAED;;AAEG;;;AACqB,QAAX,WAAW,CAAC,OAAD,EAAgB;AACtC,UAAM,MAAM,GAAG,MAAM,KAAK,UAAL,CAAgB,eAAhB,CAAgC,OAAhC,CAArB;AACA,QAAI,CAAC,MAAL,EAAa,MAAM,IAAI,KAAJ,CAAU,iCAAiC,OAAO,GAAlD,CAAN;AACb,WAAO;AACL,MAAA,OAAO,EAAE,MAAM,CAAC,OADX;AAEL,MAAA,MAAM,EAAE,MAAM,CAAC,OAFV;AAGL,MAAA,OAAO,EAAE,MAAM,CAAC,OAHX;AAIL,MAAA,KAAK,EAAE,MAAM,CAAC,KAJT;AAKL,MAAA,OAAO,EAAE,MAAM,CAAC;AALX,KAAP;AAOD;AAED;;;;;;;;AAQG;;;AAC4B,QAAlB,kBAAkB,CAC7B,eAD6B,EAE7B,QAF6B,EAG7B,WAH6B,EAI7B,gBAJ6B,EAIJ;AAEzB,QAAI;AACF,aAAO,MAAM,KAAK,UAAL,CAAgB,kBAAhB,CAAmC,eAAnC,EAAoD,QAApD,EAA8D,WAA9D,EAA0E,gBAA1E,CAAb;AACD,KAFD,CAEE,OAAO,KAAP,EAAc;AACd,UAAI,KAAK,YAAY,KAArB,EAA4B;AAC1B,YAAI,KAAK,CAAC,OAAN,CAAc,UAAd,CAAyB,qBAAzB,CAAJ,EAAqD;AACnD,gBAAM,IAAI,KAAJ,CAAU,iCAAiC,eAAe,GAA1D,CAAN;AACD,SAFD,MAEO;AACL,gBAAM,KAAN;AACD;AACF,OAND,MAMO;AACL,cAAM,KAAN;AACD;AACF;AACF;;AAEqB,QAAR,QAAQ,CAAC,KAAD,EAAc;AAClC;AACA,UAAM,KAAK,GAAG,GAAd;AACA,UAAM,MAAM,GAAG,MAAM,KAAK,UAAL,CAAgB,QAAhB,CAAyB,GAAG,KAAK,UAAU,KAAK,EAAhD,CAArB;AACA,UAAM,KAAK,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAR,EAAoB,EAApB,CAAtB;;AACA,QAAI,KAAK,GAAG,CAAZ,EAAe;AACb,YAAM,IAAI,KAAJ,CACJ,6EAA6E,MAAM,CAAC,WAAW,gBAAgB,KAAK,EADhH,CAAN;AAGD;;AACD,WAAO,MAAM,CAAC,GAAP,CAAW,GAAX,CACJ,QAAD,KAA0B;AACxB,MAAA,MAAM,EAAE,QAAQ,CAAC,QAAQ,CAAC,MAAV,EAAkB,EAAlB,CADQ;AAExB,MAAA,IAAI,EAAE,QAAQ,CAAC,MAFS;AAGxB,MAAA,IAAI,EAAE,QAAQ,CAAC,IAAT,IAAiB,CAHC;AAIxB,MAAA,MAAM,EAAE,QAAQ,CAAC,OAJO;AAKxB,MAAA,IAAI,EAAE,MAAA,CAAA,SAAA,CAAU,QAAQ,CAAC,IAAT,IAAiB,EAA3B,CALkB;AAMxB,MAAA,EAAE,EAAE,QAAQ,CAAC,EANW;AAOxB,MAAA,SAAS,EAAE,QAAQ,CAAC;AAPI,KAA1B,CADK,CAAP;AAWD;;AAEM,EAAA,mBAAmB,CAAC,EAAD,EAAW;AACnC,WAAO,KAAK,UAAL,CAAgB,mBAAhB,CAAoC,EAApC,CAAP;AACD;;AAEM,EAAA,yBAAyB,CAAC,IAAD,EAAa;AAC3C,WAAO,KAAK,UAAL,CAAgB,yBAAhB,CAA0C,IAA1C,CAAP;AACD;;AAE0B,QAAd,cAAc,CAAC,MAAD,EAAe;AACxC,UAAM,UAAU,GAAG,MAAM,KAAK,UAAL,CAAgB,MAAhB,CAAuB,MAAvB,EAA+B,KAA/B,CAAzB;AAEA,UAAM,IAAI,GAAU,UAAU,CAAC,EAAX,CAAc,KAAd,CAAoB,GAAxC;AACA,UAAM,MAAM,GAA6B,EAAzC;;AAEA,SAAK,MAAM,GAAX,IAAkB,IAAlB,EAAwB;AACtB,UAAI,KAAJ;;AACA,UAAI,GAAG,CAAC,IAAJ,KAAa,yBAAjB,EAA4C;AAC1C,QAAA,KAAK,GAAG,UAAA,CAAA,QAAA,CAAS,UAAT,CAAqB,GAA0B,CAAC,KAA3B,CAAiC,GAAtD,EAA2D,KAA3D,CAAiE,CAAjE,EAAoE,EAApE,CAAR;AACD,OAFD,MAEO,IAAI,GAAG,CAAC,IAAJ,KAAa,6BAAjB,EAAgD;AACrD,QAAA,KAAK,GAAG,UAAA,CAAA,QAAA,CAAS,UAAT,CAAqB,GAA8B,CAAC,KAA/B,CAAqC,QAA1D,EAAoE,KAApE,CAA0E,CAA1E,EAA6E,EAA7E,CAAR;AACD,OAFM,MAEA;AACL,QAAA,KAAK,GAAG,IAAR;AACD;;AAED,MAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;AACD;;AAED,WAAO,MAAP;AACD;;AA3TwB;;AAA3B,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"@iov/crypto\");\nconst encoding_1 = require(\"@iov/encoding\");\nconst logs_1 = require(\"./logs\");\nconst pubkey_1 = require(\"./pubkey\");\nconst restclient_1 = require(\"./restclient\");\nfunction isSearchByIdQuery(query) {\n    return query.id !== undefined;\n}\nfunction isSearchByHeightQuery(query) {\n    return query.height !== undefined;\n}\nfunction isSearchBySentFromOrToQuery(query) {\n    return query.sentFromOrTo !== undefined;\n}\nfunction isSearchByTagsQuery(query) {\n    return query.tags !== undefined;\n}\nclass CosmWasmClient {\n    /**\n     * Creates a new client to interact with a CosmWasm blockchain.\n     *\n     * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n     * for the lifetime of your application. When switching backends, a new instance must be created.\n     *\n     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n     * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n     */\n    constructor(apiUrl, seed, broadcastMode = restclient_1.BroadcastMode.Block) {\n        this.codesCache = new Map();\n        this.restClient = new restclient_1.RestClient(apiUrl, broadcastMode, seed);\n    }\n    async getChainId() {\n        if (!this.chainId) {\n            const response = await this.restClient.nodeInfo();\n            const chainId = response.node_info.network;\n            if (!chainId)\n                throw new Error(\"Chain ID must not be empty\");\n            this.chainId = chainId;\n        }\n        return this.chainId;\n    }\n    async getHeight() {\n        if (this.anyValidAddress) {\n            const { height } = await this.restClient.authAccounts(this.anyValidAddress);\n            return parseInt(height, 10);\n        }\n        else {\n            // Note: this gets inefficient when blocks contain a lot of transactions since it\n            // requires downloading and deserializing all transactions in the block.\n            const latest = await this.restClient.blocksLatest();\n            return parseInt(latest.block.header.height, 10);\n        }\n    }\n    /**\n     * Returns a 32 byte upper-case hex transaction hash (typically used as the transaction ID)\n     */\n    async getIdentifier(tx) {\n        // We consult the REST API because we don't have a local amino encoder\n        const bytes = await this.restClient.encodeTx(tx);\n        const hash = new crypto_1.Sha256(bytes).digest();\n        return encoding_1.Encoding.toHex(hash).toUpperCase();\n    }\n    /**\n     * Returns account number and sequence.\n     *\n     * Throws if the account does not exist on chain.\n     *\n     * @param address returns data for this address. When unset, the client's sender adddress is used.\n     */\n    async getNonce(address) {\n        const account = await this.getAccount(address);\n        if (!account) {\n            throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query nonces.\");\n        }\n        return {\n            accountNumber: account.accountNumber,\n            sequence: account.sequence,\n        };\n    }\n    async getAccount(address) {\n        const account = await this.restClient.authAccounts(address);\n        const value = account.result.value;\n        if (value.address === \"\") {\n            return undefined;\n        }\n        else {\n            this.anyValidAddress = value.address;\n            return {\n                address: value.address,\n                balance: value.coins,\n                pubkey: value.public_key ? pubkey_1.decodeBech32Pubkey(value.public_key) : undefined,\n                accountNumber: value.account_number,\n                sequence: value.sequence,\n            };\n        }\n    }\n    /**\n     * Gets block header and meta\n     *\n     * @param height The height of the block. If undefined, the latest height is used.\n     */\n    async getBlock(height) {\n        const response = height !== undefined ? await this.restClient.blocks(height) : await this.restClient.blocksLatest();\n        return {\n            id: response.block_id.hash,\n            header: {\n                version: response.block.header.version,\n                time: response.block.header.time,\n                height: parseInt(response.block.header.height, 10),\n                chainId: response.block.header.chain_id,\n            },\n            txs: (response.block.data.txs || []).map((encoded) => encoding_1.Encoding.fromBase64(encoded)),\n        };\n    }\n    async searchTx(query, filter = {}) {\n        const minHeight = filter.minHeight || 0;\n        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n        if (maxHeight < minHeight)\n            return []; // optional optimization\n        function withFilters(originalQuery) {\n            return `${originalQuery}&tx.minheight=${minHeight}&tx.maxheight=${maxHeight}`;\n        }\n        let txs;\n        if (isSearchByIdQuery(query)) {\n            txs = await this.txsQuery(`tx.hash=${query.id}`);\n        }\n        else if (isSearchByHeightQuery(query)) {\n            // optional optimization to avoid network request\n            if (query.height < minHeight || query.height > maxHeight) {\n                txs = [];\n            }\n            else {\n                txs = await this.txsQuery(`tx.height=${query.height}`);\n            }\n        }\n        else if (isSearchBySentFromOrToQuery(query)) {\n            // We cannot get both in one request (see https://github.com/cosmos/gaia/issues/75)\n            const sentQuery = withFilters(`message.module=bank&message.sender=${query.sentFromOrTo}`);\n            const receivedQuery = withFilters(`message.module=bank&transfer.recipient=${query.sentFromOrTo}`);\n            const sent = await this.txsQuery(sentQuery);\n            const received = await this.txsQuery(receivedQuery);\n            const sentHashes = sent.map((t) => t.hash);\n            txs = [...sent, ...received.filter((t) => !sentHashes.includes(t.hash))];\n        }\n        else if (isSearchByTagsQuery(query)) {\n            const rawQuery = withFilters(query.tags.map((t) => `${t.key}=${t.value}`).join(\"&\"));\n            txs = await this.txsQuery(rawQuery);\n        }\n        else {\n            throw new Error(\"Unknown query type\");\n        }\n        // backend sometimes messes up with min/max height filtering\n        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);\n        return filtered;\n    }\n    async postTx(tx) {\n        const result = await this.restClient.postTx(tx);\n        if (!result.txhash.match(/^([0-9A-F][0-9A-F])+$/)) {\n            throw new Error(\"Received ill-formatted txhash. Must be non-empty upper-case hex\");\n        }\n        if (result.code) {\n            throw new Error(`Error when posting tx ${result.txhash}. Code: ${result.code}; Raw log: ${result.raw_log}`);\n        }\n        return {\n            logs: result.logs ? logs_1.parseLogs(result.logs) : [],\n            rawLog: result.raw_log || \"\",\n            transactionHash: result.txhash,\n            data: result.data || \"\",\n        };\n    }\n    async getCodes() {\n        const result = await this.restClient.listCodeInfo();\n        return result.map((entry) => {\n            this.anyValidAddress = entry.creator;\n            return {\n                id: entry.id,\n                creator: entry.creator,\n                checksum: encoding_1.Encoding.toHex(encoding_1.Encoding.fromHex(entry.data_hash)),\n                source: entry.source || undefined,\n                builder: entry.builder || undefined,\n            };\n        });\n    }\n    async getCodeDetails(codeId) {\n        const cached = this.codesCache.get(codeId);\n        if (cached)\n            return cached;\n        const getCodeResult = await this.restClient.getCode(codeId);\n        const codeDetails = {\n            id: getCodeResult.id,\n            creator: getCodeResult.creator,\n            checksum: encoding_1.Encoding.toHex(encoding_1.Encoding.fromHex(getCodeResult.data_hash)),\n            source: getCodeResult.source || undefined,\n            builder: getCodeResult.builder || undefined,\n            data: encoding_1.Encoding.fromBase64(getCodeResult.data),\n        };\n        this.codesCache.set(codeId, codeDetails);\n        return codeDetails;\n    }\n    async getContracts(codeId) {\n        const result = await this.restClient.listContractsByCodeId(codeId);\n        return result.map((entry) => ({\n            address: entry.address,\n            codeId: entry.code_id,\n            creator: entry.creator,\n            label: entry.label,\n        }));\n    }\n    /**\n     * Throws an error if no contract was found at the address\n     */\n    async getContract(address) {\n        const result = await this.restClient.getContractInfo(address);\n        if (!result)\n            throw new Error(`No contract found at address \"${address}\"`);\n        return {\n            address: result.address,\n            codeId: result.code_id,\n            creator: result.creator,\n            label: result.label,\n            initMsg: result.init_msg,\n        };\n    }\n    /**\n     * Makes a smart query on the contract, returns the parsed JSON document.\n     *\n     * Promise is rejected when contract does not exist.\n     * Promise is rejected for invalid query format.\n     * Promise is rejected for invalid response format.\n     *\n     * Note: addedParams allows for query string additions such as \"&height=1234567\"\n     */\n    async queryContractSmart(contractAddress, queryMsg, addedParams, contractCodeHash) {\n        try {\n            return await this.restClient.queryContractSmart(contractAddress, queryMsg, addedParams, contractCodeHash);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                if (error.message.startsWith(\"not found: contract\")) {\n                    throw new Error(`No contract found at address \"${contractAddress}\"`);\n                }\n                else {\n                    throw error;\n                }\n            }\n            else {\n                throw error;\n            }\n        }\n    }\n    async txsQuery(query) {\n        // TODO: we need proper pagination support\n        const limit = 100;\n        const result = await this.restClient.txsQuery(`${query}&limit=${limit}`);\n        const pages = parseInt(result.page_total, 10);\n        if (pages > 1) {\n            throw new Error(`Found more results on the backend than we can process currently. Results: ${result.total_count}, supported: ${limit}`);\n        }\n        return result.txs.map((restItem) => ({\n            height: parseInt(restItem.height, 10),\n            hash: restItem.txhash,\n            code: restItem.code || 0,\n            rawLog: restItem.raw_log,\n            logs: logs_1.parseLogs(restItem.logs || []),\n            tx: restItem.tx,\n            timestamp: restItem.timestamp,\n        }));\n    }\n    getCodeHashByCodeId(id) {\n        return this.restClient.getCodeHashByCodeId(id);\n    }\n    getCodeHashByContractAddr(addr) {\n        return this.restClient.getCodeHashByContractAddr(addr);\n    }\n    async getNonceByTxId(txhash) {\n        const txResponse = await this.restClient.txById(txhash, false);\n        const msgs = txResponse.tx.value.msg;\n        const result = [];\n        for (const msg of msgs) {\n            let nonce;\n            if (msg.type === \"wasm/MsgExecuteContract\") {\n                nonce = encoding_1.Encoding.fromBase64(msg.value.msg).slice(0, 32);\n            }\n            else if (msg.type === \"wasm/MsgInstantiateContract\") {\n                nonce = encoding_1.Encoding.fromBase64(msg.value.init_msg).slice(0, 32);\n            }\n            else {\n                nonce = null;\n            }\n            result.push(nonce);\n        }\n        return result;\n    }\n}\nexports.CosmWasmClient = CosmWasmClient;\n//# sourceMappingURL=cosmwasmclient.js.map"]},"metadata":{},"sourceType":"script"}