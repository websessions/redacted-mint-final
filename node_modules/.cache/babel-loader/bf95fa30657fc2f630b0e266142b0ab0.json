{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nvar _regeneratorRuntime = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar block_1 = require(\"../../internals/block\");\n/**\n * Polyfill for the AES-CTR (counter) mode of operation.\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n *\n * Note that CTR mode is malleable and generally should not be used without\n * authentication. Instead, use an authenticated encryption mode, like AES-SIV!\n */\n\n\nvar PolyfillAesCtr = /*#__PURE__*/function () {\n  function PolyfillAesCtr(cipher) {\n    _classCallCheck(this, PolyfillAesCtr);\n\n    // Set cipher.\n    this._cipher = cipher; // Allocate space for counter.\n\n    this._counter = new block_1.default(); // Allocate buffer for encrypted block.\n\n    this._buffer = new block_1.default();\n  }\n\n  _createClass(PolyfillAesCtr, [{\n    key: \"clear\",\n    value: function clear() {\n      this._buffer.clear();\n\n      this._counter.clear();\n\n      this._cipher.clear();\n\n      return this;\n    }\n  }, {\n    key: \"encryptCtr\",\n    value: function encryptCtr(iv, plaintext) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var bufferPos, result, i;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(iv.length !== block_1.default.SIZE)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(\"CTR: iv length must be equal to cipher block size\");\n\n              case 2:\n                // Copy IV to counter, overwriting it.\n                this._counter.data.set(iv); // Set buffer position to length of buffer\n                // so that the first cipher block is generated.\n\n\n                bufferPos = block_1.default.SIZE;\n                result = new Uint8Array(plaintext.length);\n\n                for (i = 0; i < plaintext.length; i++) {\n                  if (bufferPos === block_1.default.SIZE) {\n                    this._buffer.copy(this._counter);\n\n                    this._cipher.encryptBlock(this._buffer);\n\n                    bufferPos = 0;\n                    incrementCounter(this._counter);\n                  }\n\n                  result[i] = plaintext[i] ^ this._buffer.data[bufferPos++];\n                }\n\n                return _context.abrupt(\"return\", result);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }]);\n\n  return PolyfillAesCtr;\n}();\n\nexports.default = PolyfillAesCtr; // Increment an AES-CTR mode counter, intentionally wrapping/overflowing\n\nfunction incrementCounter(counter) {\n  var carry = 1;\n\n  for (var i = block_1.default.SIZE - 1; i >= 0; i--) {\n    carry += counter.data[i] & 0xff | 0;\n    counter.data[i] = carry & 0xff;\n    carry >>>= 8;\n  }\n}","map":{"version":3,"sources":["/Users/aidansalzmann/redacted-mint/node_modules/miscreant/release/providers/polyfill/aes_ctr.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","block_1","require","PolyfillAesCtr","cipher","_cipher","_counter","default","_buffer","clear","iv","plaintext","length","SIZE","Error","data","set","bufferPos","Uint8Array","i","copy","encryptBlock","incrementCounter","counter","carry"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst block_1 = require(\"../../internals/block\");\n/**\n * Polyfill for the AES-CTR (counter) mode of operation.\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n *\n * Note that CTR mode is malleable and generally should not be used without\n * authentication. Instead, use an authenticated encryption mode, like AES-SIV!\n */\nclass PolyfillAesCtr {\n    constructor(cipher) {\n        // Set cipher.\n        this._cipher = cipher;\n        // Allocate space for counter.\n        this._counter = new block_1.default();\n        // Allocate buffer for encrypted block.\n        this._buffer = new block_1.default();\n    }\n    clear() {\n        this._buffer.clear();\n        this._counter.clear();\n        this._cipher.clear();\n        return this;\n    }\n    encryptCtr(iv, plaintext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (iv.length !== block_1.default.SIZE) {\n                throw new Error(\"CTR: iv length must be equal to cipher block size\");\n            }\n            // Copy IV to counter, overwriting it.\n            this._counter.data.set(iv);\n            // Set buffer position to length of buffer\n            // so that the first cipher block is generated.\n            let bufferPos = block_1.default.SIZE;\n            const result = new Uint8Array(plaintext.length);\n            for (let i = 0; i < plaintext.length; i++) {\n                if (bufferPos === block_1.default.SIZE) {\n                    this._buffer.copy(this._counter);\n                    this._cipher.encryptBlock(this._buffer);\n                    bufferPos = 0;\n                    incrementCounter(this._counter);\n                }\n                result[i] = plaintext[i] ^ this._buffer.data[bufferPos++];\n            }\n            return result;\n        });\n    }\n}\nexports.default = PolyfillAesCtr;\n// Increment an AES-CTR mode counter, intentionally wrapping/overflowing\nfunction incrementCounter(counter) {\n    let carry = 1;\n    for (let i = block_1.default.SIZE - 1; i >= 0; i--) {\n        carry += (counter.data[i] & 0xff) | 0;\n        counter.data[i] = carry & 0xff;\n        carry >>>= 8;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}