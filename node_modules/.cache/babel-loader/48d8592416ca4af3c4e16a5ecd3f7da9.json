{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst encoding_1 = require(\"@iov/encoding\");\n\nconst bip39 = __importStar(require(\"bip39\"));\n\nconst pbkdf2_1 = require(\"pbkdf2\");\n\nconst unorm = __importStar(require(\"unorm\"));\n\nconst englishmnemonic_1 = require(\"./englishmnemonic\");\n\nclass Bip39 {\n  static encode(entropy) {\n    const allowedEntropyLengths = [16, 20, 24, 28, 32];\n\n    if (allowedEntropyLengths.indexOf(entropy.length) === -1) {\n      throw new Error(\"invalid input length\");\n    }\n\n    return new englishmnemonic_1.EnglishMnemonic(bip39.entropyToMnemonic(encoding_1.Encoding.toHex(entropy)));\n  }\n\n  static decode(mnemonic) {\n    return encoding_1.Encoding.fromHex(bip39.mnemonicToEntropy(mnemonic.toString()));\n  }\n\n  static async mnemonicToSeed(mnemonic, password) {\n    // reimplementation of bip39.mnemonicToSeed using the asynchronous\n    // interface of https://www.npmjs.com/package/pbkdf2\n    const mnemonicBytes = Buffer.from(unorm.nfkd(mnemonic.toString()), \"utf8\");\n    const salt = \"mnemonic\" + (password ? unorm.nfkd(password) : \"\");\n    const saltBytes = Buffer.from(salt, \"utf8\");\n    return this.pbkdf2(mnemonicBytes, saltBytes, 2048, 64, \"sha512\");\n  } // convert pbkdf2's calllback interface to Promise interface\n\n\n  static async pbkdf2(secret, salt, iterations, keylen, digest) {\n    return new Promise((resolve, reject) => {\n      pbkdf2_1.pbkdf2(secret, salt, iterations, keylen, digest, (err, derivedKey) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(new Uint8Array(derivedKey));\n        }\n      });\n    });\n  }\n\n}\n\nexports.Bip39 = Bip39;","map":{"version":3,"sources":["../src/bip39.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,MAAA,UAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,KAAA,GAAA,YAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,MAAA,KAAA,GAAA,YAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAEA,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAEA,MAAa,KAAb,CAAkB;AACI,SAAN,MAAM,CAAC,OAAD,EAAoB;AACtC,UAAM,qBAAqB,GAAsB,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,CAAjD;;AAEA,QAAI,qBAAqB,CAAC,OAAtB,CAA8B,OAAO,CAAC,MAAtC,MAAkD,CAAC,CAAvD,EAA0D;AACxD,YAAM,IAAI,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,WAAO,IAAI,iBAAA,CAAA,eAAJ,CAAoB,KAAK,CAAC,iBAAN,CAAwB,UAAA,CAAA,QAAA,CAAS,KAAT,CAAe,OAAf,CAAxB,CAApB,CAAP;AACD;;AAEmB,SAAN,MAAM,CAAC,QAAD,EAA0B;AAC5C,WAAO,UAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,KAAK,CAAC,iBAAN,CAAwB,QAAQ,CAAC,QAAT,EAAxB,CAAjB,CAAP;AACD;;AAEiC,eAAd,cAAc,CAAC,QAAD,EAA4B,QAA5B,EAA6C;AAC7E;AACA;AACA,UAAM,aAAa,GAAG,MAAM,CAAC,IAAP,CAAY,KAAK,CAAC,IAAN,CAAW,QAAQ,CAAC,QAAT,EAAX,CAAZ,EAA6C,MAA7C,CAAtB;AACA,UAAM,IAAI,GAAG,cAAc,QAAQ,GAAG,KAAK,CAAC,IAAN,CAAW,QAAX,CAAH,GAA0B,EAAhD,CAAb;AACA,UAAM,SAAS,GAAG,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,MAAlB,CAAlB;AACA,WAAO,KAAK,MAAL,CAAY,aAAZ,EAA2B,SAA3B,EAAsC,IAAtC,EAA4C,EAA5C,EAAgD,QAAhD,CAAP;AACD,GAtBe,CAwBhB;;;AAC2B,eAAN,MAAM,CACzB,MADyB,EAEzB,IAFyB,EAGzB,UAHyB,EAIzB,MAJyB,EAKzB,MALyB,EAKX;AAEd,WAAO,IAAI,OAAJ,CAAiB,CAAC,OAAD,EAAU,MAAV,KAAoB;AAC1C,MAAA,QAAA,CAAA,MAAA,CAAO,MAAP,EAAe,IAAf,EAAqB,UAArB,EAAiC,MAAjC,EAAyC,MAAzC,EAAiD,CAAC,GAAD,EAAW,UAAX,KAA8B;AAC7E,YAAI,GAAJ,EAAS;AACP,UAAA,MAAM,CAAC,GAAD,CAAN;AACD,SAFD,MAEO;AACL,UAAA,OAAO,CAAC,IAAI,UAAJ,CAAe,UAAf,CAAD,CAAP;AACD;AACF,OAND;AAOD,KARM,CAAP;AASD;;AAzCe;;AAAlB,OAAA,CAAA,KAAA,GAAA,KAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst encoding_1 = require(\"@iov/encoding\");\nconst bip39 = __importStar(require(\"bip39\"));\nconst pbkdf2_1 = require(\"pbkdf2\");\nconst unorm = __importStar(require(\"unorm\"));\nconst englishmnemonic_1 = require(\"./englishmnemonic\");\nclass Bip39 {\n    static encode(entropy) {\n        const allowedEntropyLengths = [16, 20, 24, 28, 32];\n        if (allowedEntropyLengths.indexOf(entropy.length) === -1) {\n            throw new Error(\"invalid input length\");\n        }\n        return new englishmnemonic_1.EnglishMnemonic(bip39.entropyToMnemonic(encoding_1.Encoding.toHex(entropy)));\n    }\n    static decode(mnemonic) {\n        return encoding_1.Encoding.fromHex(bip39.mnemonicToEntropy(mnemonic.toString()));\n    }\n    static async mnemonicToSeed(mnemonic, password) {\n        // reimplementation of bip39.mnemonicToSeed using the asynchronous\n        // interface of https://www.npmjs.com/package/pbkdf2\n        const mnemonicBytes = Buffer.from(unorm.nfkd(mnemonic.toString()), \"utf8\");\n        const salt = \"mnemonic\" + (password ? unorm.nfkd(password) : \"\");\n        const saltBytes = Buffer.from(salt, \"utf8\");\n        return this.pbkdf2(mnemonicBytes, saltBytes, 2048, 64, \"sha512\");\n    }\n    // convert pbkdf2's calllback interface to Promise interface\n    static async pbkdf2(secret, salt, iterations, keylen, digest) {\n        return new Promise((resolve, reject) => {\n            pbkdf2_1.pbkdf2(secret, salt, iterations, keylen, digest, (err, derivedKey) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(new Uint8Array(derivedKey));\n                }\n            });\n        });\n    }\n}\nexports.Bip39 = Bip39;\n//# sourceMappingURL=bip39.js.map"]},"metadata":{},"sourceType":"script"}