{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto_1 = require(\"@iov/crypto\");\n\nvar encoding_1 = require(\"@iov/encoding\");\n\nvar types_1 = require(\"./types\");\n\nvar fromBase64 = encoding_1.Encoding.fromBase64;\n\nfunction rawSecp256k1PubkeyToAddress(pubkeyRaw, prefix) {\n  if (pubkeyRaw.length !== 33) {\n    throw new Error(\"Invalid Secp256k1 pubkey length (compressed): \".concat(pubkeyRaw.length));\n  }\n\n  var hash1 = new crypto_1.Sha256(pubkeyRaw).digest();\n  var hash2 = new crypto_1.Ripemd160(hash1).digest();\n  return encoding_1.Bech32.encode(prefix, hash2);\n}\n\nexports.rawSecp256k1PubkeyToAddress = rawSecp256k1PubkeyToAddress; // See https://github.com/tendermint/tendermint/blob/f2ada0a604b4c0763bda2f64fac53d506d3beca7/docs/spec/blockchain/encoding.md#public-key-cryptography\n// This assumes we already have a cosmos-compressed pubkey\n\nfunction pubkeyToAddress(pubkey, prefix) {\n  var pubkeyBytes = fromBase64(pubkey.value);\n\n  switch (pubkey.type) {\n    case types_1.pubkeyType.secp256k1:\n      {\n        return rawSecp256k1PubkeyToAddress(pubkeyBytes, prefix);\n      }\n\n    case types_1.pubkeyType.ed25519:\n      {\n        if (pubkeyBytes.length !== 32) {\n          throw new Error(\"Invalid Ed25519 pubkey length: \".concat(pubkeyBytes.length));\n        }\n\n        var hash = new crypto_1.Sha256(pubkeyBytes).digest();\n        return encoding_1.Bech32.encode(prefix, hash.slice(0, 20));\n      }\n\n    case types_1.pubkeyType.sr25519:\n      {\n        if (pubkeyBytes.length !== 32) {\n          throw new Error(\"Invalid Sr25519 pubkey length: \".concat(pubkeyBytes.length));\n        }\n\n        var _hash = new crypto_1.Sha256(pubkeyBytes).digest();\n\n        return encoding_1.Bech32.encode(prefix, _hash.slice(0, 20));\n      }\n\n    default:\n      throw new Error(\"Unrecognized public key algorithm\");\n  }\n}\n\nexports.pubkeyToAddress = pubkeyToAddress;","map":{"version":3,"sources":["../src/address.ts"],"names":[],"mappings":";;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;IAEQ,U,GAAe,UAAA,CAAA,Q,CAAf,U;;AAER,SAAgB,2BAAhB,CAA4C,SAA5C,EAAmE,MAAnE,EAAiF;AAC/E,MAAI,SAAS,CAAC,MAAV,KAAqB,EAAzB,EAA6B;AAC3B,UAAM,IAAI,KAAJ,yDAA2D,SAAS,CAAC,MAArE,EAAN;AACD;;AACD,MAAM,KAAK,GAAG,IAAI,QAAA,CAAA,MAAJ,CAAW,SAAX,EAAsB,MAAtB,EAAd;AACA,MAAM,KAAK,GAAG,IAAI,QAAA,CAAA,SAAJ,CAAc,KAAd,EAAqB,MAArB,EAAd;AACA,SAAO,UAAA,CAAA,MAAA,CAAO,MAAP,CAAc,MAAd,EAAsB,KAAtB,CAAP;AACD;;AAPD,OAAA,CAAA,2BAAA,GAAA,2BAAA,C,CASA;AACA;;AACA,SAAgB,eAAhB,CAAgC,MAAhC,EAAgD,MAAhD,EAA8D;AAC5D,MAAM,WAAW,GAAG,UAAU,CAAC,MAAM,CAAC,KAAR,CAA9B;;AACA,UAAQ,MAAM,CAAC,IAAf;AACE,SAAK,OAAA,CAAA,UAAA,CAAW,SAAhB;AAA2B;AACzB,eAAO,2BAA2B,CAAC,WAAD,EAAc,MAAd,CAAlC;AACD;;AACD,SAAK,OAAA,CAAA,UAAA,CAAW,OAAhB;AAAyB;AACvB,YAAI,WAAW,CAAC,MAAZ,KAAuB,EAA3B,EAA+B;AAC7B,gBAAM,IAAI,KAAJ,0CAA4C,WAAW,CAAC,MAAxD,EAAN;AACD;;AACD,YAAM,IAAI,GAAG,IAAI,QAAA,CAAA,MAAJ,CAAW,WAAX,EAAwB,MAAxB,EAAb;AACA,eAAO,UAAA,CAAA,MAAA,CAAO,MAAP,CAAc,MAAd,EAAsB,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,EAAd,CAAtB,CAAP;AACD;;AACD,SAAK,OAAA,CAAA,UAAA,CAAW,OAAhB;AAAyB;AACvB,YAAI,WAAW,CAAC,MAAZ,KAAuB,EAA3B,EAA+B;AAC7B,gBAAM,IAAI,KAAJ,0CAA4C,WAAW,CAAC,MAAxD,EAAN;AACD;;AACD,YAAM,KAAI,GAAG,IAAI,QAAA,CAAA,MAAJ,CAAW,WAAX,EAAwB,MAAxB,EAAb;;AACA,eAAO,UAAA,CAAA,MAAA,CAAO,MAAP,CAAc,MAAd,EAAsB,KAAI,CAAC,KAAL,CAAW,CAAX,EAAc,EAAd,CAAtB,CAAP;AACD;;AACD;AACE,YAAM,IAAI,KAAJ,CAAU,mCAAV,CAAN;AAnBJ;AAqBD;;AAvBD,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"@iov/crypto\");\nconst encoding_1 = require(\"@iov/encoding\");\nconst types_1 = require(\"./types\");\nconst { fromBase64 } = encoding_1.Encoding;\nfunction rawSecp256k1PubkeyToAddress(pubkeyRaw, prefix) {\n    if (pubkeyRaw.length !== 33) {\n        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyRaw.length}`);\n    }\n    const hash1 = new crypto_1.Sha256(pubkeyRaw).digest();\n    const hash2 = new crypto_1.Ripemd160(hash1).digest();\n    return encoding_1.Bech32.encode(prefix, hash2);\n}\nexports.rawSecp256k1PubkeyToAddress = rawSecp256k1PubkeyToAddress;\n// See https://github.com/tendermint/tendermint/blob/f2ada0a604b4c0763bda2f64fac53d506d3beca7/docs/spec/blockchain/encoding.md#public-key-cryptography\n// This assumes we already have a cosmos-compressed pubkey\nfunction pubkeyToAddress(pubkey, prefix) {\n    const pubkeyBytes = fromBase64(pubkey.value);\n    switch (pubkey.type) {\n        case types_1.pubkeyType.secp256k1: {\n            return rawSecp256k1PubkeyToAddress(pubkeyBytes, prefix);\n        }\n        case types_1.pubkeyType.ed25519: {\n            if (pubkeyBytes.length !== 32) {\n                throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyBytes.length}`);\n            }\n            const hash = new crypto_1.Sha256(pubkeyBytes).digest();\n            return encoding_1.Bech32.encode(prefix, hash.slice(0, 20));\n        }\n        case types_1.pubkeyType.sr25519: {\n            if (pubkeyBytes.length !== 32) {\n                throw new Error(`Invalid Sr25519 pubkey length: ${pubkeyBytes.length}`);\n            }\n            const hash = new crypto_1.Sha256(pubkeyBytes).digest();\n            return encoding_1.Bech32.encode(prefix, hash.slice(0, 20));\n        }\n        default:\n            throw new Error(\"Unrecognized public key algorithm\");\n    }\n}\nexports.pubkeyToAddress = pubkeyToAddress;\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"script"}