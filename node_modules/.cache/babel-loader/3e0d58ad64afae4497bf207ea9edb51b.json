{"ast":null,"code":"\"use strict\";\n/** Type which represents AES blocks */\n\nvar _classCallCheck = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constant_time_1 = require(\"./constant-time\");\n\nvar wipe_1 = require(\"./wipe\");\n/** An AES block (128-bits) */\n\n\nvar Block = /*#__PURE__*/function () {\n  function Block() {\n    _classCallCheck(this, Block);\n\n    this.data = new Uint8Array(Block.SIZE);\n  }\n  /**\n   * Clear the given array by setting its values to zero.\n   *\n   * WARNING: The fact that it sets bytes to zero can be relied on.\n   *\n   * There is no guarantee that this function makes data disappear from memory,\n   * as runtime implementation can, for example, have copying garbage collector\n   * that will make copies of sensitive data before we wipe it. Or that an\n   * operating system will write our data to swap or sleep image. Another thing\n   * is that an optimizing compiler can remove calls to this function or make it\n   * no-op. There's nothing we can do with it, so we just do our best and hope\n   * that everything will be okay and good will triumph over evil.\n   */\n\n\n  _createClass(Block, [{\n    key: \"clear\",\n    value: function clear() {\n      wipe_1.wipe(this.data);\n    }\n    /**\n     * Make a copy of this block, returning a new block\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var ret = new Block();\n      ret.copy(this);\n      return ret;\n    }\n    /** Copy the contents of another block into this one */\n\n  }, {\n    key: \"copy\",\n    value: function copy(other) {\n      this.data.set(other.data);\n    }\n    /**\n     * Double a value over GF(2^128):\n     *\n     *     a<<1 if firstbit(a)=0\n     *     (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n     */\n\n  }, {\n    key: \"dbl\",\n    value: function dbl() {\n      var carry = 0;\n\n      for (var i = Block.SIZE - 1; i >= 0; i--) {\n        var b = this.data[i] >>> 7 & 0xff;\n        this.data[i] = this.data[i] << 1 | carry;\n        carry = b;\n      }\n\n      this.data[Block.SIZE - 1] ^= constant_time_1.select(carry, Block.R, 0);\n      carry = 0;\n    }\n  }]);\n\n  return Block;\n}();\n/** Size of a block as used by the AES cipher */\n\n\nBlock.SIZE = 16;\n/** Minimal irreducible polynomial for a 128-bit block size */\n\nBlock.R = 0x87;\nexports.default = Block;","map":{"version":3,"sources":["/Users/aidansalzmann/redacted-mint/node_modules/miscreant/release/internals/block.js"],"names":["Object","defineProperty","exports","value","constant_time_1","require","wipe_1","Block","data","Uint8Array","SIZE","wipe","ret","copy","other","set","carry","i","b","select","R","default"],"mappings":"AAAA;AACA;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAMC,eAAe,GAAGC,OAAO,CAAC,iBAAD,CAA/B;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;AACA;;;IACME,K;AACF,mBAAc;AAAA;;AACV,SAAKC,IAAL,GAAY,IAAIC,UAAJ,CAAeF,KAAK,CAACG,IAArB,CAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACI,iBAAQ;AACJJ,MAAAA,MAAM,CAACK,IAAP,CAAY,KAAKH,IAAjB;AACH;AACD;AACJ;AACA;;;;WACI,iBAAQ;AACJ,UAAMI,GAAG,GAAG,IAAIL,KAAJ,EAAZ;AACAK,MAAAA,GAAG,CAACC,IAAJ,CAAS,IAAT;AACA,aAAOD,GAAP;AACH;AACD;;;;WACA,cAAKE,KAAL,EAAY;AACR,WAAKN,IAAL,CAAUO,GAAV,CAAcD,KAAK,CAACN,IAApB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;;WACI,eAAM;AACF,UAAIQ,KAAK,GAAG,CAAZ;;AACA,WAAK,IAAIC,CAAC,GAAGV,KAAK,CAACG,IAAN,GAAa,CAA1B,EAA6BO,CAAC,IAAI,CAAlC,EAAqCA,CAAC,EAAtC,EAA0C;AACtC,YAAMC,CAAC,GAAI,KAAKV,IAAL,CAAUS,CAAV,MAAiB,CAAlB,GAAuB,IAAjC;AACA,aAAKT,IAAL,CAAUS,CAAV,IAAgB,KAAKT,IAAL,CAAUS,CAAV,KAAgB,CAAjB,GAAsBD,KAArC;AACAA,QAAAA,KAAK,GAAGE,CAAR;AACH;;AACD,WAAKV,IAAL,CAAUD,KAAK,CAACG,IAAN,GAAa,CAAvB,KAA6BN,eAAe,CAACe,MAAhB,CAAuBH,KAAvB,EAA8BT,KAAK,CAACa,CAApC,EAAuC,CAAvC,CAA7B;AACAJ,MAAAA,KAAK,GAAG,CAAR;AACH;;;;;AAEL;;;AACAT,KAAK,CAACG,IAAN,GAAa,EAAb;AACA;;AACAH,KAAK,CAACa,CAAN,GAAU,IAAV;AACAlB,OAAO,CAACmB,OAAR,GAAkBd,KAAlB","sourcesContent":["\"use strict\";\n/** Type which represents AES blocks */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constant_time_1 = require(\"./constant-time\");\nconst wipe_1 = require(\"./wipe\");\n/** An AES block (128-bits) */\nclass Block {\n    constructor() {\n        this.data = new Uint8Array(Block.SIZE);\n    }\n    /**\n     * Clear the given array by setting its values to zero.\n     *\n     * WARNING: The fact that it sets bytes to zero can be relied on.\n     *\n     * There is no guarantee that this function makes data disappear from memory,\n     * as runtime implementation can, for example, have copying garbage collector\n     * that will make copies of sensitive data before we wipe it. Or that an\n     * operating system will write our data to swap or sleep image. Another thing\n     * is that an optimizing compiler can remove calls to this function or make it\n     * no-op. There's nothing we can do with it, so we just do our best and hope\n     * that everything will be okay and good will triumph over evil.\n     */\n    clear() {\n        wipe_1.wipe(this.data);\n    }\n    /**\n     * Make a copy of this block, returning a new block\n     */\n    clone() {\n        const ret = new Block();\n        ret.copy(this);\n        return ret;\n    }\n    /** Copy the contents of another block into this one */\n    copy(other) {\n        this.data.set(other.data);\n    }\n    /**\n     * Double a value over GF(2^128):\n     *\n     *     a<<1 if firstbit(a)=0\n     *     (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n     */\n    dbl() {\n        let carry = 0;\n        for (let i = Block.SIZE - 1; i >= 0; i--) {\n            const b = (this.data[i] >>> 7) & 0xff;\n            this.data[i] = (this.data[i] << 1) | carry;\n            carry = b;\n        }\n        this.data[Block.SIZE - 1] ^= constant_time_1.select(carry, Block.R, 0);\n        carry = 0;\n    }\n}\n/** Size of a block as used by the AES cipher */\nBlock.SIZE = 16;\n/** Minimal irreducible polynomial for a 128-bit block size */\nBlock.R = 0x87;\nexports.default = Block;\n"]},"metadata":{},"sourceType":"script"}