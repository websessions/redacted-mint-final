{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst base64js = __importStar(require(\"base64-js\"));\n\nconst readonly_date_1 = require(\"readonly-date\");\n\nclass Encoding {\n  static toHex(data) {\n    let out = \"\";\n\n    for (const byte of data) {\n      out += (\"0\" + byte.toString(16)).slice(-2);\n    }\n\n    return out;\n  }\n\n  static fromHex(hexstring) {\n    if (hexstring.length % 2 !== 0) {\n      throw new Error(\"hex string length must be a multiple of 2\");\n    } // tslint:disable-next-line:readonly-array\n\n\n    const listOfInts = [];\n\n    for (let i = 0; i < hexstring.length; i += 2) {\n      const hexByteAsString = hexstring.substr(i, 2);\n\n      if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {\n        throw new Error(\"hex string contains invalid characters\");\n      }\n\n      listOfInts.push(parseInt(hexByteAsString, 16));\n    }\n\n    return new Uint8Array(listOfInts);\n  }\n\n  static toBase64(data) {\n    return base64js.fromByteArray(data);\n  }\n\n  static fromBase64(base64String) {\n    if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {\n      throw new Error(\"Invalid base64 string format\");\n    }\n\n    return base64js.toByteArray(base64String);\n  }\n\n  static toAscii(input) {\n    const toNums = str => str.split(\"\").map(x => {\n      const charCode = x.charCodeAt(0); // 0x00–0x1F control characters\n      // 0x20–0x7E printable characters\n      // 0x7F delete character\n      // 0x80–0xFF out of 7 bit ascii range\n\n      if (charCode < 0x20 || charCode > 0x7e) {\n        throw new Error(\"Cannot encode character that is out of printable ASCII range: \" + charCode);\n      }\n\n      return charCode;\n    });\n\n    return Uint8Array.from(toNums(input));\n  }\n\n  static fromAscii(data) {\n    const fromNums = listOfNumbers => listOfNumbers.map(x => {\n      // 0x00–0x1F control characters\n      // 0x20–0x7E printable characters\n      // 0x7F delete character\n      // 0x80–0xFF out of 7 bit ascii range\n      if (x < 0x20 || x > 0x7e) {\n        throw new Error(\"Cannot decode character that is out of printable ASCII range: \" + x);\n      }\n\n      return String.fromCharCode(x);\n    });\n\n    return fromNums(Array.from(data)).join(\"\");\n  }\n\n  static toUtf8(str) {\n    // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n    if (typeof TextEncoder !== \"undefined\") {\n      return new TextEncoder().encode(str);\n    } // Use Buffer hack instead of nodejs util.TextEncoder to ensure\n    // webpack does not bundle the util module for browsers.\n\n\n    return new Uint8Array(Buffer.from(str, \"utf8\"));\n  }\n\n  static fromUtf8(data) {\n    // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n    if (typeof TextDecoder !== \"undefined\") {\n      return new TextDecoder(\"utf-8\", {\n        fatal: true\n      }).decode(data);\n    } // Use Buffer hack instead of nodejs util.TextDecoder to ensure\n    // webpack does not bundle the util module for browsers.\n    // Buffer.toString has no fatal option\n\n\n    if (!Encoding.isValidUtf8(data)) {\n      throw new Error(\"Invalid UTF8 data\");\n    }\n\n    return Buffer.from(data).toString(\"utf8\");\n  }\n\n  static fromRfc3339(str) {\n    const rfc3339Matcher = /^(\\d{4})-(\\d{2})-(\\d{2})[T ](\\d{2}):(\\d{2}):(\\d{2})(\\.\\d{1,9})?((?:[+-]\\d{2}:\\d{2})|Z)$/;\n    const matches = rfc3339Matcher.exec(str);\n\n    if (!matches) {\n      throw new Error(\"Date string is not in RFC3339 format\");\n    }\n\n    const year = +matches[1];\n    const month = +matches[2];\n    const day = +matches[3];\n    const hour = +matches[4];\n    const minute = +matches[5];\n    const second = +matches[6]; // fractional seconds match either undefined or a string like \".1\", \".123456789\"\n\n    const milliSeconds = matches[7] ? Math.floor(+matches[7] * 1000) : 0;\n    let tzOffsetSign;\n    let tzOffsetHours;\n    let tzOffsetMinutes; // if timezone is undefined, it must be Z or nothing (otherwise the group would have captured).\n\n    if (matches[8] === \"Z\") {\n      tzOffsetSign = 1;\n      tzOffsetHours = 0;\n      tzOffsetMinutes = 0;\n    } else {\n      tzOffsetSign = matches[8].substring(0, 1) === \"-\" ? -1 : 1;\n      tzOffsetHours = +matches[8].substring(1, 3);\n      tzOffsetMinutes = +matches[8].substring(4, 6);\n    }\n\n    const tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60; // seconds\n\n    return new readonly_date_1.ReadonlyDate(readonly_date_1.ReadonlyDate.UTC(year, month - 1, day, hour, minute, second, milliSeconds) - tzOffset * 1000);\n  }\n\n  static toRfc3339(date) {\n    function padded(integer, length = 2) {\n      const filled = \"00000\" + integer.toString();\n      return filled.substring(filled.length - length);\n    }\n\n    const year = date.getUTCFullYear();\n    const month = padded(date.getUTCMonth() + 1);\n    const day = padded(date.getUTCDate());\n    const hour = padded(date.getUTCHours());\n    const minute = padded(date.getUTCMinutes());\n    const second = padded(date.getUTCSeconds());\n    const ms = padded(date.getUTCMilliseconds(), 3);\n    return `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms}Z`;\n  }\n\n  static isValidUtf8(data) {\n    const toStringAndBack = Buffer.from(Buffer.from(data).toString(\"utf8\"), \"utf8\");\n    return Buffer.compare(Buffer.from(data), toStringAndBack) === 0;\n  }\n\n}\n\nexports.Encoding = Encoding;","map":{"version":3,"sources":["../src/encoding.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,MAAA,QAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AACA,MAAA,eAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAQA,MAAa,QAAb,CAAqB;AACA,SAAL,KAAK,CAAC,IAAD,EAAiB;AAClC,QAAI,GAAG,GAAG,EAAV;;AACA,SAAK,MAAM,IAAX,IAAmB,IAAnB,EAAyB;AACvB,MAAA,GAAG,IAAI,CAAC,MAAM,IAAI,CAAC,QAAL,CAAc,EAAd,CAAP,EAA0B,KAA1B,CAAgC,CAAC,CAAjC,CAAP;AACD;;AACD,WAAO,GAAP;AACD;;AAEoB,SAAP,OAAO,CAAC,SAAD,EAAkB;AACrC,QAAI,SAAS,CAAC,MAAV,GAAmB,CAAnB,KAAyB,CAA7B,EAAgC;AAC9B,YAAM,IAAI,KAAJ,CAAU,2CAAV,CAAN;AACD,KAHoC,CAKrC;;;AACA,UAAM,UAAU,GAAa,EAA7B;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,IAAI,CAA3C,EAA8C;AAC5C,YAAM,eAAe,GAAG,SAAS,CAAC,MAAV,CAAiB,CAAjB,EAAoB,CAApB,CAAxB;;AACA,UAAI,CAAC,eAAe,CAAC,KAAhB,CAAsB,cAAtB,CAAL,EAA4C;AAC1C,cAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AACD;;AACD,MAAA,UAAU,CAAC,IAAX,CAAgB,QAAQ,CAAC,eAAD,EAAkB,EAAlB,CAAxB;AACD;;AACD,WAAO,IAAI,UAAJ,CAAe,UAAf,CAAP;AACD;;AAEqB,SAAR,QAAQ,CAAC,IAAD,EAAiB;AACrC,WAAO,QAAQ,CAAC,aAAT,CAAuB,IAAvB,CAAP;AACD;;AAEuB,SAAV,UAAU,CAAC,YAAD,EAAqB;AAC3C,QAAI,CAAC,YAAY,CAAC,KAAb,CAAmB,wBAAnB,CAAL,EAAmD;AACjD,YAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,WAAO,QAAQ,CAAC,WAAT,CAAqB,YAArB,CAAP;AACD;;AAEoB,SAAP,OAAO,CAAC,KAAD,EAAc;AACjC,UAAM,MAAM,GAAI,GAAD,IACb,GAAG,CAAC,KAAJ,CAAU,EAAV,EAAc,GAAd,CAAmB,CAAD,IAAc;AAC9B,YAAM,QAAQ,GAAG,CAAC,CAAC,UAAF,CAAa,CAAb,CAAjB,CAD8B,CAE9B;AACA;AACA;AACA;;AACA,UAAI,QAAQ,GAAG,IAAX,IAAmB,QAAQ,GAAG,IAAlC,EAAwC;AACtC,cAAM,IAAI,KAAJ,CAAU,mEAAmE,QAA7E,CAAN;AACD;;AACD,aAAO,QAAP;AACD,KAVD,CADF;;AAYA,WAAO,UAAU,CAAC,IAAX,CAAgB,MAAM,CAAC,KAAD,CAAtB,CAAP;AACD;;AAEsB,SAAT,SAAS,CAAC,IAAD,EAAiB;AACtC,UAAM,QAAQ,GAAI,aAAD,IACf,aAAa,CAAC,GAAd,CAAmB,CAAD,IAAsB;AACtC;AACA;AACA;AACA;AACA,UAAI,CAAC,GAAG,IAAJ,IAAY,CAAC,GAAG,IAApB,EAA0B;AACxB,cAAM,IAAI,KAAJ,CAAU,mEAAmE,CAA7E,CAAN;AACD;;AACD,aAAO,MAAM,CAAC,YAAP,CAAoB,CAApB,CAAP;AACD,KATD,CADF;;AAYA,WAAO,QAAQ,CAAC,KAAK,CAAC,IAAN,CAAW,IAAX,CAAD,CAAR,CAA2B,IAA3B,CAAgC,EAAhC,CAAP;AACD;;AAEmB,SAAN,MAAM,CAAC,GAAD,EAAY;AAC9B;AACA,QAAI,OAAO,WAAP,KAAuB,WAA3B,EAAwC;AACtC,aAAO,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,GAAzB,CAAP;AACD,KAJ6B,CAM9B;AACA;;;AACA,WAAO,IAAI,UAAJ,CAAe,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,MAAjB,CAAf,CAAP;AACD;;AAEqB,SAAR,QAAQ,CAAC,IAAD,EAAiB;AACrC;AACA,QAAI,OAAO,WAAP,KAAuB,WAA3B,EAAwC;AACtC,aAAO,IAAI,WAAJ,CAAgB,OAAhB,EAAyB;AAAE,QAAA,KAAK,EAAE;AAAT,OAAzB,EAA0C,MAA1C,CAAiD,IAAjD,CAAP;AACD,KAJoC,CAMrC;AACA;AACA;;;AACA,QAAI,CAAC,QAAQ,CAAC,WAAT,CAAqB,IAArB,CAAL,EAAiC;AAC/B,YAAM,IAAI,KAAJ,CAAU,mBAAV,CAAN;AACD;;AACD,WAAO,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,QAAlB,CAA2B,MAA3B,CAAP;AACD;;AAEwB,SAAX,WAAW,CAAC,GAAD,EAAY;AACnC,UAAM,cAAc,GAAG,yFAAvB;AAEA,UAAM,OAAO,GAAG,cAAc,CAAC,IAAf,CAAoB,GAApB,CAAhB;;AACA,QAAI,CAAC,OAAL,EAAc;AACZ,YAAM,IAAI,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,UAAM,IAAI,GAAG,CAAC,OAAO,CAAC,CAAD,CAArB;AACA,UAAM,KAAK,GAAG,CAAC,OAAO,CAAC,CAAD,CAAtB;AACA,UAAM,GAAG,GAAG,CAAC,OAAO,CAAC,CAAD,CAApB;AACA,UAAM,IAAI,GAAG,CAAC,OAAO,CAAC,CAAD,CAArB;AACA,UAAM,MAAM,GAAG,CAAC,OAAO,CAAC,CAAD,CAAvB;AACA,UAAM,MAAM,GAAG,CAAC,OAAO,CAAC,CAAD,CAAvB,CAbmC,CAenC;;AACA,UAAM,YAAY,GAAG,OAAO,CAAC,CAAD,CAAP,GAAa,IAAI,CAAC,KAAL,CAAW,CAAC,OAAO,CAAC,CAAD,CAAR,GAAc,IAAzB,CAAb,GAA8C,CAAnE;AAEA,QAAI,YAAJ;AACA,QAAI,aAAJ;AACA,QAAI,eAAJ,CApBmC,CAsBnC;;AACA,QAAI,OAAO,CAAC,CAAD,CAAP,KAAe,GAAnB,EAAwB;AACtB,MAAA,YAAY,GAAG,CAAf;AACA,MAAA,aAAa,GAAG,CAAhB;AACA,MAAA,eAAe,GAAG,CAAlB;AACD,KAJD,MAIO;AACL,MAAA,YAAY,GAAG,OAAO,CAAC,CAAD,CAAP,CAAW,SAAX,CAAqB,CAArB,EAAwB,CAAxB,MAA+B,GAA/B,GAAqC,CAAC,CAAtC,GAA0C,CAAzD;AACA,MAAA,aAAa,GAAG,CAAC,OAAO,CAAC,CAAD,CAAP,CAAW,SAAX,CAAqB,CAArB,EAAwB,CAAxB,CAAjB;AACA,MAAA,eAAe,GAAG,CAAC,OAAO,CAAC,CAAD,CAAP,CAAW,SAAX,CAAqB,CAArB,EAAwB,CAAxB,CAAnB;AACD;;AAED,UAAM,QAAQ,GAAG,YAAY,IAAI,aAAa,GAAG,EAAhB,GAAqB,eAAzB,CAAZ,GAAwD,EAAzE,CAjCmC,CAiC0C;;AAE7E,WAAO,IAAI,eAAA,CAAA,YAAJ,CACL,eAAA,CAAA,YAAA,CAAa,GAAb,CAAiB,IAAjB,EAAuB,KAAK,GAAG,CAA/B,EAAkC,GAAlC,EAAuC,IAAvC,EAA6C,MAA7C,EAAqD,MAArD,EAA6D,YAA7D,IAA6E,QAAQ,GAAG,IADnF,CAAP;AAGD;;AAEsB,SAAT,SAAS,CAAC,IAAD,EAA0B;AAC/C,aAAS,MAAT,CAAgB,OAAhB,EAAiC,MAAM,GAAG,CAA1C,EAA2C;AACzC,YAAM,MAAM,GAAG,UAAU,OAAO,CAAC,QAAR,EAAzB;AACA,aAAO,MAAM,CAAC,SAAP,CAAiB,MAAM,CAAC,MAAP,GAAgB,MAAjC,CAAP;AACD;;AAED,UAAM,IAAI,GAAG,IAAI,CAAC,cAAL,EAAb;AACA,UAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,WAAL,KAAqB,CAAtB,CAApB;AACA,UAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,UAAL,EAAD,CAAlB;AACA,UAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,WAAL,EAAD,CAAnB;AACA,UAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,aAAL,EAAD,CAArB;AACA,UAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,aAAL,EAAD,CAArB;AACA,UAAM,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC,kBAAL,EAAD,EAA4B,CAA5B,CAAjB;AAEA,WAAO,GAAG,IAAI,IAAI,KAAK,IAAI,GAAG,IAAI,IAAI,IAAI,MAAM,IAAI,MAAM,IAAI,EAAE,GAAhE;AACD;;AAEyB,SAAX,WAAW,CAAC,IAAD,EAAiB;AACzC,UAAM,eAAe,GAAG,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,QAAlB,CAA2B,MAA3B,CAAZ,EAAgD,MAAhD,CAAxB;AACA,WAAO,MAAM,CAAC,OAAP,CAAe,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAf,EAAkC,eAAlC,MAAuD,CAA9D;AACD;;AA3JkB;;AAArB,OAAA,CAAA,QAAA,GAAA,QAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base64js = __importStar(require(\"base64-js\"));\nconst readonly_date_1 = require(\"readonly-date\");\nclass Encoding {\n    static toHex(data) {\n        let out = \"\";\n        for (const byte of data) {\n            out += (\"0\" + byte.toString(16)).slice(-2);\n        }\n        return out;\n    }\n    static fromHex(hexstring) {\n        if (hexstring.length % 2 !== 0) {\n            throw new Error(\"hex string length must be a multiple of 2\");\n        }\n        // tslint:disable-next-line:readonly-array\n        const listOfInts = [];\n        for (let i = 0; i < hexstring.length; i += 2) {\n            const hexByteAsString = hexstring.substr(i, 2);\n            if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {\n                throw new Error(\"hex string contains invalid characters\");\n            }\n            listOfInts.push(parseInt(hexByteAsString, 16));\n        }\n        return new Uint8Array(listOfInts);\n    }\n    static toBase64(data) {\n        return base64js.fromByteArray(data);\n    }\n    static fromBase64(base64String) {\n        if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {\n            throw new Error(\"Invalid base64 string format\");\n        }\n        return base64js.toByteArray(base64String);\n    }\n    static toAscii(input) {\n        const toNums = (str) => str.split(\"\").map((x) => {\n            const charCode = x.charCodeAt(0);\n            // 0x00–0x1F control characters\n            // 0x20–0x7E printable characters\n            // 0x7F delete character\n            // 0x80–0xFF out of 7 bit ascii range\n            if (charCode < 0x20 || charCode > 0x7e) {\n                throw new Error(\"Cannot encode character that is out of printable ASCII range: \" + charCode);\n            }\n            return charCode;\n        });\n        return Uint8Array.from(toNums(input));\n    }\n    static fromAscii(data) {\n        const fromNums = (listOfNumbers) => listOfNumbers.map((x) => {\n            // 0x00–0x1F control characters\n            // 0x20–0x7E printable characters\n            // 0x7F delete character\n            // 0x80–0xFF out of 7 bit ascii range\n            if (x < 0x20 || x > 0x7e) {\n                throw new Error(\"Cannot decode character that is out of printable ASCII range: \" + x);\n            }\n            return String.fromCharCode(x);\n        });\n        return fromNums(Array.from(data)).join(\"\");\n    }\n    static toUtf8(str) {\n        // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n        if (typeof TextEncoder !== \"undefined\") {\n            return new TextEncoder().encode(str);\n        }\n        // Use Buffer hack instead of nodejs util.TextEncoder to ensure\n        // webpack does not bundle the util module for browsers.\n        return new Uint8Array(Buffer.from(str, \"utf8\"));\n    }\n    static fromUtf8(data) {\n        // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n        if (typeof TextDecoder !== \"undefined\") {\n            return new TextDecoder(\"utf-8\", { fatal: true }).decode(data);\n        }\n        // Use Buffer hack instead of nodejs util.TextDecoder to ensure\n        // webpack does not bundle the util module for browsers.\n        // Buffer.toString has no fatal option\n        if (!Encoding.isValidUtf8(data)) {\n            throw new Error(\"Invalid UTF8 data\");\n        }\n        return Buffer.from(data).toString(\"utf8\");\n    }\n    static fromRfc3339(str) {\n        const rfc3339Matcher = /^(\\d{4})-(\\d{2})-(\\d{2})[T ](\\d{2}):(\\d{2}):(\\d{2})(\\.\\d{1,9})?((?:[+-]\\d{2}:\\d{2})|Z)$/;\n        const matches = rfc3339Matcher.exec(str);\n        if (!matches) {\n            throw new Error(\"Date string is not in RFC3339 format\");\n        }\n        const year = +matches[1];\n        const month = +matches[2];\n        const day = +matches[3];\n        const hour = +matches[4];\n        const minute = +matches[5];\n        const second = +matches[6];\n        // fractional seconds match either undefined or a string like \".1\", \".123456789\"\n        const milliSeconds = matches[7] ? Math.floor(+matches[7] * 1000) : 0;\n        let tzOffsetSign;\n        let tzOffsetHours;\n        let tzOffsetMinutes;\n        // if timezone is undefined, it must be Z or nothing (otherwise the group would have captured).\n        if (matches[8] === \"Z\") {\n            tzOffsetSign = 1;\n            tzOffsetHours = 0;\n            tzOffsetMinutes = 0;\n        }\n        else {\n            tzOffsetSign = matches[8].substring(0, 1) === \"-\" ? -1 : 1;\n            tzOffsetHours = +matches[8].substring(1, 3);\n            tzOffsetMinutes = +matches[8].substring(4, 6);\n        }\n        const tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60; // seconds\n        return new readonly_date_1.ReadonlyDate(readonly_date_1.ReadonlyDate.UTC(year, month - 1, day, hour, minute, second, milliSeconds) - tzOffset * 1000);\n    }\n    static toRfc3339(date) {\n        function padded(integer, length = 2) {\n            const filled = \"00000\" + integer.toString();\n            return filled.substring(filled.length - length);\n        }\n        const year = date.getUTCFullYear();\n        const month = padded(date.getUTCMonth() + 1);\n        const day = padded(date.getUTCDate());\n        const hour = padded(date.getUTCHours());\n        const minute = padded(date.getUTCMinutes());\n        const second = padded(date.getUTCSeconds());\n        const ms = padded(date.getUTCMilliseconds(), 3);\n        return `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms}Z`;\n    }\n    static isValidUtf8(data) {\n        const toStringAndBack = Buffer.from(Buffer.from(data).toString(\"utf8\"), \"utf8\");\n        return Buffer.compare(Buffer.from(data), toStringAndBack) === 0;\n    }\n}\nexports.Encoding = Encoding;\n//# sourceMappingURL=encoding.js.map"]},"metadata":{},"sourceType":"script"}