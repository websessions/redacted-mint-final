{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* tslint:disable:no-bitwise */\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar uint64MaxValue = new bn_js_1.default(\"18446744073709551615\", 10, \"be\");\n\nvar Uint32 = /*#__PURE__*/function () {\n  function Uint32(input) {\n    _classCallCheck(this, Uint32);\n\n    if (Number.isNaN(input)) {\n      throw new Error(\"Input is not a number\");\n    }\n\n    if (!Number.isInteger(input)) {\n      throw new Error(\"Input is not an integer\");\n    }\n\n    if (input < 0 || input > 4294967295) {\n      throw new Error(\"Input not in uint32 range: \" + input.toString());\n    }\n\n    this.data = input;\n  }\n\n  _createClass(Uint32, [{\n    key: \"toBytesBigEndian\",\n    value: function toBytesBigEndian() {\n      // Use division instead of shifting since bitwise operators are defined\n      // on SIGNED int32 in JavaScript and we don't want to risk surprises\n      return new Uint8Array([Math.floor(this.data / Math.pow(2, 24)) & 0xff, Math.floor(this.data / Math.pow(2, 16)) & 0xff, Math.floor(this.data / Math.pow(2, 8)) & 0xff, Math.floor(this.data / Math.pow(2, 0)) & 0xff]);\n    }\n  }, {\n    key: \"toBytesLittleEndian\",\n    value: function toBytesLittleEndian() {\n      // Use division instead of shifting since bitwise operators are defined\n      // on SIGNED int32 in JavaScript and we don't want to risk surprises\n      return new Uint8Array([Math.floor(this.data / Math.pow(2, 0)) & 0xff, Math.floor(this.data / Math.pow(2, 8)) & 0xff, Math.floor(this.data / Math.pow(2, 16)) & 0xff, Math.floor(this.data / Math.pow(2, 24)) & 0xff]);\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString();\n    }\n  }], [{\n    key: \"fromBigEndianBytes\",\n    value: function fromBigEndianBytes(bytes) {\n      if (bytes.length !== 4) {\n        throw new Error(\"Invalid input length. Expected 4 bytes.\");\n      } // tslint:disable-next-line:prefer-for-of\n\n\n      for (var i = 0; i < bytes.length; ++i) {\n        if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n          throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n        }\n      } // Use mulitiplication instead of shifting since bitwise operators are defined\n      // on SIGNED int32 in JavaScript and we don't want to risk surprises\n\n\n      return new Uint32(bytes[0] * Math.pow(2, 24) + bytes[1] * Math.pow(2, 16) + bytes[2] * Math.pow(2, 8) + bytes[3]);\n    }\n  }]);\n\n  return Uint32;\n}();\n\nexports.Uint32 = Uint32;\n\nvar Int53 = /*#__PURE__*/function () {\n  function Int53(input) {\n    _classCallCheck(this, Int53);\n\n    if (Number.isNaN(input)) {\n      throw new Error(\"Input is not a number\");\n    }\n\n    if (!Number.isInteger(input)) {\n      throw new Error(\"Input is not an integer\");\n    }\n\n    if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {\n      throw new Error(\"Input not in int53 range: \" + input.toString());\n    }\n\n    this.data = input;\n  }\n\n  _createClass(Int53, [{\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString();\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(str) {\n      if (!str.match(/^-?[0-9]+$/)) {\n        throw new Error(\"Invalid string format\");\n      }\n\n      return new Int53(Number.parseInt(str, 10));\n    }\n  }]);\n\n  return Int53;\n}();\n\nexports.Int53 = Int53;\n\nvar Uint53 = /*#__PURE__*/function () {\n  function Uint53(input) {\n    _classCallCheck(this, Uint53);\n\n    var signed = new Int53(input);\n\n    if (signed.toNumber() < 0) {\n      throw new Error(\"Input is negative\");\n    }\n\n    this.data = signed;\n  }\n\n  _createClass(Uint53, [{\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data.toNumber();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString();\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(str) {\n      var signed = Int53.fromString(str);\n      return new Uint53(signed.toNumber());\n    }\n  }]);\n\n  return Uint53;\n}();\n\nexports.Uint53 = Uint53;\n\nvar Uint64 = /*#__PURE__*/function () {\n  function Uint64(data) {\n    _classCallCheck(this, Uint64);\n\n    if (data.isNeg()) {\n      throw new Error(\"Input is negative\");\n    }\n\n    if (data.gt(uint64MaxValue)) {\n      throw new Error(\"Input exceeds uint64 range\");\n    }\n\n    this.data = data;\n  }\n\n  _createClass(Uint64, [{\n    key: \"toBytesBigEndian\",\n    value: function toBytesBigEndian() {\n      return Uint8Array.from(this.data.toArray(\"be\", 8));\n    }\n  }, {\n    key: \"toBytesLittleEndian\",\n    value: function toBytesLittleEndian() {\n      return Uint8Array.from(this.data.toArray(\"le\", 8));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString(10);\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data.toNumber();\n    }\n  }], [{\n    key: \"fromBytesBigEndian\",\n    value: function fromBytesBigEndian(bytes) {\n      if (bytes.length !== 8) {\n        throw new Error(\"Invalid input length. Expected 8 bytes.\");\n      } // tslint:disable-next-line:prefer-for-of\n\n\n      for (var i = 0; i < bytes.length; ++i) {\n        if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n          throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n        }\n      } // tslint:disable-next-line:readonly-array\n\n\n      var asArray = []; // tslint:disable-next-line:prefer-for-of\n\n      for (var _i = 0; _i < bytes.length; ++_i) {\n        asArray.push(bytes[_i]);\n      }\n\n      return new Uint64(new bn_js_1.default([].concat(asArray)));\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(str) {\n      if (!str.match(/^[0-9]+$/)) {\n        throw new Error(\"Invalid string format\");\n      }\n\n      return new Uint64(new bn_js_1.default(str, 10, \"be\"));\n    }\n  }, {\n    key: \"fromNumber\",\n    value: function fromNumber(input) {\n      if (Number.isNaN(input)) {\n        throw new Error(\"Input is not a number\");\n      }\n\n      var bigint;\n\n      try {\n        bigint = new bn_js_1.default(input);\n      } catch (_a) {\n        throw new Error(\"Input is not a safe integer\");\n      }\n\n      return new Uint64(bigint);\n    }\n  }]);\n\n  return Uint64;\n}();\n\nexports.Uint64 = Uint64;","map":{"version":3,"sources":["../src/integers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* tslint:disable:no-bitwise */\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst uint64MaxValue = new bn_js_1.default(\"18446744073709551615\", 10, \"be\");\nclass Uint32 {\n    constructor(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        if (input < 0 || input > 4294967295) {\n            throw new Error(\"Input not in uint32 range: \" + input.toString());\n        }\n        this.data = input;\n    }\n    static fromBigEndianBytes(bytes) {\n        if (bytes.length !== 4) {\n            throw new Error(\"Invalid input length. Expected 4 bytes.\");\n        }\n        // tslint:disable-next-line:prefer-for-of\n        for (let i = 0; i < bytes.length; ++i) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n                throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n            }\n        }\n        // Use mulitiplication instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint32(bytes[0] * 2 ** 24 + bytes[1] * 2 ** 16 + bytes[2] * 2 ** 8 + bytes[3]);\n    }\n    toBytesBigEndian() {\n        // Use division instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint8Array([\n            Math.floor(this.data / 2 ** 24) & 0xff,\n            Math.floor(this.data / 2 ** 16) & 0xff,\n            Math.floor(this.data / 2 ** 8) & 0xff,\n            Math.floor(this.data / 2 ** 0) & 0xff,\n        ]);\n    }\n    toBytesLittleEndian() {\n        // Use division instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint8Array([\n            Math.floor(this.data / 2 ** 0) & 0xff,\n            Math.floor(this.data / 2 ** 8) & 0xff,\n            Math.floor(this.data / 2 ** 16) & 0xff,\n            Math.floor(this.data / 2 ** 24) & 0xff,\n        ]);\n    }\n    toNumber() {\n        return this.data;\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Uint32 = Uint32;\nclass Int53 {\n    constructor(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\"Input not in int53 range: \" + input.toString());\n        }\n        this.data = input;\n    }\n    static fromString(str) {\n        if (!str.match(/^-?[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Int53(Number.parseInt(str, 10));\n    }\n    toNumber() {\n        return this.data;\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Int53 = Int53;\nclass Uint53 {\n    constructor(input) {\n        const signed = new Int53(input);\n        if (signed.toNumber() < 0) {\n            throw new Error(\"Input is negative\");\n        }\n        this.data = signed;\n    }\n    static fromString(str) {\n        const signed = Int53.fromString(str);\n        return new Uint53(signed.toNumber());\n    }\n    toNumber() {\n        return this.data.toNumber();\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Uint53 = Uint53;\nclass Uint64 {\n    constructor(data) {\n        if (data.isNeg()) {\n            throw new Error(\"Input is negative\");\n        }\n        if (data.gt(uint64MaxValue)) {\n            throw new Error(\"Input exceeds uint64 range\");\n        }\n        this.data = data;\n    }\n    static fromBytesBigEndian(bytes) {\n        if (bytes.length !== 8) {\n            throw new Error(\"Invalid input length. Expected 8 bytes.\");\n        }\n        // tslint:disable-next-line:prefer-for-of\n        for (let i = 0; i < bytes.length; ++i) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n                throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n            }\n        }\n        // tslint:disable-next-line:readonly-array\n        const asArray = [];\n        // tslint:disable-next-line:prefer-for-of\n        for (let i = 0; i < bytes.length; ++i) {\n            asArray.push(bytes[i]);\n        }\n        return new Uint64(new bn_js_1.default([...asArray]));\n    }\n    static fromString(str) {\n        if (!str.match(/^[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Uint64(new bn_js_1.default(str, 10, \"be\"));\n    }\n    static fromNumber(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        let bigint;\n        try {\n            bigint = new bn_js_1.default(input);\n        }\n        catch (_a) {\n            throw new Error(\"Input is not a safe integer\");\n        }\n        return new Uint64(bigint);\n    }\n    toBytesBigEndian() {\n        return Uint8Array.from(this.data.toArray(\"be\", 8));\n    }\n    toBytesLittleEndian() {\n        return Uint8Array.from(this.data.toArray(\"le\", 8));\n    }\n    toString() {\n        return this.data.toString(10);\n    }\n    toNumber() {\n        return this.data.toNumber();\n    }\n}\nexports.Uint64 = Uint64;\n//# sourceMappingURL=integers.js.map"]},"metadata":{},"sourceType":"script"}