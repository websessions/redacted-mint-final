{"ast":null,"code":"\"use strict\"; // Copyright (C) 2017 Tony Arcieri\n// MIT License. See LICENSE file for details.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst block_1 = require(\"../../internals/block\");\n/**\n * WebCrypto-based implementation of the AES block cipher.\n *\n * This implementation (ab)uses AES-CBC mode to implement AES-ECB. This is\n * likely to be rather slow, as it requires an async call per block, and\n * discards half the buffer.\n *\n * In theory it should be constant time due to the use of WebCrypto (provided\n * the browser's implementation is constant time), but it could probably benefit\n * from some clever optimization work, or improvements to the WebCrypto API.\n *\n * Some WebCrypto implementations (e.g. node-webcrypto-ossl) support ECB mode\n * natively, so we could take advantage of that to potentially encrypt multiple\n * blocks in a single invocation.\n *\n * Key size: 16 or 32 bytes, block size: 16 bytes.\n */\n\n\nclass WebCryptoAes {\n  constructor(_crypto, _key) {\n    this._crypto = _crypto;\n    this._key = _key; // An initialization vector of all zeros, exposing the raw AES function\n\n    this._iv = new block_1.default();\n    this._emptyPromise = Promise.resolve(this);\n  }\n  /**\n   * Create a new WebCryptoAes instance\n   *\n   * @param {Crypto} crypto - the Web Cryptography provider\n   * @param {Uint8Array} keyData - the AES secret key\n   * @returns {Promise<WebCryptoAes}\n   */\n\n\n  static importKey(crypto, keyData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Only AES-128 and AES-256 supported. AES-192 is not.\n      if (keyData.length !== 16 && keyData.length !== 32) {\n        throw new Error(`Miscreant: invalid key length: ${keyData.length} (expected 16 or 32 bytes)`);\n      }\n\n      const key = yield crypto.subtle.importKey(\"raw\", keyData, \"AES-CBC\", false, [\"encrypt\"]);\n      return new WebCryptoAes(crypto, key);\n    });\n  }\n  /**\n   * Cleans expanded keys from memory, setting them to zeros.\n   */\n\n\n  clear() {\n    // TODO: perhaps we should clear something, but what, and how?\n    return this;\n  }\n  /**\n   * Encrypt a single AES block. While ordinarily this might let us see penguins, we're using it safely\n   *\n   * @param {Block} block - block to be encrypted in-place\n   * @returns {Promise<this>}\n   */\n\n\n  encryptBlock(block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const params = {\n        name: \"AES-CBC\",\n        iv: this._iv.data\n      };\n      const ctBlock = yield this._crypto.subtle.encrypt(params, this._key, block.data); // TODO: a more efficient way to do in-place encryption?\n\n      block.data.set(new Uint8Array(ctBlock, 0, block_1.default.SIZE));\n      return this._emptyPromise;\n    });\n  }\n\n}\n\nexports.default = WebCryptoAes;","map":{"version":3,"sources":["/Users/aidansalzmann/button-minter/6_wallets/reactjs_keplr/secret-dapp/node_modules/miscreant/release/providers/webcrypto/aes.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","block_1","require","WebCryptoAes","constructor","_crypto","_key","_iv","default","_emptyPromise","importKey","crypto","keyData","length","Error","key","subtle","clear","encryptBlock","block","params","name","iv","data","ctBlock","encrypt","set","Uint8Array","SIZE"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright (C) 2017 Tony Arcieri\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst block_1 = require(\"../../internals/block\");\n/**\n * WebCrypto-based implementation of the AES block cipher.\n *\n * This implementation (ab)uses AES-CBC mode to implement AES-ECB. This is\n * likely to be rather slow, as it requires an async call per block, and\n * discards half the buffer.\n *\n * In theory it should be constant time due to the use of WebCrypto (provided\n * the browser's implementation is constant time), but it could probably benefit\n * from some clever optimization work, or improvements to the WebCrypto API.\n *\n * Some WebCrypto implementations (e.g. node-webcrypto-ossl) support ECB mode\n * natively, so we could take advantage of that to potentially encrypt multiple\n * blocks in a single invocation.\n *\n * Key size: 16 or 32 bytes, block size: 16 bytes.\n */\nclass WebCryptoAes {\n    constructor(_crypto, _key) {\n        this._crypto = _crypto;\n        this._key = _key;\n        // An initialization vector of all zeros, exposing the raw AES function\n        this._iv = new block_1.default();\n        this._emptyPromise = Promise.resolve(this);\n    }\n    /**\n     * Create a new WebCryptoAes instance\n     *\n     * @param {Crypto} crypto - the Web Cryptography provider\n     * @param {Uint8Array} keyData - the AES secret key\n     * @returns {Promise<WebCryptoAes}\n     */\n    static importKey(crypto, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Only AES-128 and AES-256 supported. AES-192 is not.\n            if (keyData.length !== 16 && keyData.length !== 32) {\n                throw new Error(`Miscreant: invalid key length: ${keyData.length} (expected 16 or 32 bytes)`);\n            }\n            const key = yield crypto.subtle.importKey(\"raw\", keyData, \"AES-CBC\", false, [\"encrypt\"]);\n            return new WebCryptoAes(crypto, key);\n        });\n    }\n    /**\n     * Cleans expanded keys from memory, setting them to zeros.\n     */\n    clear() {\n        // TODO: perhaps we should clear something, but what, and how?\n        return this;\n    }\n    /**\n     * Encrypt a single AES block. While ordinarily this might let us see penguins, we're using it safely\n     *\n     * @param {Block} block - block to be encrypted in-place\n     * @returns {Promise<this>}\n     */\n    encryptBlock(block) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const params = { name: \"AES-CBC\", iv: this._iv.data };\n            const ctBlock = yield this._crypto.subtle.encrypt(params, this._key, block.data);\n            // TODO: a more efficient way to do in-place encryption?\n            block.data.set(new Uint8Array(ctBlock, 0, block_1.default.SIZE));\n            return this._emptyPromise;\n        });\n    }\n}\nexports.default = WebCryptoAes;\n"]},"metadata":{},"sourceType":"script"}