{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst encoding_1 = require(\"@iov/encoding\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst elliptic_1 = __importDefault(require(\"elliptic\"));\n\nconst secp256k1signature_1 = require(\"./secp256k1signature\");\n\nconst secp256k1 = new elliptic_1.default.ec(\"secp256k1\");\nconst secp256k1N = new bn_js_1.default(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", \"hex\");\n\nclass Secp256k1 {\n  static async makeKeypair(privkey) {\n    if (privkey.length !== 32) {\n      // is this check missing in secp256k1.validatePrivateKey?\n      // https://github.com/bitjson/bitcoin-ts/issues/4\n      throw new Error(\"input data is not a valid secp256k1 private key\");\n    }\n\n    const keypair = secp256k1.keyFromPrivate(privkey);\n\n    if (keypair.validate().result !== true) {\n      throw new Error(\"input data is not a valid secp256k1 private key\");\n    } // range test that is not part of the elliptic implementation\n\n\n    const privkeyAsBigInteger = new bn_js_1.default(privkey);\n\n    if (privkeyAsBigInteger.gte(secp256k1N)) {\n      // not strictly smaller than N\n      throw new Error(\"input data is not a valid secp256k1 private key\");\n    }\n\n    const out = {\n      privkey: encoding_1.Encoding.fromHex(keypair.getPrivate(\"hex\")),\n      // encodes uncompressed as\n      // - 1-byte prefix \"04\"\n      // - 32-byte x coordinate\n      // - 32-byte y coordinate\n      pubkey: encoding_1.Encoding.fromHex(keypair.getPublic().encode(\"hex\"))\n    };\n    return out;\n  } // Creates a signature that is\n  // - deterministic (RFC 6979)\n  // - lowS signature\n  // - DER encoded\n\n\n  static async createSignature(messageHash, privkey) {\n    if (messageHash.length === 0) {\n      throw new Error(\"Message hash must not be empty\");\n    }\n\n    if (messageHash.length > 32) {\n      throw new Error(\"Message hash length must not exceed 32 bytes\");\n    }\n\n    const keypair = secp256k1.keyFromPrivate(privkey); // the `canonical` option ensures creation of lowS signature representations\n\n    const signature = keypair.sign(messageHash, {\n      canonical: true\n    });\n    return new secp256k1signature_1.ExtendedSecp256k1Signature(Uint8Array.from(signature.r.toArray()), Uint8Array.from(signature.s.toArray()), signature.recoveryParam);\n  }\n\n  static async verifySignature(signature, messageHash, pubkey) {\n    if (messageHash.length === 0) {\n      throw new Error(\"Message hash must not be empty\");\n    }\n\n    if (messageHash.length > 32) {\n      throw new Error(\"Message hash length must not exceed 32 bytes\");\n    }\n\n    const keypair = secp256k1.keyFromPublic(pubkey); // From https://github.com/indutny/elliptic:\n    //\n    //     Sign the message's hash (input must be an array, or a hex-string)\n    //\n    //     Signature MUST be either:\n    //     1) DER-encoded signature as hex-string; or\n    //     2) DER-encoded signature as buffer; or\n    //     3) object with two hex-string properties (r and s); or\n    //     4) object with two buffer properties (r and s)\n    //\n    // Uint8Array is not a Buffer, but elliptic seems to be happy with the interface\n    // common to both types. Uint8Array is not an array of ints but the interface is\n    // similar\n\n    try {\n      return keypair.verify(messageHash, signature.toDer());\n    } catch (error) {\n      return false;\n    }\n  }\n\n  static recoverPubkey(signature, messageHash) {\n    const signatureForElliptic = {\n      r: encoding_1.Encoding.toHex(signature.r()),\n      s: encoding_1.Encoding.toHex(signature.s())\n    };\n    const point = secp256k1.recoverPubKey(messageHash, signatureForElliptic, signature.recovery);\n    const keypair = secp256k1.keyFromPublic(point);\n    return encoding_1.Encoding.fromHex(keypair.getPublic(false, \"hex\"));\n  }\n\n  static compressPubkey(pubkey) {\n    switch (pubkey.length) {\n      case 33:\n        return pubkey;\n\n      case 65:\n        return Uint8Array.from(secp256k1.keyFromPublic(pubkey).pub.encodeCompressed());\n\n      default:\n        throw new Error(\"Invalid pubkey length\");\n    }\n  }\n\n  static trimRecoveryByte(signature) {\n    switch (signature.length) {\n      case 64:\n        return signature;\n\n      case 65:\n        return signature.slice(0, 64);\n\n      default:\n        throw new Error(\"Invalid signature length\");\n    }\n  }\n\n}\n\nexports.Secp256k1 = Secp256k1;","map":{"version":3,"sources":["../src/secp256k1.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst encoding_1 = require(\"@iov/encoding\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst elliptic_1 = __importDefault(require(\"elliptic\"));\nconst secp256k1signature_1 = require(\"./secp256k1signature\");\nconst secp256k1 = new elliptic_1.default.ec(\"secp256k1\");\nconst secp256k1N = new bn_js_1.default(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", \"hex\");\nclass Secp256k1 {\n    static async makeKeypair(privkey) {\n        if (privkey.length !== 32) {\n            // is this check missing in secp256k1.validatePrivateKey?\n            // https://github.com/bitjson/bitcoin-ts/issues/4\n            throw new Error(\"input data is not a valid secp256k1 private key\");\n        }\n        const keypair = secp256k1.keyFromPrivate(privkey);\n        if (keypair.validate().result !== true) {\n            throw new Error(\"input data is not a valid secp256k1 private key\");\n        }\n        // range test that is not part of the elliptic implementation\n        const privkeyAsBigInteger = new bn_js_1.default(privkey);\n        if (privkeyAsBigInteger.gte(secp256k1N)) {\n            // not strictly smaller than N\n            throw new Error(\"input data is not a valid secp256k1 private key\");\n        }\n        const out = {\n            privkey: encoding_1.Encoding.fromHex(keypair.getPrivate(\"hex\")),\n            // encodes uncompressed as\n            // - 1-byte prefix \"04\"\n            // - 32-byte x coordinate\n            // - 32-byte y coordinate\n            pubkey: encoding_1.Encoding.fromHex(keypair.getPublic().encode(\"hex\")),\n        };\n        return out;\n    }\n    // Creates a signature that is\n    // - deterministic (RFC 6979)\n    // - lowS signature\n    // - DER encoded\n    static async createSignature(messageHash, privkey) {\n        if (messageHash.length === 0) {\n            throw new Error(\"Message hash must not be empty\");\n        }\n        if (messageHash.length > 32) {\n            throw new Error(\"Message hash length must not exceed 32 bytes\");\n        }\n        const keypair = secp256k1.keyFromPrivate(privkey);\n        // the `canonical` option ensures creation of lowS signature representations\n        const signature = keypair.sign(messageHash, { canonical: true });\n        return new secp256k1signature_1.ExtendedSecp256k1Signature(Uint8Array.from(signature.r.toArray()), Uint8Array.from(signature.s.toArray()), signature.recoveryParam);\n    }\n    static async verifySignature(signature, messageHash, pubkey) {\n        if (messageHash.length === 0) {\n            throw new Error(\"Message hash must not be empty\");\n        }\n        if (messageHash.length > 32) {\n            throw new Error(\"Message hash length must not exceed 32 bytes\");\n        }\n        const keypair = secp256k1.keyFromPublic(pubkey);\n        // From https://github.com/indutny/elliptic:\n        //\n        //     Sign the message's hash (input must be an array, or a hex-string)\n        //\n        //     Signature MUST be either:\n        //     1) DER-encoded signature as hex-string; or\n        //     2) DER-encoded signature as buffer; or\n        //     3) object with two hex-string properties (r and s); or\n        //     4) object with two buffer properties (r and s)\n        //\n        // Uint8Array is not a Buffer, but elliptic seems to be happy with the interface\n        // common to both types. Uint8Array is not an array of ints but the interface is\n        // similar\n        try {\n            return keypair.verify(messageHash, signature.toDer());\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    static recoverPubkey(signature, messageHash) {\n        const signatureForElliptic = { r: encoding_1.Encoding.toHex(signature.r()), s: encoding_1.Encoding.toHex(signature.s()) };\n        const point = secp256k1.recoverPubKey(messageHash, signatureForElliptic, signature.recovery);\n        const keypair = secp256k1.keyFromPublic(point);\n        return encoding_1.Encoding.fromHex(keypair.getPublic(false, \"hex\"));\n    }\n    static compressPubkey(pubkey) {\n        switch (pubkey.length) {\n            case 33:\n                return pubkey;\n            case 65:\n                return Uint8Array.from(secp256k1.keyFromPublic(pubkey).pub.encodeCompressed());\n            default:\n                throw new Error(\"Invalid pubkey length\");\n        }\n    }\n    static trimRecoveryByte(signature) {\n        switch (signature.length) {\n            case 64:\n                return signature;\n            case 65:\n                return signature.slice(0, 64);\n            default:\n                throw new Error(\"Invalid signature length\");\n        }\n    }\n}\nexports.Secp256k1 = Secp256k1;\n//# sourceMappingURL=secp256k1.js.map"]},"metadata":{},"sourceType":"script"}