{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto_1 = require(\"@iov/crypto\");\n\nvar encoding_1 = require(\"@iov/encoding\");\n\nvar logs_1 = require(\"./logs\");\n\nvar pubkey_1 = require(\"./pubkey\");\n\nvar restclient_1 = require(\"./restclient\");\n\nfunction isSearchByIdQuery(query) {\n  return query.id !== undefined;\n}\n\nfunction isSearchByHeightQuery(query) {\n  return query.height !== undefined;\n}\n\nfunction isSearchBySentFromOrToQuery(query) {\n  return query.sentFromOrTo !== undefined;\n}\n\nfunction isSearchByTagsQuery(query) {\n  return query.tags !== undefined;\n}\n\nvar CosmWasmClient = /*#__PURE__*/function () {\n  /**\n   * Creates a new client to interact with a CosmWasm blockchain.\n   *\n   * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n   * for the lifetime of your application. When switching backends, a new instance must be created.\n   *\n   * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n   * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n   */\n  function CosmWasmClient(apiUrl, seed) {\n    var broadcastMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : restclient_1.BroadcastMode.Block;\n\n    _classCallCheck(this, CosmWasmClient);\n\n    this.codesCache = new Map();\n    this.restClient = new restclient_1.RestClient(apiUrl, broadcastMode, seed);\n  }\n\n  _createClass(CosmWasmClient, [{\n    key: \"getChainId\",\n    value: function () {\n      var _getChainId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var response, chainId;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.chainId) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.restClient.nodeInfo();\n\n              case 3:\n                response = _context.sent;\n                chainId = response.node_info.network;\n\n                if (chainId) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Chain ID must not be empty\");\n\n              case 7:\n                this.chainId = chainId;\n\n              case 8:\n                return _context.abrupt(\"return\", this.chainId);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getChainId() {\n        return _getChainId.apply(this, arguments);\n      }\n\n      return getChainId;\n    }()\n  }, {\n    key: \"getHeight\",\n    value: function () {\n      var _getHeight = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _yield$this$restClien, height, latest;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.anyValidAddress) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.restClient.authAccounts(this.anyValidAddress);\n\n              case 3:\n                _yield$this$restClien = _context2.sent;\n                height = _yield$this$restClien.height;\n                return _context2.abrupt(\"return\", parseInt(height, 10));\n\n              case 8:\n                _context2.next = 10;\n                return this.restClient.blocksLatest();\n\n              case 10:\n                latest = _context2.sent;\n                return _context2.abrupt(\"return\", parseInt(latest.block.header.height, 10));\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getHeight() {\n        return _getHeight.apply(this, arguments);\n      }\n\n      return getHeight;\n    }()\n    /**\n     * Returns a 32 byte upper-case hex transaction hash (typically used as the transaction ID)\n     */\n\n  }, {\n    key: \"getIdentifier\",\n    value: function () {\n      var _getIdentifier = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(tx) {\n        var bytes, hash;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.restClient.encodeTx(tx);\n\n              case 2:\n                bytes = _context3.sent;\n                hash = new crypto_1.Sha256(bytes).digest();\n                return _context3.abrupt(\"return\", encoding_1.Encoding.toHex(hash).toUpperCase());\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getIdentifier(_x) {\n        return _getIdentifier.apply(this, arguments);\n      }\n\n      return getIdentifier;\n    }()\n    /**\n     * Returns account number and sequence.\n     *\n     * Throws if the account does not exist on chain.\n     *\n     * @param address returns data for this address. When unset, the client's sender adddress is used.\n     */\n\n  }, {\n    key: \"getNonce\",\n    value: function () {\n      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(address) {\n        var account;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.getAccount(address);\n\n              case 2:\n                account = _context4.sent;\n\n                if (account) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query nonces.\");\n\n              case 5:\n                return _context4.abrupt(\"return\", {\n                  accountNumber: account.accountNumber,\n                  sequence: account.sequence\n                });\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getNonce(_x2) {\n        return _getNonce.apply(this, arguments);\n      }\n\n      return getNonce;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function () {\n      var _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(address) {\n        var account, value;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.restClient.authAccounts(address);\n\n              case 2:\n                account = _context5.sent;\n                value = account.result.value;\n\n                if (!(value.address === \"\")) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", undefined);\n\n              case 8:\n                this.anyValidAddress = value.address;\n                return _context5.abrupt(\"return\", {\n                  address: value.address,\n                  balance: value.coins,\n                  pubkey: value.public_key ? pubkey_1.decodeBech32Pubkey(value.public_key) : undefined,\n                  accountNumber: value.account_number,\n                  sequence: value.sequence\n                });\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getAccount(_x3) {\n        return _getAccount.apply(this, arguments);\n      }\n\n      return getAccount;\n    }()\n    /**\n     * Gets block header and meta\n     *\n     * @param height The height of the block. If undefined, the latest height is used.\n     */\n\n  }, {\n    key: \"getBlock\",\n    value: function () {\n      var _getBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(height) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(height !== undefined)) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                _context6.next = 3;\n                return this.restClient.blocks(height);\n\n              case 3:\n                _context6.t0 = _context6.sent;\n                _context6.next = 9;\n                break;\n\n              case 6:\n                _context6.next = 8;\n                return this.restClient.blocksLatest();\n\n              case 8:\n                _context6.t0 = _context6.sent;\n\n              case 9:\n                response = _context6.t0;\n                return _context6.abrupt(\"return\", {\n                  id: response.block_id.hash,\n                  header: {\n                    version: response.block.header.version,\n                    time: response.block.header.time,\n                    height: parseInt(response.block.header.height, 10),\n                    chainId: response.block.header.chain_id\n                  },\n                  txs: (response.block.data.txs || []).map(function (encoded) {\n                    return encoding_1.Encoding.fromBase64(encoded);\n                  })\n                });\n\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getBlock(_x4) {\n        return _getBlock.apply(this, arguments);\n      }\n\n      return getBlock;\n    }()\n  }, {\n    key: \"searchTx\",\n    value: function () {\n      var _searchTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(query) {\n        var filter,\n            minHeight,\n            maxHeight,\n            withFilters,\n            txs,\n            sentQuery,\n            receivedQuery,\n            sent,\n            received,\n            sentHashes,\n            rawQuery,\n            filtered,\n            _args7 = arguments;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                withFilters = function _withFilters(originalQuery) {\n                  return \"\".concat(originalQuery, \"&tx.minheight=\").concat(minHeight, \"&tx.maxheight=\").concat(maxHeight);\n                };\n\n                filter = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n                minHeight = filter.minHeight || 0;\n                maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n\n                if (!(maxHeight < minHeight)) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", []);\n\n              case 6:\n                if (!isSearchByIdQuery(query)) {\n                  _context7.next = 12;\n                  break;\n                }\n\n                _context7.next = 9;\n                return this.txsQuery(\"tx.hash=\".concat(query.id));\n\n              case 9:\n                txs = _context7.sent;\n                _context7.next = 43;\n                break;\n\n              case 12:\n                if (!isSearchByHeightQuery(query)) {\n                  _context7.next = 22;\n                  break;\n                }\n\n                if (!(query.height < minHeight || query.height > maxHeight)) {\n                  _context7.next = 17;\n                  break;\n                }\n\n                txs = [];\n                _context7.next = 20;\n                break;\n\n              case 17:\n                _context7.next = 19;\n                return this.txsQuery(\"tx.height=\".concat(query.height));\n\n              case 19:\n                txs = _context7.sent;\n\n              case 20:\n                _context7.next = 43;\n                break;\n\n              case 22:\n                if (!isSearchBySentFromOrToQuery(query)) {\n                  _context7.next = 35;\n                  break;\n                }\n\n                // We cannot get both in one request (see https://github.com/cosmos/gaia/issues/75)\n                sentQuery = withFilters(\"message.module=bank&message.sender=\".concat(query.sentFromOrTo));\n                receivedQuery = withFilters(\"message.module=bank&transfer.recipient=\".concat(query.sentFromOrTo));\n                _context7.next = 27;\n                return this.txsQuery(sentQuery);\n\n              case 27:\n                sent = _context7.sent;\n                _context7.next = 30;\n                return this.txsQuery(receivedQuery);\n\n              case 30:\n                received = _context7.sent;\n                sentHashes = sent.map(function (t) {\n                  return t.hash;\n                });\n                txs = [].concat(_toConsumableArray(sent), _toConsumableArray(received.filter(function (t) {\n                  return !sentHashes.includes(t.hash);\n                })));\n                _context7.next = 43;\n                break;\n\n              case 35:\n                if (!isSearchByTagsQuery(query)) {\n                  _context7.next = 42;\n                  break;\n                }\n\n                rawQuery = withFilters(query.tags.map(function (t) {\n                  return \"\".concat(t.key, \"=\").concat(t.value);\n                }).join(\"&\"));\n                _context7.next = 39;\n                return this.txsQuery(rawQuery);\n\n              case 39:\n                txs = _context7.sent;\n                _context7.next = 43;\n                break;\n\n              case 42:\n                throw new Error(\"Unknown query type\");\n\n              case 43:\n                // backend sometimes messes up with min/max height filtering\n                filtered = txs.filter(function (tx) {\n                  return tx.height >= minHeight && tx.height <= maxHeight;\n                });\n                return _context7.abrupt(\"return\", filtered);\n\n              case 45:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function searchTx(_x5) {\n        return _searchTx.apply(this, arguments);\n      }\n\n      return searchTx;\n    }()\n  }, {\n    key: \"postTx\",\n    value: function () {\n      var _postTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(tx) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.restClient.postTx(tx);\n\n              case 2:\n                result = _context8.sent;\n\n                if (result.txhash.match(/^([0-9A-F][0-9A-F])+$/)) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Received ill-formatted txhash. Must be non-empty upper-case hex\");\n\n              case 5:\n                if (!result.code) {\n                  _context8.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Error when posting tx \".concat(result.txhash, \". Code: \").concat(result.code, \"; Raw log: \").concat(result.raw_log));\n\n              case 7:\n                return _context8.abrupt(\"return\", {\n                  logs: result.logs ? logs_1.parseLogs(result.logs) : [],\n                  rawLog: result.raw_log || \"\",\n                  transactionHash: result.txhash,\n                  data: result.data || \"\"\n                });\n\n              case 8:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function postTx(_x6) {\n        return _postTx.apply(this, arguments);\n      }\n\n      return postTx;\n    }()\n  }, {\n    key: \"getCodes\",\n    value: function () {\n      var _getCodes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _this = this;\n\n        var result;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.restClient.listCodeInfo();\n\n              case 2:\n                result = _context9.sent;\n                return _context9.abrupt(\"return\", result.map(function (entry) {\n                  _this.anyValidAddress = entry.creator;\n                  return {\n                    id: entry.id,\n                    creator: entry.creator,\n                    checksum: encoding_1.Encoding.toHex(encoding_1.Encoding.fromHex(entry.data_hash)),\n                    source: entry.source || undefined,\n                    builder: entry.builder || undefined\n                  };\n                }));\n\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getCodes() {\n        return _getCodes.apply(this, arguments);\n      }\n\n      return getCodes;\n    }()\n  }, {\n    key: \"getCodeDetails\",\n    value: function () {\n      var _getCodeDetails = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(codeId) {\n        var cached, getCodeResult, codeDetails;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                cached = this.codesCache.get(codeId);\n\n                if (!cached) {\n                  _context10.next = 3;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", cached);\n\n              case 3:\n                _context10.next = 5;\n                return this.restClient.getCode(codeId);\n\n              case 5:\n                getCodeResult = _context10.sent;\n                codeDetails = {\n                  id: getCodeResult.id,\n                  creator: getCodeResult.creator,\n                  checksum: encoding_1.Encoding.toHex(encoding_1.Encoding.fromHex(getCodeResult.data_hash)),\n                  source: getCodeResult.source || undefined,\n                  builder: getCodeResult.builder || undefined,\n                  data: encoding_1.Encoding.fromBase64(getCodeResult.data)\n                };\n                this.codesCache.set(codeId, codeDetails);\n                return _context10.abrupt(\"return\", codeDetails);\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getCodeDetails(_x7) {\n        return _getCodeDetails.apply(this, arguments);\n      }\n\n      return getCodeDetails;\n    }()\n  }, {\n    key: \"getContracts\",\n    value: function () {\n      var _getContracts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(codeId) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.restClient.listContractsByCodeId(codeId);\n\n              case 2:\n                result = _context11.sent;\n                return _context11.abrupt(\"return\", result.map(function (entry) {\n                  return {\n                    address: entry.address,\n                    codeId: entry.code_id,\n                    creator: entry.creator,\n                    label: entry.label\n                  };\n                }));\n\n              case 4:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getContracts(_x8) {\n        return _getContracts.apply(this, arguments);\n      }\n\n      return getContracts;\n    }()\n    /**\n     * Throws an error if no contract was found at the address\n     */\n\n  }, {\n    key: \"getContract\",\n    value: function () {\n      var _getContract = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(address) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.restClient.getContractInfo(address);\n\n              case 2:\n                result = _context12.sent;\n\n                if (result) {\n                  _context12.next = 5;\n                  break;\n                }\n\n                throw new Error(\"No contract found at address \\\"\".concat(address, \"\\\"\"));\n\n              case 5:\n                return _context12.abrupt(\"return\", {\n                  address: result.address,\n                  codeId: result.code_id,\n                  creator: result.creator,\n                  label: result.label,\n                  initMsg: result.init_msg\n                });\n\n              case 6:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getContract(_x9) {\n        return _getContract.apply(this, arguments);\n      }\n\n      return getContract;\n    }()\n    /**\n     * Makes a smart query on the contract, returns the parsed JSON document.\n     *\n     * Promise is rejected when contract does not exist.\n     * Promise is rejected for invalid query format.\n     * Promise is rejected for invalid response format.\n     *\n     * Note: addedParams allows for query string additions such as \"&height=1234567\"\n     */\n\n  }, {\n    key: \"queryContractSmart\",\n    value: function () {\n      var _queryContractSmart = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(contractAddress, queryMsg, addedParams, contractCodeHash) {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n                _context13.next = 3;\n                return this.restClient.queryContractSmart(contractAddress, queryMsg, addedParams, contractCodeHash);\n\n              case 3:\n                return _context13.abrupt(\"return\", _context13.sent);\n\n              case 6:\n                _context13.prev = 6;\n                _context13.t0 = _context13[\"catch\"](0);\n\n                if (!(_context13.t0 instanceof Error)) {\n                  _context13.next = 16;\n                  break;\n                }\n\n                if (!_context13.t0.message.startsWith(\"not found: contract\")) {\n                  _context13.next = 13;\n                  break;\n                }\n\n                throw new Error(\"No contract found at address \\\"\".concat(contractAddress, \"\\\"\"));\n\n              case 13:\n                throw _context13.t0;\n\n              case 14:\n                _context13.next = 17;\n                break;\n\n              case 16:\n                throw _context13.t0;\n\n              case 17:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[0, 6]]);\n      }));\n\n      function queryContractSmart(_x10, _x11, _x12, _x13) {\n        return _queryContractSmart.apply(this, arguments);\n      }\n\n      return queryContractSmart;\n    }()\n  }, {\n    key: \"txsQuery\",\n    value: function () {\n      var _txsQuery = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(query) {\n        var limit, result, pages;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                // TODO: we need proper pagination support\n                limit = 100;\n                _context14.next = 3;\n                return this.restClient.txsQuery(\"\".concat(query, \"&limit=\").concat(limit));\n\n              case 3:\n                result = _context14.sent;\n                pages = parseInt(result.page_total, 10);\n\n                if (!(pages > 1)) {\n                  _context14.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Found more results on the backend than we can process currently. Results: \".concat(result.total_count, \", supported: \").concat(limit));\n\n              case 7:\n                return _context14.abrupt(\"return\", result.txs.map(function (restItem) {\n                  return {\n                    height: parseInt(restItem.height, 10),\n                    hash: restItem.txhash,\n                    code: restItem.code || 0,\n                    rawLog: restItem.raw_log,\n                    logs: logs_1.parseLogs(restItem.logs || []),\n                    tx: restItem.tx,\n                    timestamp: restItem.timestamp\n                  };\n                }));\n\n              case 8:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function txsQuery(_x14) {\n        return _txsQuery.apply(this, arguments);\n      }\n\n      return txsQuery;\n    }()\n  }, {\n    key: \"getCodeHashByCodeId\",\n    value: function getCodeHashByCodeId(id) {\n      return this.restClient.getCodeHashByCodeId(id);\n    }\n  }, {\n    key: \"getCodeHashByContractAddr\",\n    value: function getCodeHashByContractAddr(addr) {\n      return this.restClient.getCodeHashByContractAddr(addr);\n    }\n  }, {\n    key: \"getNonceByTxId\",\n    value: function () {\n      var _getNonceByTxId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(txhash) {\n        var txResponse, msgs, result, _iterator, _step, msg, nonce;\n\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.restClient.txById(txhash, false);\n\n              case 2:\n                txResponse = _context15.sent;\n                msgs = txResponse.tx.value.msg;\n                result = [];\n                _iterator = _createForOfIteratorHelper(msgs);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    msg = _step.value;\n                    nonce = void 0;\n\n                    if (msg.type === \"wasm/MsgExecuteContract\") {\n                      nonce = encoding_1.Encoding.fromBase64(msg.value.msg).slice(0, 32);\n                    } else if (msg.type === \"wasm/MsgInstantiateContract\") {\n                      nonce = encoding_1.Encoding.fromBase64(msg.value.init_msg).slice(0, 32);\n                    } else {\n                      nonce = null;\n                    }\n\n                    result.push(nonce);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                return _context15.abrupt(\"return\", result);\n\n              case 8:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function getNonceByTxId(_x15) {\n        return _getNonceByTxId.apply(this, arguments);\n      }\n\n      return getNonceByTxId;\n    }()\n  }]);\n\n  return CosmWasmClient;\n}();\n\nexports.CosmWasmClient = CosmWasmClient;","map":{"version":3,"sources":["../src/cosmwasmclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"@iov/crypto\");\nconst encoding_1 = require(\"@iov/encoding\");\nconst logs_1 = require(\"./logs\");\nconst pubkey_1 = require(\"./pubkey\");\nconst restclient_1 = require(\"./restclient\");\nfunction isSearchByIdQuery(query) {\n    return query.id !== undefined;\n}\nfunction isSearchByHeightQuery(query) {\n    return query.height !== undefined;\n}\nfunction isSearchBySentFromOrToQuery(query) {\n    return query.sentFromOrTo !== undefined;\n}\nfunction isSearchByTagsQuery(query) {\n    return query.tags !== undefined;\n}\nclass CosmWasmClient {\n    /**\n     * Creates a new client to interact with a CosmWasm blockchain.\n     *\n     * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n     * for the lifetime of your application. When switching backends, a new instance must be created.\n     *\n     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n     * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns\n     */\n    constructor(apiUrl, seed, broadcastMode = restclient_1.BroadcastMode.Block) {\n        this.codesCache = new Map();\n        this.restClient = new restclient_1.RestClient(apiUrl, broadcastMode, seed);\n    }\n    async getChainId() {\n        if (!this.chainId) {\n            const response = await this.restClient.nodeInfo();\n            const chainId = response.node_info.network;\n            if (!chainId)\n                throw new Error(\"Chain ID must not be empty\");\n            this.chainId = chainId;\n        }\n        return this.chainId;\n    }\n    async getHeight() {\n        if (this.anyValidAddress) {\n            const { height } = await this.restClient.authAccounts(this.anyValidAddress);\n            return parseInt(height, 10);\n        }\n        else {\n            // Note: this gets inefficient when blocks contain a lot of transactions since it\n            // requires downloading and deserializing all transactions in the block.\n            const latest = await this.restClient.blocksLatest();\n            return parseInt(latest.block.header.height, 10);\n        }\n    }\n    /**\n     * Returns a 32 byte upper-case hex transaction hash (typically used as the transaction ID)\n     */\n    async getIdentifier(tx) {\n        // We consult the REST API because we don't have a local amino encoder\n        const bytes = await this.restClient.encodeTx(tx);\n        const hash = new crypto_1.Sha256(bytes).digest();\n        return encoding_1.Encoding.toHex(hash).toUpperCase();\n    }\n    /**\n     * Returns account number and sequence.\n     *\n     * Throws if the account does not exist on chain.\n     *\n     * @param address returns data for this address. When unset, the client's sender adddress is used.\n     */\n    async getNonce(address) {\n        const account = await this.getAccount(address);\n        if (!account) {\n            throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query nonces.\");\n        }\n        return {\n            accountNumber: account.accountNumber,\n            sequence: account.sequence,\n        };\n    }\n    async getAccount(address) {\n        const account = await this.restClient.authAccounts(address);\n        const value = account.result.value;\n        if (value.address === \"\") {\n            return undefined;\n        }\n        else {\n            this.anyValidAddress = value.address;\n            return {\n                address: value.address,\n                balance: value.coins,\n                pubkey: value.public_key ? pubkey_1.decodeBech32Pubkey(value.public_key) : undefined,\n                accountNumber: value.account_number,\n                sequence: value.sequence,\n            };\n        }\n    }\n    /**\n     * Gets block header and meta\n     *\n     * @param height The height of the block. If undefined, the latest height is used.\n     */\n    async getBlock(height) {\n        const response = height !== undefined ? await this.restClient.blocks(height) : await this.restClient.blocksLatest();\n        return {\n            id: response.block_id.hash,\n            header: {\n                version: response.block.header.version,\n                time: response.block.header.time,\n                height: parseInt(response.block.header.height, 10),\n                chainId: response.block.header.chain_id,\n            },\n            txs: (response.block.data.txs || []).map((encoded) => encoding_1.Encoding.fromBase64(encoded)),\n        };\n    }\n    async searchTx(query, filter = {}) {\n        const minHeight = filter.minHeight || 0;\n        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n        if (maxHeight < minHeight)\n            return []; // optional optimization\n        function withFilters(originalQuery) {\n            return `${originalQuery}&tx.minheight=${minHeight}&tx.maxheight=${maxHeight}`;\n        }\n        let txs;\n        if (isSearchByIdQuery(query)) {\n            txs = await this.txsQuery(`tx.hash=${query.id}`);\n        }\n        else if (isSearchByHeightQuery(query)) {\n            // optional optimization to avoid network request\n            if (query.height < minHeight || query.height > maxHeight) {\n                txs = [];\n            }\n            else {\n                txs = await this.txsQuery(`tx.height=${query.height}`);\n            }\n        }\n        else if (isSearchBySentFromOrToQuery(query)) {\n            // We cannot get both in one request (see https://github.com/cosmos/gaia/issues/75)\n            const sentQuery = withFilters(`message.module=bank&message.sender=${query.sentFromOrTo}`);\n            const receivedQuery = withFilters(`message.module=bank&transfer.recipient=${query.sentFromOrTo}`);\n            const sent = await this.txsQuery(sentQuery);\n            const received = await this.txsQuery(receivedQuery);\n            const sentHashes = sent.map((t) => t.hash);\n            txs = [...sent, ...received.filter((t) => !sentHashes.includes(t.hash))];\n        }\n        else if (isSearchByTagsQuery(query)) {\n            const rawQuery = withFilters(query.tags.map((t) => `${t.key}=${t.value}`).join(\"&\"));\n            txs = await this.txsQuery(rawQuery);\n        }\n        else {\n            throw new Error(\"Unknown query type\");\n        }\n        // backend sometimes messes up with min/max height filtering\n        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);\n        return filtered;\n    }\n    async postTx(tx) {\n        const result = await this.restClient.postTx(tx);\n        if (!result.txhash.match(/^([0-9A-F][0-9A-F])+$/)) {\n            throw new Error(\"Received ill-formatted txhash. Must be non-empty upper-case hex\");\n        }\n        if (result.code) {\n            throw new Error(`Error when posting tx ${result.txhash}. Code: ${result.code}; Raw log: ${result.raw_log}`);\n        }\n        return {\n            logs: result.logs ? logs_1.parseLogs(result.logs) : [],\n            rawLog: result.raw_log || \"\",\n            transactionHash: result.txhash,\n            data: result.data || \"\",\n        };\n    }\n    async getCodes() {\n        const result = await this.restClient.listCodeInfo();\n        return result.map((entry) => {\n            this.anyValidAddress = entry.creator;\n            return {\n                id: entry.id,\n                creator: entry.creator,\n                checksum: encoding_1.Encoding.toHex(encoding_1.Encoding.fromHex(entry.data_hash)),\n                source: entry.source || undefined,\n                builder: entry.builder || undefined,\n            };\n        });\n    }\n    async getCodeDetails(codeId) {\n        const cached = this.codesCache.get(codeId);\n        if (cached)\n            return cached;\n        const getCodeResult = await this.restClient.getCode(codeId);\n        const codeDetails = {\n            id: getCodeResult.id,\n            creator: getCodeResult.creator,\n            checksum: encoding_1.Encoding.toHex(encoding_1.Encoding.fromHex(getCodeResult.data_hash)),\n            source: getCodeResult.source || undefined,\n            builder: getCodeResult.builder || undefined,\n            data: encoding_1.Encoding.fromBase64(getCodeResult.data),\n        };\n        this.codesCache.set(codeId, codeDetails);\n        return codeDetails;\n    }\n    async getContracts(codeId) {\n        const result = await this.restClient.listContractsByCodeId(codeId);\n        return result.map((entry) => ({\n            address: entry.address,\n            codeId: entry.code_id,\n            creator: entry.creator,\n            label: entry.label,\n        }));\n    }\n    /**\n     * Throws an error if no contract was found at the address\n     */\n    async getContract(address) {\n        const result = await this.restClient.getContractInfo(address);\n        if (!result)\n            throw new Error(`No contract found at address \"${address}\"`);\n        return {\n            address: result.address,\n            codeId: result.code_id,\n            creator: result.creator,\n            label: result.label,\n            initMsg: result.init_msg,\n        };\n    }\n    /**\n     * Makes a smart query on the contract, returns the parsed JSON document.\n     *\n     * Promise is rejected when contract does not exist.\n     * Promise is rejected for invalid query format.\n     * Promise is rejected for invalid response format.\n     *\n     * Note: addedParams allows for query string additions such as \"&height=1234567\"\n     */\n    async queryContractSmart(contractAddress, queryMsg, addedParams, contractCodeHash) {\n        try {\n            return await this.restClient.queryContractSmart(contractAddress, queryMsg, addedParams, contractCodeHash);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                if (error.message.startsWith(\"not found: contract\")) {\n                    throw new Error(`No contract found at address \"${contractAddress}\"`);\n                }\n                else {\n                    throw error;\n                }\n            }\n            else {\n                throw error;\n            }\n        }\n    }\n    async txsQuery(query) {\n        // TODO: we need proper pagination support\n        const limit = 100;\n        const result = await this.restClient.txsQuery(`${query}&limit=${limit}`);\n        const pages = parseInt(result.page_total, 10);\n        if (pages > 1) {\n            throw new Error(`Found more results on the backend than we can process currently. Results: ${result.total_count}, supported: ${limit}`);\n        }\n        return result.txs.map((restItem) => ({\n            height: parseInt(restItem.height, 10),\n            hash: restItem.txhash,\n            code: restItem.code || 0,\n            rawLog: restItem.raw_log,\n            logs: logs_1.parseLogs(restItem.logs || []),\n            tx: restItem.tx,\n            timestamp: restItem.timestamp,\n        }));\n    }\n    getCodeHashByCodeId(id) {\n        return this.restClient.getCodeHashByCodeId(id);\n    }\n    getCodeHashByContractAddr(addr) {\n        return this.restClient.getCodeHashByContractAddr(addr);\n    }\n    async getNonceByTxId(txhash) {\n        const txResponse = await this.restClient.txById(txhash, false);\n        const msgs = txResponse.tx.value.msg;\n        const result = [];\n        for (const msg of msgs) {\n            let nonce;\n            if (msg.type === \"wasm/MsgExecuteContract\") {\n                nonce = encoding_1.Encoding.fromBase64(msg.value.msg).slice(0, 32);\n            }\n            else if (msg.type === \"wasm/MsgInstantiateContract\") {\n                nonce = encoding_1.Encoding.fromBase64(msg.value.init_msg).slice(0, 32);\n            }\n            else {\n                nonce = null;\n            }\n            result.push(nonce);\n        }\n        return result;\n    }\n}\nexports.CosmWasmClient = CosmWasmClient;\n//# sourceMappingURL=cosmwasmclient.js.map"]},"metadata":{},"sourceType":"script"}