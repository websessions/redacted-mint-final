{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar base64js = __importStar(require(\"base64-js\"));\n\nvar readonly_date_1 = require(\"readonly-date\");\n\nvar Encoding = /*#__PURE__*/function () {\n  function Encoding() {\n    _classCallCheck(this, Encoding);\n  }\n\n  _createClass(Encoding, null, [{\n    key: \"toHex\",\n    value: function toHex(data) {\n      var out = \"\";\n\n      var _iterator = _createForOfIteratorHelper(data),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var byte = _step.value;\n          out += (\"0\" + byte.toString(16)).slice(-2);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return out;\n    }\n  }, {\n    key: \"fromHex\",\n    value: function fromHex(hexstring) {\n      if (hexstring.length % 2 !== 0) {\n        throw new Error(\"hex string length must be a multiple of 2\");\n      } // tslint:disable-next-line:readonly-array\n\n\n      var listOfInts = [];\n\n      for (var i = 0; i < hexstring.length; i += 2) {\n        var hexByteAsString = hexstring.substr(i, 2);\n\n        if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {\n          throw new Error(\"hex string contains invalid characters\");\n        }\n\n        listOfInts.push(parseInt(hexByteAsString, 16));\n      }\n\n      return new Uint8Array(listOfInts);\n    }\n  }, {\n    key: \"toBase64\",\n    value: function toBase64(data) {\n      return base64js.fromByteArray(data);\n    }\n  }, {\n    key: \"fromBase64\",\n    value: function fromBase64(base64String) {\n      if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {\n        throw new Error(\"Invalid base64 string format\");\n      }\n\n      return base64js.toByteArray(base64String);\n    }\n  }, {\n    key: \"toAscii\",\n    value: function toAscii(input) {\n      var toNums = function toNums(str) {\n        return str.split(\"\").map(function (x) {\n          var charCode = x.charCodeAt(0); // 0x00–0x1F control characters\n          // 0x20–0x7E printable characters\n          // 0x7F delete character\n          // 0x80–0xFF out of 7 bit ascii range\n\n          if (charCode < 0x20 || charCode > 0x7e) {\n            throw new Error(\"Cannot encode character that is out of printable ASCII range: \" + charCode);\n          }\n\n          return charCode;\n        });\n      };\n\n      return Uint8Array.from(toNums(input));\n    }\n  }, {\n    key: \"fromAscii\",\n    value: function fromAscii(data) {\n      var fromNums = function fromNums(listOfNumbers) {\n        return listOfNumbers.map(function (x) {\n          // 0x00–0x1F control characters\n          // 0x20–0x7E printable characters\n          // 0x7F delete character\n          // 0x80–0xFF out of 7 bit ascii range\n          if (x < 0x20 || x > 0x7e) {\n            throw new Error(\"Cannot decode character that is out of printable ASCII range: \" + x);\n          }\n\n          return String.fromCharCode(x);\n        });\n      };\n\n      return fromNums(Array.from(data)).join(\"\");\n    }\n  }, {\n    key: \"toUtf8\",\n    value: function toUtf8(str) {\n      // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n      if (typeof TextEncoder !== \"undefined\") {\n        return new TextEncoder().encode(str);\n      } // Use Buffer hack instead of nodejs util.TextEncoder to ensure\n      // webpack does not bundle the util module for browsers.\n\n\n      return new Uint8Array(Buffer.from(str, \"utf8\"));\n    }\n  }, {\n    key: \"fromUtf8\",\n    value: function fromUtf8(data) {\n      // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n      if (typeof TextDecoder !== \"undefined\") {\n        return new TextDecoder(\"utf-8\", {\n          fatal: true\n        }).decode(data);\n      } // Use Buffer hack instead of nodejs util.TextDecoder to ensure\n      // webpack does not bundle the util module for browsers.\n      // Buffer.toString has no fatal option\n\n\n      if (!Encoding.isValidUtf8(data)) {\n        throw new Error(\"Invalid UTF8 data\");\n      }\n\n      return Buffer.from(data).toString(\"utf8\");\n    }\n  }, {\n    key: \"fromRfc3339\",\n    value: function fromRfc3339(str) {\n      var rfc3339Matcher = /^(\\d{4})-(\\d{2})-(\\d{2})[T ](\\d{2}):(\\d{2}):(\\d{2})(\\.\\d{1,9})?((?:[+-]\\d{2}:\\d{2})|Z)$/;\n      var matches = rfc3339Matcher.exec(str);\n\n      if (!matches) {\n        throw new Error(\"Date string is not in RFC3339 format\");\n      }\n\n      var year = +matches[1];\n      var month = +matches[2];\n      var day = +matches[3];\n      var hour = +matches[4];\n      var minute = +matches[5];\n      var second = +matches[6]; // fractional seconds match either undefined or a string like \".1\", \".123456789\"\n\n      var milliSeconds = matches[7] ? Math.floor(+matches[7] * 1000) : 0;\n      var tzOffsetSign;\n      var tzOffsetHours;\n      var tzOffsetMinutes; // if timezone is undefined, it must be Z or nothing (otherwise the group would have captured).\n\n      if (matches[8] === \"Z\") {\n        tzOffsetSign = 1;\n        tzOffsetHours = 0;\n        tzOffsetMinutes = 0;\n      } else {\n        tzOffsetSign = matches[8].substring(0, 1) === \"-\" ? -1 : 1;\n        tzOffsetHours = +matches[8].substring(1, 3);\n        tzOffsetMinutes = +matches[8].substring(4, 6);\n      }\n\n      var tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60; // seconds\n\n      return new readonly_date_1.ReadonlyDate(readonly_date_1.ReadonlyDate.UTC(year, month - 1, day, hour, minute, second, milliSeconds) - tzOffset * 1000);\n    }\n  }, {\n    key: \"toRfc3339\",\n    value: function toRfc3339(date) {\n      function padded(integer) {\n        var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n        var filled = \"00000\" + integer.toString();\n        return filled.substring(filled.length - length);\n      }\n\n      var year = date.getUTCFullYear();\n      var month = padded(date.getUTCMonth() + 1);\n      var day = padded(date.getUTCDate());\n      var hour = padded(date.getUTCHours());\n      var minute = padded(date.getUTCMinutes());\n      var second = padded(date.getUTCSeconds());\n      var ms = padded(date.getUTCMilliseconds(), 3);\n      return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second, \".\").concat(ms, \"Z\");\n    }\n  }, {\n    key: \"isValidUtf8\",\n    value: function isValidUtf8(data) {\n      var toStringAndBack = Buffer.from(Buffer.from(data).toString(\"utf8\"), \"utf8\");\n      return Buffer.compare(Buffer.from(data), toStringAndBack) === 0;\n    }\n  }]);\n\n  return Encoding;\n}();\n\nexports.Encoding = Encoding;","map":{"version":3,"sources":["../src/encoding.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AACA,IAAA,eAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;IAQa,Q;;;;;;;WACJ,eAAa,IAAb,EAA6B;AAClC,UAAI,GAAG,GAAG,EAAV;;AADkC,iDAEf,IAFe;AAAA;;AAAA;AAElC,4DAAyB;AAAA,cAAd,IAAc;AACvB,UAAA,GAAG,IAAI,CAAC,MAAM,IAAI,CAAC,QAAL,CAAc,EAAd,CAAP,EAA0B,KAA1B,CAAgC,CAAC,CAAjC,CAAP;AACD;AAJiC;AAAA;AAAA;AAAA;AAAA;;AAKlC,aAAO,GAAP;AACD;;;WAEM,iBAAe,SAAf,EAAgC;AACrC,UAAI,SAAS,CAAC,MAAV,GAAmB,CAAnB,KAAyB,CAA7B,EAAgC;AAC9B,cAAM,IAAI,KAAJ,CAAU,2CAAV,CAAN;AACD,OAHoC,CAKrC;;;AACA,UAAM,UAAU,GAAa,EAA7B;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,IAAI,CAA3C,EAA8C;AAC5C,YAAM,eAAe,GAAG,SAAS,CAAC,MAAV,CAAiB,CAAjB,EAAoB,CAApB,CAAxB;;AACA,YAAI,CAAC,eAAe,CAAC,KAAhB,CAAsB,cAAtB,CAAL,EAA4C;AAC1C,gBAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AACD;;AACD,QAAA,UAAU,CAAC,IAAX,CAAgB,QAAQ,CAAC,eAAD,EAAkB,EAAlB,CAAxB;AACD;;AACD,aAAO,IAAI,UAAJ,CAAe,UAAf,CAAP;AACD;;;WAEM,kBAAgB,IAAhB,EAAgC;AACrC,aAAO,QAAQ,CAAC,aAAT,CAAuB,IAAvB,CAAP;AACD;;;WAEM,oBAAkB,YAAlB,EAAsC;AAC3C,UAAI,CAAC,YAAY,CAAC,KAAb,CAAmB,wBAAnB,CAAL,EAAmD;AACjD,cAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,aAAO,QAAQ,CAAC,WAAT,CAAqB,YAArB,CAAP;AACD;;;WAEM,iBAAe,KAAf,EAA4B;AACjC,UAAM,MAAM,GAAG,SAAT,MAAS,CAAC,GAAD;AAAA,eACb,GAAG,CAAC,KAAJ,CAAU,EAAV,EAAc,GAAd,CAAkB,UAAC,CAAD,EAAc;AAC9B,cAAM,QAAQ,GAAG,CAAC,CAAC,UAAF,CAAa,CAAb,CAAjB,CAD8B,CAE9B;AACA;AACA;AACA;;AACA,cAAI,QAAQ,GAAG,IAAX,IAAmB,QAAQ,GAAG,IAAlC,EAAwC;AACtC,kBAAM,IAAI,KAAJ,CAAU,mEAAmE,QAA7E,CAAN;AACD;;AACD,iBAAO,QAAP;AACD,SAVD,CADa;AAAA,OAAf;;AAYA,aAAO,UAAU,CAAC,IAAX,CAAgB,MAAM,CAAC,KAAD,CAAtB,CAAP;AACD;;;WAEM,mBAAiB,IAAjB,EAAiC;AACtC,UAAM,QAAQ,GAAG,SAAX,QAAW,CAAC,aAAD;AAAA,eACf,aAAa,CAAC,GAAd,CAAkB,UAAC,CAAD,EAAsB;AACtC;AACA;AACA;AACA;AACA,cAAI,CAAC,GAAG,IAAJ,IAAY,CAAC,GAAG,IAApB,EAA0B;AACxB,kBAAM,IAAI,KAAJ,CAAU,mEAAmE,CAA7E,CAAN;AACD;;AACD,iBAAO,MAAM,CAAC,YAAP,CAAoB,CAApB,CAAP;AACD,SATD,CADe;AAAA,OAAjB;;AAYA,aAAO,QAAQ,CAAC,KAAK,CAAC,IAAN,CAAW,IAAX,CAAD,CAAR,CAA2B,IAA3B,CAAgC,EAAhC,CAAP;AACD;;;WAEM,gBAAc,GAAd,EAAyB;AAC9B;AACA,UAAI,OAAO,WAAP,KAAuB,WAA3B,EAAwC;AACtC,eAAO,IAAI,WAAJ,GAAkB,MAAlB,CAAyB,GAAzB,CAAP;AACD,OAJ6B,CAM9B;AACA;;;AACA,aAAO,IAAI,UAAJ,CAAe,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,MAAjB,CAAf,CAAP;AACD;;;WAEM,kBAAgB,IAAhB,EAAgC;AACrC;AACA,UAAI,OAAO,WAAP,KAAuB,WAA3B,EAAwC;AACtC,eAAO,IAAI,WAAJ,CAAgB,OAAhB,EAAyB;AAAE,UAAA,KAAK,EAAE;AAAT,SAAzB,EAA0C,MAA1C,CAAiD,IAAjD,CAAP;AACD,OAJoC,CAMrC;AACA;AACA;;;AACA,UAAI,CAAC,QAAQ,CAAC,WAAT,CAAqB,IAArB,CAAL,EAAiC;AAC/B,cAAM,IAAI,KAAJ,CAAU,mBAAV,CAAN;AACD;;AACD,aAAO,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,QAAlB,CAA2B,MAA3B,CAAP;AACD;;;WAEM,qBAAmB,GAAnB,EAA8B;AACnC,UAAM,cAAc,GAAG,yFAAvB;AAEA,UAAM,OAAO,GAAG,cAAc,CAAC,IAAf,CAAoB,GAApB,CAAhB;;AACA,UAAI,CAAC,OAAL,EAAc;AACZ,cAAM,IAAI,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,UAAM,IAAI,GAAG,CAAC,OAAO,CAAC,CAAD,CAArB;AACA,UAAM,KAAK,GAAG,CAAC,OAAO,CAAC,CAAD,CAAtB;AACA,UAAM,GAAG,GAAG,CAAC,OAAO,CAAC,CAAD,CAApB;AACA,UAAM,IAAI,GAAG,CAAC,OAAO,CAAC,CAAD,CAArB;AACA,UAAM,MAAM,GAAG,CAAC,OAAO,CAAC,CAAD,CAAvB;AACA,UAAM,MAAM,GAAG,CAAC,OAAO,CAAC,CAAD,CAAvB,CAbmC,CAenC;;AACA,UAAM,YAAY,GAAG,OAAO,CAAC,CAAD,CAAP,GAAa,IAAI,CAAC,KAAL,CAAW,CAAC,OAAO,CAAC,CAAD,CAAR,GAAc,IAAzB,CAAb,GAA8C,CAAnE;AAEA,UAAI,YAAJ;AACA,UAAI,aAAJ;AACA,UAAI,eAAJ,CApBmC,CAsBnC;;AACA,UAAI,OAAO,CAAC,CAAD,CAAP,KAAe,GAAnB,EAAwB;AACtB,QAAA,YAAY,GAAG,CAAf;AACA,QAAA,aAAa,GAAG,CAAhB;AACA,QAAA,eAAe,GAAG,CAAlB;AACD,OAJD,MAIO;AACL,QAAA,YAAY,GAAG,OAAO,CAAC,CAAD,CAAP,CAAW,SAAX,CAAqB,CAArB,EAAwB,CAAxB,MAA+B,GAA/B,GAAqC,CAAC,CAAtC,GAA0C,CAAzD;AACA,QAAA,aAAa,GAAG,CAAC,OAAO,CAAC,CAAD,CAAP,CAAW,SAAX,CAAqB,CAArB,EAAwB,CAAxB,CAAjB;AACA,QAAA,eAAe,GAAG,CAAC,OAAO,CAAC,CAAD,CAAP,CAAW,SAAX,CAAqB,CAArB,EAAwB,CAAxB,CAAnB;AACD;;AAED,UAAM,QAAQ,GAAG,YAAY,IAAI,aAAa,GAAG,EAAhB,GAAqB,eAAzB,CAAZ,GAAwD,EAAzE,CAjCmC,CAiC0C;;AAE7E,aAAO,IAAI,eAAA,CAAA,YAAJ,CACL,eAAA,CAAA,YAAA,CAAa,GAAb,CAAiB,IAAjB,EAAuB,KAAK,GAAG,CAA/B,EAAkC,GAAlC,EAAuC,IAAvC,EAA6C,MAA7C,EAAqD,MAArD,EAA6D,YAA7D,IAA6E,QAAQ,GAAG,IADnF,CAAP;AAGD;;;WAEM,mBAAiB,IAAjB,EAA0C;AAC/C,eAAS,MAAT,CAAgB,OAAhB,EAA2C;AAAA,YAAV,MAAU,uEAAD,CAAC;AACzC,YAAM,MAAM,GAAG,UAAU,OAAO,CAAC,QAAR,EAAzB;AACA,eAAO,MAAM,CAAC,SAAP,CAAiB,MAAM,CAAC,MAAP,GAAgB,MAAjC,CAAP;AACD;;AAED,UAAM,IAAI,GAAG,IAAI,CAAC,cAAL,EAAb;AACA,UAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,WAAL,KAAqB,CAAtB,CAApB;AACA,UAAM,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,UAAL,EAAD,CAAlB;AACA,UAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,WAAL,EAAD,CAAnB;AACA,UAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,aAAL,EAAD,CAArB;AACA,UAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,aAAL,EAAD,CAArB;AACA,UAAM,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC,kBAAL,EAAD,EAA4B,CAA5B,CAAjB;AAEA,uBAAU,IAAV,cAAkB,KAAlB,cAA2B,GAA3B,cAAkC,IAAlC,cAA0C,MAA1C,cAAoD,MAApD,cAA8D,EAA9D;AACD;;;WAEO,qBAAmB,IAAnB,EAAmC;AACzC,UAAM,eAAe,GAAG,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,QAAlB,CAA2B,MAA3B,CAAZ,EAAgD,MAAhD,CAAxB;AACA,aAAO,MAAM,CAAC,OAAP,CAAe,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAf,EAAkC,eAAlC,MAAuD,CAA9D;AACD;;;;;;AA3JH,OAAA,CAAA,QAAA,GAAA,QAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base64js = __importStar(require(\"base64-js\"));\nconst readonly_date_1 = require(\"readonly-date\");\nclass Encoding {\n    static toHex(data) {\n        let out = \"\";\n        for (const byte of data) {\n            out += (\"0\" + byte.toString(16)).slice(-2);\n        }\n        return out;\n    }\n    static fromHex(hexstring) {\n        if (hexstring.length % 2 !== 0) {\n            throw new Error(\"hex string length must be a multiple of 2\");\n        }\n        // tslint:disable-next-line:readonly-array\n        const listOfInts = [];\n        for (let i = 0; i < hexstring.length; i += 2) {\n            const hexByteAsString = hexstring.substr(i, 2);\n            if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {\n                throw new Error(\"hex string contains invalid characters\");\n            }\n            listOfInts.push(parseInt(hexByteAsString, 16));\n        }\n        return new Uint8Array(listOfInts);\n    }\n    static toBase64(data) {\n        return base64js.fromByteArray(data);\n    }\n    static fromBase64(base64String) {\n        if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {\n            throw new Error(\"Invalid base64 string format\");\n        }\n        return base64js.toByteArray(base64String);\n    }\n    static toAscii(input) {\n        const toNums = (str) => str.split(\"\").map((x) => {\n            const charCode = x.charCodeAt(0);\n            // 0x00–0x1F control characters\n            // 0x20–0x7E printable characters\n            // 0x7F delete character\n            // 0x80–0xFF out of 7 bit ascii range\n            if (charCode < 0x20 || charCode > 0x7e) {\n                throw new Error(\"Cannot encode character that is out of printable ASCII range: \" + charCode);\n            }\n            return charCode;\n        });\n        return Uint8Array.from(toNums(input));\n    }\n    static fromAscii(data) {\n        const fromNums = (listOfNumbers) => listOfNumbers.map((x) => {\n            // 0x00–0x1F control characters\n            // 0x20–0x7E printable characters\n            // 0x7F delete character\n            // 0x80–0xFF out of 7 bit ascii range\n            if (x < 0x20 || x > 0x7e) {\n                throw new Error(\"Cannot decode character that is out of printable ASCII range: \" + x);\n            }\n            return String.fromCharCode(x);\n        });\n        return fromNums(Array.from(data)).join(\"\");\n    }\n    static toUtf8(str) {\n        // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n        if (typeof TextEncoder !== \"undefined\") {\n            return new TextEncoder().encode(str);\n        }\n        // Use Buffer hack instead of nodejs util.TextEncoder to ensure\n        // webpack does not bundle the util module for browsers.\n        return new Uint8Array(Buffer.from(str, \"utf8\"));\n    }\n    static fromUtf8(data) {\n        // Browser and future nodejs (https://github.com/nodejs/node/issues/20365)\n        if (typeof TextDecoder !== \"undefined\") {\n            return new TextDecoder(\"utf-8\", { fatal: true }).decode(data);\n        }\n        // Use Buffer hack instead of nodejs util.TextDecoder to ensure\n        // webpack does not bundle the util module for browsers.\n        // Buffer.toString has no fatal option\n        if (!Encoding.isValidUtf8(data)) {\n            throw new Error(\"Invalid UTF8 data\");\n        }\n        return Buffer.from(data).toString(\"utf8\");\n    }\n    static fromRfc3339(str) {\n        const rfc3339Matcher = /^(\\d{4})-(\\d{2})-(\\d{2})[T ](\\d{2}):(\\d{2}):(\\d{2})(\\.\\d{1,9})?((?:[+-]\\d{2}:\\d{2})|Z)$/;\n        const matches = rfc3339Matcher.exec(str);\n        if (!matches) {\n            throw new Error(\"Date string is not in RFC3339 format\");\n        }\n        const year = +matches[1];\n        const month = +matches[2];\n        const day = +matches[3];\n        const hour = +matches[4];\n        const minute = +matches[5];\n        const second = +matches[6];\n        // fractional seconds match either undefined or a string like \".1\", \".123456789\"\n        const milliSeconds = matches[7] ? Math.floor(+matches[7] * 1000) : 0;\n        let tzOffsetSign;\n        let tzOffsetHours;\n        let tzOffsetMinutes;\n        // if timezone is undefined, it must be Z or nothing (otherwise the group would have captured).\n        if (matches[8] === \"Z\") {\n            tzOffsetSign = 1;\n            tzOffsetHours = 0;\n            tzOffsetMinutes = 0;\n        }\n        else {\n            tzOffsetSign = matches[8].substring(0, 1) === \"-\" ? -1 : 1;\n            tzOffsetHours = +matches[8].substring(1, 3);\n            tzOffsetMinutes = +matches[8].substring(4, 6);\n        }\n        const tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60; // seconds\n        return new readonly_date_1.ReadonlyDate(readonly_date_1.ReadonlyDate.UTC(year, month - 1, day, hour, minute, second, milliSeconds) - tzOffset * 1000);\n    }\n    static toRfc3339(date) {\n        function padded(integer, length = 2) {\n            const filled = \"00000\" + integer.toString();\n            return filled.substring(filled.length - length);\n        }\n        const year = date.getUTCFullYear();\n        const month = padded(date.getUTCMonth() + 1);\n        const day = padded(date.getUTCDate());\n        const hour = padded(date.getUTCHours());\n        const minute = padded(date.getUTCMinutes());\n        const second = padded(date.getUTCSeconds());\n        const ms = padded(date.getUTCMilliseconds(), 3);\n        return `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms}Z`;\n    }\n    static isValidUtf8(data) {\n        const toStringAndBack = Buffer.from(Buffer.from(data).toString(\"utf8\"), \"utf8\");\n        return Buffer.compare(Buffer.from(data), toStringAndBack) === 0;\n    }\n}\nexports.Encoding = Encoding;\n//# sourceMappingURL=encoding.js.map"]},"metadata":{},"sourceType":"script"}