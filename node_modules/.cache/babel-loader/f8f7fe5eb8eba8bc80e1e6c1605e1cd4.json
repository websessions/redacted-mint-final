{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016-2017 Tony Arcieri, Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nvar _regeneratorRuntime = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar block_1 = require(\"../internals/block\");\n\nvar constant_time_1 = require(\"../internals/constant-time\");\n\nvar ctz_1 = require(\"../internals/ctz\");\n\nvar xor_1 = require(\"../internals/xor\"); // Number of L blocks to precompute (i.e. µ in the PMAC paper)\n// TODO: dynamically compute these as needed\n\n\nvar PRECOMPUTED_BLOCKS = 31;\n/**\n * Polyfill for the AES-PMAC message authentication code\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n */\n\nvar PMAC = /*#__PURE__*/function () {\n  function PMAC(cipher, l, lInv) {\n    _classCallCheck(this, PMAC);\n\n    /**\n     * finished is set true when we are done processing a message, and forbids\n     * any subsequent writes until we reset the internal state\n     */\n    this._finished = false;\n    this._cipher = cipher;\n    this._L = l;\n    this._LInv = lInv;\n    this._buffer = new block_1.default();\n    this._bufferPos = 0;\n    this._counter = 0;\n    this._offset = new block_1.default();\n    this._tag = new block_1.default();\n  }\n  /** Create a new CMAC instance from the given key */\n\n\n  _createClass(PMAC, [{\n    key: \"reset\",\n    value: function reset() {\n      this._buffer.clear();\n\n      this._bufferPos = 0;\n      this._counter = 0;\n\n      this._offset.clear();\n\n      this._tag.clear();\n\n      this._finished = false;\n      return this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.reset();\n\n      this._cipher.clear();\n    }\n  }, {\n    key: \"update\",\n    value: function update(data) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var left, dataPos, dataLength;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._finished) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new Error(\"pmac: already finished\");\n\n              case 2:\n                left = block_1.default.SIZE - this._bufferPos;\n                dataPos = 0;\n                dataLength = data.length; // Finish filling the internal buf with the message\n\n                if (!(dataLength > left)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                this._buffer.data.set(data.slice(0, left), this._bufferPos);\n\n                dataPos += left;\n                dataLength -= left;\n                _context.next = 11;\n                return this._processBuffer();\n\n              case 11:\n                if (!(dataLength > block_1.default.SIZE)) {\n                  _context.next = 19;\n                  break;\n                }\n\n                this._buffer.data.set(data.slice(dataPos, dataPos + block_1.default.SIZE));\n\n                dataPos += block_1.default.SIZE;\n                dataLength -= block_1.default.SIZE;\n                _context.next = 17;\n                return this._processBuffer();\n\n              case 17:\n                _context.next = 11;\n                break;\n\n              case 19:\n                if (dataLength > 0) {\n                  this._buffer.data.set(data.slice(dataPos, dataPos + dataLength), this._bufferPos);\n\n                  this._bufferPos += dataLength;\n                }\n\n                return _context.abrupt(\"return\", this);\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._finished) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error(\"pmac: already finished\");\n\n              case 2:\n                if (this._bufferPos === block_1.default.SIZE) {\n                  xor_1.xor(this._tag.data, this._buffer.data);\n                  xor_1.xor(this._tag.data, this._LInv.data);\n                } else {\n                  xor_1.xor(this._tag.data, this._buffer.data.slice(0, this._bufferPos));\n                  this._tag.data[this._bufferPos] ^= 0x80;\n                }\n\n                _context2.next = 5;\n                return this._cipher.encryptBlock(this._tag);\n\n              case 5:\n                this._finished = true;\n                return _context2.abrupt(\"return\", this._tag.clone().data);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    } // Update the internal tag state based on the buffer contents\n\n  }, {\n    key: \"_processBuffer\",\n    value: function _processBuffer() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                xor_1.xor(this._offset.data, this._L[ctz_1.ctz(this._counter + 1)].data);\n                xor_1.xor(this._buffer.data, this._offset.data);\n                this._counter++;\n                _context3.next = 5;\n                return this._cipher.encryptBlock(this._buffer);\n\n              case 5:\n                xor_1.xor(this._tag.data, this._buffer.data);\n                this._bufferPos = 0;\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }], [{\n    key: \"importKey\",\n    value: function importKey(provider, keyData) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var cipher, tmp, l, i, lInv, lastBit, _i, carry;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return provider.importBlockCipherKey(keyData);\n\n              case 2:\n                cipher = _context4.sent;\n\n                /**\n                 * L is defined as follows (quoted from the PMAC paper):\n                 *\n                 * Equation 1:\n                 *\n                 *     a · x =\n                 *         a<<1 if firstbit(a)=0\n                 *         (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n                 *\n                 * Equation 2:\n                 *\n                 *     a · x⁻¹ =\n                 *         a>>1 if lastbit(a)=0\n                 *         (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n                 *\n                 * Let L(0) ← L. For i ∈ [1..µ], compute L(i) ← L(i − 1) · x by\n                 * Equation (1) using a shift and a conditional xor.\n                 *\n                 * Compute L(−1) ← L · x⁻¹ by Equation (2), using a shift and a\n                 * conditional xor.\n                 *\n                 * Save the values L(−1), L(0), L(1), L(2), ..., L(µ) in a table.\n                 * (Alternatively, [ed: as we have done in this codebase] defer computing\n                 * some or  all of these L(i) values until the value is actually needed.)\n                 */\n                tmp = new block_1.default();\n                _context4.next = 6;\n                return cipher.encryptBlock(tmp);\n\n              case 6:\n                l = new Array(PRECOMPUTED_BLOCKS);\n\n                for (i = 0; i < PRECOMPUTED_BLOCKS; i++) {\n                  l[i] = tmp.clone();\n                  tmp.dbl();\n                }\n                /**\n                 * Compute L(−1) ← L · x⁻¹:\n                 *\n                 *     a>>1 if lastbit(a)=0\n                 *     (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n                 */\n\n\n                lInv = l[0].clone();\n                lastBit = lInv.data[block_1.default.SIZE - 1] & 0x01;\n\n                for (_i = block_1.default.SIZE - 1; _i > 0; _i--) {\n                  carry = constant_time_1.select(lInv.data[_i - 1] & 1, 0x80, 0);\n                  lInv.data[_i] = lInv.data[_i] >>> 1 | carry;\n                }\n\n                lInv.data[0] >>>= 1;\n                lInv.data[0] ^= constant_time_1.select(lastBit, 0x80, 0);\n                lInv.data[block_1.default.SIZE - 1] ^= constant_time_1.select(lastBit, block_1.default.R >>> 1, 0);\n                return _context4.abrupt(\"return\", new PMAC(cipher, l, lInv));\n\n              case 15:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n    }\n  }]);\n\n  return PMAC;\n}();\n\nexports.PMAC = PMAC;","map":{"version":3,"sources":["/Users/aidansalzmann/redacted-mint/node_modules/miscreant/release/mac/pmac.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","block_1","require","constant_time_1","ctz_1","xor_1","PRECOMPUTED_BLOCKS","PMAC","cipher","l","lInv","_finished","_cipher","_L","_LInv","_buffer","default","_bufferPos","_counter","_offset","_tag","clear","reset","data","Error","left","SIZE","dataPos","dataLength","length","set","slice","_processBuffer","xor","encryptBlock","clone","ctz","provider","keyData","importBlockCipherKey","tmp","Array","i","dbl","lastBit","carry","select","R"],"mappings":"AAAA,a,CACA;AACA;;;;;;;;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,CAA/B,EAAkCC,SAAlC,EAA6C;AACrF,SAAO,KAAKD,CAAC,KAAKA,CAAC,GAAGE,OAAT,CAAN,EAAyB,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AACvD,aAASC,SAAT,CAAmBC,KAAnB,EAA0B;AAAE,UAAI;AAAEC,QAAAA,IAAI,CAACN,SAAS,CAACO,IAAV,CAAeF,KAAf,CAAD,CAAJ;AAA8B,OAApC,CAAqC,OAAOG,CAAP,EAAU;AAAEL,QAAAA,MAAM,CAACK,CAAD,CAAN;AAAY;AAAE;;AAC3F,aAASC,QAAT,CAAkBJ,KAAlB,EAAyB;AAAE,UAAI;AAAEC,QAAAA,IAAI,CAACN,SAAS,CAAC,OAAD,CAAT,CAAmBK,KAAnB,CAAD,CAAJ;AAAkC,OAAxC,CAAyC,OAAOG,CAAP,EAAU;AAAEL,QAAAA,MAAM,CAACK,CAAD,CAAN;AAAY;AAAE;;AAC9F,aAASF,IAAT,CAAcI,MAAd,EAAsB;AAAEA,MAAAA,MAAM,CAACC,IAAP,GAAcT,OAAO,CAACQ,MAAM,CAACL,KAAR,CAArB,GAAsC,IAAIN,CAAJ,CAAM,UAAUG,OAAV,EAAmB;AAAEA,QAAAA,OAAO,CAACQ,MAAM,CAACL,KAAR,CAAP;AAAwB,OAAnD,EAAqDO,IAArD,CAA0DR,SAA1D,EAAqEK,QAArE,CAAtC;AAAuH;;AAC/IH,IAAAA,IAAI,CAAC,CAACN,SAAS,GAAGA,SAAS,CAACa,KAAV,CAAgBhB,OAAhB,EAAyBC,UAAU,IAAI,EAAvC,CAAb,EAAyDS,IAAzD,EAAD,CAAJ;AACH,GALM,CAAP;AAMH,CAPD;;AAQAO,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEX,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAMY,OAAO,GAAGC,OAAO,CAAC,oBAAD,CAAvB;;AACA,IAAMC,eAAe,GAAGD,OAAO,CAAC,4BAAD,CAA/B;;AACA,IAAME,KAAK,GAAGF,OAAO,CAAC,kBAAD,CAArB;;AACA,IAAMG,KAAK,GAAGH,OAAO,CAAC,kBAAD,CAArB,C,CACA;AACA;;;AACA,IAAMI,kBAAkB,GAAG,EAA3B;AACA;AACA;AACA;AACA;AACA;AACA;;IACMC,I;AACF,gBAAYC,MAAZ,EAAoBC,CAApB,EAAuBC,IAAvB,EAA6B;AAAA;;AACzB;AACR;AACA;AACA;AACQ,SAAKC,SAAL,GAAiB,KAAjB;AACA,SAAKC,OAAL,GAAeJ,MAAf;AACA,SAAKK,EAAL,GAAUJ,CAAV;AACA,SAAKK,KAAL,GAAaJ,IAAb;AACA,SAAKK,OAAL,GAAe,IAAId,OAAO,CAACe,OAAZ,EAAf;AACA,SAAKC,UAAL,GAAkB,CAAlB;AACA,SAAKC,QAAL,GAAgB,CAAhB;AACA,SAAKC,OAAL,GAAe,IAAIlB,OAAO,CAACe,OAAZ,EAAf;AACA,SAAKI,IAAL,GAAY,IAAInB,OAAO,CAACe,OAAZ,EAAZ;AACH;AACD;;;;;WAsDA,iBAAQ;AACJ,WAAKD,OAAL,CAAaM,KAAb;;AACA,WAAKJ,UAAL,GAAkB,CAAlB;AACA,WAAKC,QAAL,GAAgB,CAAhB;;AACA,WAAKC,OAAL,CAAaE,KAAb;;AACA,WAAKD,IAAL,CAAUC,KAAV;;AACA,WAAKV,SAAL,GAAiB,KAAjB;AACA,aAAO,IAAP;AACH;;;WACD,iBAAQ;AACJ,WAAKW,KAAL;;AACA,WAAKV,OAAL,CAAaS,KAAb;AACH;;;WACD,gBAAOE,IAAP,EAAa;AACT,aAAO3C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,wCAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAC/B,KAAK+B,SAD0B;AAAA;AAAA;AAAA;;AAAA,sBAEzB,IAAIa,KAAJ,CAAU,wBAAV,CAFyB;;AAAA;AAI7BC,gBAAAA,IAJ6B,GAItBxB,OAAO,CAACe,OAAR,CAAgBU,IAAhB,GAAuB,KAAKT,UAJN;AAK/BU,gBAAAA,OAL+B,GAKrB,CALqB;AAM/BC,gBAAAA,UAN+B,GAMlBL,IAAI,CAACM,MANa,EAOnC;;AAPmC,sBAQ/BD,UAAU,GAAGH,IARkB;AAAA;AAAA;AAAA;;AAS/B,qBAAKV,OAAL,CAAaQ,IAAb,CAAkBO,GAAlB,CAAsBP,IAAI,CAACQ,KAAL,CAAW,CAAX,EAAcN,IAAd,CAAtB,EAA2C,KAAKR,UAAhD;;AACAU,gBAAAA,OAAO,IAAIF,IAAX;AACAG,gBAAAA,UAAU,IAAIH,IAAd;AAX+B;AAY/B,uBAAM,KAAKO,cAAL,EAAN;;AAZ+B;AAAA,sBAgB5BJ,UAAU,GAAG3B,OAAO,CAACe,OAAR,CAAgBU,IAhBD;AAAA;AAAA;AAAA;;AAiB/B,qBAAKX,OAAL,CAAaQ,IAAb,CAAkBO,GAAlB,CAAsBP,IAAI,CAACQ,KAAL,CAAWJ,OAAX,EAAoBA,OAAO,GAAG1B,OAAO,CAACe,OAAR,CAAgBU,IAA9C,CAAtB;;AACAC,gBAAAA,OAAO,IAAI1B,OAAO,CAACe,OAAR,CAAgBU,IAA3B;AACAE,gBAAAA,UAAU,IAAI3B,OAAO,CAACe,OAAR,CAAgBU,IAA9B;AAnB+B;AAoB/B,uBAAM,KAAKM,cAAL,EAAN;;AApB+B;AAAA;AAAA;;AAAA;AAsBnC,oBAAIJ,UAAU,GAAG,CAAjB,EAAoB;AAChB,uBAAKb,OAAL,CAAaQ,IAAb,CAAkBO,GAAlB,CAAsBP,IAAI,CAACQ,KAAL,CAAWJ,OAAX,EAAoBA,OAAO,GAAGC,UAA9B,CAAtB,EAAiE,KAAKX,UAAtE;;AACA,uBAAKA,UAAL,IAAmBW,UAAnB;AACH;;AAzBkC,iDA0B5B,IA1B4B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAvB,EAAhB;AA4BH;;;WACD,kBAAS;AACL,aAAOhD,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,wCAAuB;AAAA;AAAA;AAAA;AAAA;AAAA,qBAC/B,KAAK+B,SAD0B;AAAA;AAAA;AAAA;;AAAA,sBAEzB,IAAIa,KAAJ,CAAU,wBAAV,CAFyB;;AAAA;AAInC,oBAAI,KAAKP,UAAL,KAAoBhB,OAAO,CAACe,OAAR,CAAgBU,IAAxC,EAA8C;AAC1CrB,kBAAAA,KAAK,CAAC4B,GAAN,CAAU,KAAKb,IAAL,CAAUG,IAApB,EAA0B,KAAKR,OAAL,CAAaQ,IAAvC;AACAlB,kBAAAA,KAAK,CAAC4B,GAAN,CAAU,KAAKb,IAAL,CAAUG,IAApB,EAA0B,KAAKT,KAAL,CAAWS,IAArC;AACH,iBAHD,MAIK;AACDlB,kBAAAA,KAAK,CAAC4B,GAAN,CAAU,KAAKb,IAAL,CAAUG,IAApB,EAA0B,KAAKR,OAAL,CAAaQ,IAAb,CAAkBQ,KAAlB,CAAwB,CAAxB,EAA2B,KAAKd,UAAhC,CAA1B;AACA,uBAAKG,IAAL,CAAUG,IAAV,CAAe,KAAKN,UAApB,KAAmC,IAAnC;AACH;;AAXkC;AAYnC,uBAAM,KAAKL,OAAL,CAAasB,YAAb,CAA0B,KAAKd,IAA/B,CAAN;;AAZmC;AAanC,qBAAKT,SAAL,GAAiB,IAAjB;AAbmC,kDAc5B,KAAKS,IAAL,CAAUe,KAAV,GAAkBZ,IAdU;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAvB,EAAhB;AAgBH,K,CACD;;;;WACA,0BAAiB;AACb,aAAO3C,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,wCAAuB;AAAA;AAAA;AAAA;AAAA;AACnCyB,gBAAAA,KAAK,CAAC4B,GAAN,CAAU,KAAKd,OAAL,CAAaI,IAAvB,EAA6B,KAAKV,EAAL,CAAQT,KAAK,CAACgC,GAAN,CAAU,KAAKlB,QAAL,GAAgB,CAA1B,CAAR,EAAsCK,IAAnE;AACAlB,gBAAAA,KAAK,CAAC4B,GAAN,CAAU,KAAKlB,OAAL,CAAaQ,IAAvB,EAA6B,KAAKJ,OAAL,CAAaI,IAA1C;AACA,qBAAKL,QAAL;AAHmC;AAInC,uBAAM,KAAKN,OAAL,CAAasB,YAAb,CAA0B,KAAKnB,OAA/B,CAAN;;AAJmC;AAKnCV,gBAAAA,KAAK,CAAC4B,GAAN,CAAU,KAAKb,IAAL,CAAUG,IAApB,EAA0B,KAAKR,OAAL,CAAaQ,IAAvC;AACA,qBAAKN,UAAL,GAAkB,CAAlB;;AANmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAvB,EAAhB;AAQH;;;WA5HD,mBAAiBoB,QAAjB,EAA2BC,OAA3B,EAAoC;AAChC,aAAO1D,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,wCAAuB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACpB,uBAAMyD,QAAQ,CAACE,oBAAT,CAA8BD,OAA9B,CAAN;;AADoB;AAC7B9B,gBAAAA,MAD6B;;AAEnC;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkBgC,gBAAAA,GA3B6B,GA2BvB,IAAIvC,OAAO,CAACe,OAAZ,EA3BuB;AAAA;AA4BnC,uBAAMR,MAAM,CAAC0B,YAAP,CAAoBM,GAApB,CAAN;;AA5BmC;AA6B7B/B,gBAAAA,CA7B6B,GA6BzB,IAAIgC,KAAJ,CAAUnC,kBAAV,CA7ByB;;AA8BnC,qBAASoC,CAAT,GAAa,CAAb,EAAgBA,CAAC,GAAGpC,kBAApB,EAAwCoC,CAAC,EAAzC,EAA6C;AACzCjC,kBAAAA,CAAC,CAACiC,CAAD,CAAD,GAAOF,GAAG,CAACL,KAAJ,EAAP;AACAK,kBAAAA,GAAG,CAACG,GAAJ;AACH;AACD;AACZ;AACA;AACA;AACA;AACA;;;AACkBjC,gBAAAA,IAxC6B,GAwCtBD,CAAC,CAAC,CAAD,CAAD,CAAK0B,KAAL,EAxCsB;AAyC7BS,gBAAAA,OAzC6B,GAyCnBlC,IAAI,CAACa,IAAL,CAAUtB,OAAO,CAACe,OAAR,CAAgBU,IAAhB,GAAuB,CAAjC,IAAsC,IAzCnB;;AA0CnC,qBAASgB,EAAT,GAAazC,OAAO,CAACe,OAAR,CAAgBU,IAAhB,GAAuB,CAApC,EAAuCgB,EAAC,GAAG,CAA3C,EAA8CA,EAAC,EAA/C,EAAmD;AACzCG,kBAAAA,KADyC,GACjC1C,eAAe,CAAC2C,MAAhB,CAAuBpC,IAAI,CAACa,IAAL,CAAUmB,EAAC,GAAG,CAAd,IAAmB,CAA1C,EAA6C,IAA7C,EAAmD,CAAnD,CADiC;AAE/ChC,kBAAAA,IAAI,CAACa,IAAL,CAAUmB,EAAV,IAAgBhC,IAAI,CAACa,IAAL,CAAUmB,EAAV,MAAiB,CAAlB,GAAuBG,KAAtC;AACH;;AACDnC,gBAAAA,IAAI,CAACa,IAAL,CAAU,CAAV,OAAkB,CAAlB;AACAb,gBAAAA,IAAI,CAACa,IAAL,CAAU,CAAV,KAAgBpB,eAAe,CAAC2C,MAAhB,CAAuBF,OAAvB,EAAgC,IAAhC,EAAsC,CAAtC,CAAhB;AACAlC,gBAAAA,IAAI,CAACa,IAAL,CAAUtB,OAAO,CAACe,OAAR,CAAgBU,IAAhB,GAAuB,CAAjC,KAAuCvB,eAAe,CAAC2C,MAAhB,CAAuBF,OAAvB,EAAgC3C,OAAO,CAACe,OAAR,CAAgB+B,CAAhB,KAAsB,CAAtD,EAAyD,CAAzD,CAAvC;AAhDmC,kDAiD5B,IAAIxC,IAAJ,CAASC,MAAT,EAAiBC,CAAjB,EAAoBC,IAApB,CAjD4B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAvB,EAAhB;AAmDH;;;;;;AA0ELV,OAAO,CAACO,IAAR,GAAeA,IAAf","sourcesContent":["\"use strict\";\n// Copyright (C) 2016-2017 Tony Arcieri, Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst block_1 = require(\"../internals/block\");\nconst constant_time_1 = require(\"../internals/constant-time\");\nconst ctz_1 = require(\"../internals/ctz\");\nconst xor_1 = require(\"../internals/xor\");\n// Number of L blocks to precompute (i.e. µ in the PMAC paper)\n// TODO: dynamically compute these as needed\nconst PRECOMPUTED_BLOCKS = 31;\n/**\n * Polyfill for the AES-PMAC message authentication code\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n */\nclass PMAC {\n    constructor(cipher, l, lInv) {\n        /**\n         * finished is set true when we are done processing a message, and forbids\n         * any subsequent writes until we reset the internal state\n         */\n        this._finished = false;\n        this._cipher = cipher;\n        this._L = l;\n        this._LInv = lInv;\n        this._buffer = new block_1.default();\n        this._bufferPos = 0;\n        this._counter = 0;\n        this._offset = new block_1.default();\n        this._tag = new block_1.default();\n    }\n    /** Create a new CMAC instance from the given key */\n    static importKey(provider, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cipher = yield provider.importBlockCipherKey(keyData);\n            /**\n             * L is defined as follows (quoted from the PMAC paper):\n             *\n             * Equation 1:\n             *\n             *     a · x =\n             *         a<<1 if firstbit(a)=0\n             *         (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n             *\n             * Equation 2:\n             *\n             *     a · x⁻¹ =\n             *         a>>1 if lastbit(a)=0\n             *         (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n             *\n             * Let L(0) ← L. For i ∈ [1..µ], compute L(i) ← L(i − 1) · x by\n             * Equation (1) using a shift and a conditional xor.\n             *\n             * Compute L(−1) ← L · x⁻¹ by Equation (2), using a shift and a\n             * conditional xor.\n             *\n             * Save the values L(−1), L(0), L(1), L(2), ..., L(µ) in a table.\n             * (Alternatively, [ed: as we have done in this codebase] defer computing\n             * some or  all of these L(i) values until the value is actually needed.)\n             */\n            const tmp = new block_1.default();\n            yield cipher.encryptBlock(tmp);\n            const l = new Array(PRECOMPUTED_BLOCKS);\n            for (let i = 0; i < PRECOMPUTED_BLOCKS; i++) {\n                l[i] = tmp.clone();\n                tmp.dbl();\n            }\n            /**\n             * Compute L(−1) ← L · x⁻¹:\n             *\n             *     a>>1 if lastbit(a)=0\n             *     (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n             */\n            const lInv = l[0].clone();\n            const lastBit = lInv.data[block_1.default.SIZE - 1] & 0x01;\n            for (let i = block_1.default.SIZE - 1; i > 0; i--) {\n                const carry = constant_time_1.select(lInv.data[i - 1] & 1, 0x80, 0);\n                lInv.data[i] = (lInv.data[i] >>> 1) | carry;\n            }\n            lInv.data[0] >>>= 1;\n            lInv.data[0] ^= constant_time_1.select(lastBit, 0x80, 0);\n            lInv.data[block_1.default.SIZE - 1] ^= constant_time_1.select(lastBit, block_1.default.R >>> 1, 0);\n            return new PMAC(cipher, l, lInv);\n        });\n    }\n    reset() {\n        this._buffer.clear();\n        this._bufferPos = 0;\n        this._counter = 0;\n        this._offset.clear();\n        this._tag.clear();\n        this._finished = false;\n        return this;\n    }\n    clear() {\n        this.reset();\n        this._cipher.clear();\n    }\n    update(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._finished) {\n                throw new Error(\"pmac: already finished\");\n            }\n            const left = block_1.default.SIZE - this._bufferPos;\n            let dataPos = 0;\n            let dataLength = data.length;\n            // Finish filling the internal buf with the message\n            if (dataLength > left) {\n                this._buffer.data.set(data.slice(0, left), this._bufferPos);\n                dataPos += left;\n                dataLength -= left;\n                yield this._processBuffer();\n            }\n            // So long as we have more than a blocks worth of data, compute\n            // whole-sized blocks at a time.\n            while (dataLength > block_1.default.SIZE) {\n                this._buffer.data.set(data.slice(dataPos, dataPos + block_1.default.SIZE));\n                dataPos += block_1.default.SIZE;\n                dataLength -= block_1.default.SIZE;\n                yield this._processBuffer();\n            }\n            if (dataLength > 0) {\n                this._buffer.data.set(data.slice(dataPos, dataPos + dataLength), this._bufferPos);\n                this._bufferPos += dataLength;\n            }\n            return this;\n        });\n    }\n    finish() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._finished) {\n                throw new Error(\"pmac: already finished\");\n            }\n            if (this._bufferPos === block_1.default.SIZE) {\n                xor_1.xor(this._tag.data, this._buffer.data);\n                xor_1.xor(this._tag.data, this._LInv.data);\n            }\n            else {\n                xor_1.xor(this._tag.data, this._buffer.data.slice(0, this._bufferPos));\n                this._tag.data[this._bufferPos] ^= 0x80;\n            }\n            yield this._cipher.encryptBlock(this._tag);\n            this._finished = true;\n            return this._tag.clone().data;\n        });\n    }\n    // Update the internal tag state based on the buffer contents\n    _processBuffer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            xor_1.xor(this._offset.data, this._L[ctz_1.ctz(this._counter + 1)].data);\n            xor_1.xor(this._buffer.data, this._offset.data);\n            this._counter++;\n            yield this._cipher.encryptBlock(this._buffer);\n            xor_1.xor(this._tag.data, this._buffer.data);\n            this._bufferPos = 0;\n        });\n    }\n}\nexports.PMAC = PMAC;\n"]},"metadata":{},"sourceType":"script"}