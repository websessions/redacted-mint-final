{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016-2017 Tony Arcieri, Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst block_1 = require(\"../internals/block\");\n\nconst constant_time_1 = require(\"../internals/constant-time\");\n\nconst ctz_1 = require(\"../internals/ctz\");\n\nconst xor_1 = require(\"../internals/xor\"); // Number of L blocks to precompute (i.e. µ in the PMAC paper)\n// TODO: dynamically compute these as needed\n\n\nconst PRECOMPUTED_BLOCKS = 31;\n/**\n * Polyfill for the AES-PMAC message authentication code\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n */\n\nclass PMAC {\n  constructor(cipher, l, lInv) {\n    /**\n     * finished is set true when we are done processing a message, and forbids\n     * any subsequent writes until we reset the internal state\n     */\n    this._finished = false;\n    this._cipher = cipher;\n    this._L = l;\n    this._LInv = lInv;\n    this._buffer = new block_1.default();\n    this._bufferPos = 0;\n    this._counter = 0;\n    this._offset = new block_1.default();\n    this._tag = new block_1.default();\n  }\n  /** Create a new CMAC instance from the given key */\n\n\n  static importKey(provider, keyData) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const cipher = yield provider.importBlockCipherKey(keyData);\n      /**\n       * L is defined as follows (quoted from the PMAC paper):\n       *\n       * Equation 1:\n       *\n       *     a · x =\n       *         a<<1 if firstbit(a)=0\n       *         (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n       *\n       * Equation 2:\n       *\n       *     a · x⁻¹ =\n       *         a>>1 if lastbit(a)=0\n       *         (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n       *\n       * Let L(0) ← L. For i ∈ [1..µ], compute L(i) ← L(i − 1) · x by\n       * Equation (1) using a shift and a conditional xor.\n       *\n       * Compute L(−1) ← L · x⁻¹ by Equation (2), using a shift and a\n       * conditional xor.\n       *\n       * Save the values L(−1), L(0), L(1), L(2), ..., L(µ) in a table.\n       * (Alternatively, [ed: as we have done in this codebase] defer computing\n       * some or  all of these L(i) values until the value is actually needed.)\n       */\n\n      const tmp = new block_1.default();\n      yield cipher.encryptBlock(tmp);\n      const l = new Array(PRECOMPUTED_BLOCKS);\n\n      for (let i = 0; i < PRECOMPUTED_BLOCKS; i++) {\n        l[i] = tmp.clone();\n        tmp.dbl();\n      }\n      /**\n       * Compute L(−1) ← L · x⁻¹:\n       *\n       *     a>>1 if lastbit(a)=0\n       *     (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n       */\n\n\n      const lInv = l[0].clone();\n      const lastBit = lInv.data[block_1.default.SIZE - 1] & 0x01;\n\n      for (let i = block_1.default.SIZE - 1; i > 0; i--) {\n        const carry = constant_time_1.select(lInv.data[i - 1] & 1, 0x80, 0);\n        lInv.data[i] = lInv.data[i] >>> 1 | carry;\n      }\n\n      lInv.data[0] >>>= 1;\n      lInv.data[0] ^= constant_time_1.select(lastBit, 0x80, 0);\n      lInv.data[block_1.default.SIZE - 1] ^= constant_time_1.select(lastBit, block_1.default.R >>> 1, 0);\n      return new PMAC(cipher, l, lInv);\n    });\n  }\n\n  reset() {\n    this._buffer.clear();\n\n    this._bufferPos = 0;\n    this._counter = 0;\n\n    this._offset.clear();\n\n    this._tag.clear();\n\n    this._finished = false;\n    return this;\n  }\n\n  clear() {\n    this.reset();\n\n    this._cipher.clear();\n  }\n\n  update(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._finished) {\n        throw new Error(\"pmac: already finished\");\n      }\n\n      const left = block_1.default.SIZE - this._bufferPos;\n      let dataPos = 0;\n      let dataLength = data.length; // Finish filling the internal buf with the message\n\n      if (dataLength > left) {\n        this._buffer.data.set(data.slice(0, left), this._bufferPos);\n\n        dataPos += left;\n        dataLength -= left;\n        yield this._processBuffer();\n      } // So long as we have more than a blocks worth of data, compute\n      // whole-sized blocks at a time.\n\n\n      while (dataLength > block_1.default.SIZE) {\n        this._buffer.data.set(data.slice(dataPos, dataPos + block_1.default.SIZE));\n\n        dataPos += block_1.default.SIZE;\n        dataLength -= block_1.default.SIZE;\n        yield this._processBuffer();\n      }\n\n      if (dataLength > 0) {\n        this._buffer.data.set(data.slice(dataPos, dataPos + dataLength), this._bufferPos);\n\n        this._bufferPos += dataLength;\n      }\n\n      return this;\n    });\n  }\n\n  finish() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._finished) {\n        throw new Error(\"pmac: already finished\");\n      }\n\n      if (this._bufferPos === block_1.default.SIZE) {\n        xor_1.xor(this._tag.data, this._buffer.data);\n        xor_1.xor(this._tag.data, this._LInv.data);\n      } else {\n        xor_1.xor(this._tag.data, this._buffer.data.slice(0, this._bufferPos));\n        this._tag.data[this._bufferPos] ^= 0x80;\n      }\n\n      yield this._cipher.encryptBlock(this._tag);\n      this._finished = true;\n      return this._tag.clone().data;\n    });\n  } // Update the internal tag state based on the buffer contents\n\n\n  _processBuffer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      xor_1.xor(this._offset.data, this._L[ctz_1.ctz(this._counter + 1)].data);\n      xor_1.xor(this._buffer.data, this._offset.data);\n      this._counter++;\n      yield this._cipher.encryptBlock(this._buffer);\n      xor_1.xor(this._tag.data, this._buffer.data);\n      this._bufferPos = 0;\n    });\n  }\n\n}\n\nexports.PMAC = PMAC;","map":{"version":3,"sources":["/Users/aidansalzmann/button-minter/6_wallets/reactjs_keplr/secret-dapp/node_modules/miscreant/release/mac/pmac.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","block_1","require","constant_time_1","ctz_1","xor_1","PRECOMPUTED_BLOCKS","PMAC","constructor","cipher","l","lInv","_finished","_cipher","_L","_LInv","_buffer","default","_bufferPos","_counter","_offset","_tag","importKey","provider","keyData","importBlockCipherKey","tmp","encryptBlock","Array","i","clone","dbl","lastBit","data","SIZE","carry","select","R","reset","clear","update","Error","left","dataPos","dataLength","length","set","slice","_processBuffer","finish","xor","ctz"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright (C) 2016-2017 Tony Arcieri, Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst block_1 = require(\"../internals/block\");\nconst constant_time_1 = require(\"../internals/constant-time\");\nconst ctz_1 = require(\"../internals/ctz\");\nconst xor_1 = require(\"../internals/xor\");\n// Number of L blocks to precompute (i.e. µ in the PMAC paper)\n// TODO: dynamically compute these as needed\nconst PRECOMPUTED_BLOCKS = 31;\n/**\n * Polyfill for the AES-PMAC message authentication code\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n */\nclass PMAC {\n    constructor(cipher, l, lInv) {\n        /**\n         * finished is set true when we are done processing a message, and forbids\n         * any subsequent writes until we reset the internal state\n         */\n        this._finished = false;\n        this._cipher = cipher;\n        this._L = l;\n        this._LInv = lInv;\n        this._buffer = new block_1.default();\n        this._bufferPos = 0;\n        this._counter = 0;\n        this._offset = new block_1.default();\n        this._tag = new block_1.default();\n    }\n    /** Create a new CMAC instance from the given key */\n    static importKey(provider, keyData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cipher = yield provider.importBlockCipherKey(keyData);\n            /**\n             * L is defined as follows (quoted from the PMAC paper):\n             *\n             * Equation 1:\n             *\n             *     a · x =\n             *         a<<1 if firstbit(a)=0\n             *         (a<<1) ⊕ 0¹²⁰10000111 if firstbit(a)=1\n             *\n             * Equation 2:\n             *\n             *     a · x⁻¹ =\n             *         a>>1 if lastbit(a)=0\n             *         (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n             *\n             * Let L(0) ← L. For i ∈ [1..µ], compute L(i) ← L(i − 1) · x by\n             * Equation (1) using a shift and a conditional xor.\n             *\n             * Compute L(−1) ← L · x⁻¹ by Equation (2), using a shift and a\n             * conditional xor.\n             *\n             * Save the values L(−1), L(0), L(1), L(2), ..., L(µ) in a table.\n             * (Alternatively, [ed: as we have done in this codebase] defer computing\n             * some or  all of these L(i) values until the value is actually needed.)\n             */\n            const tmp = new block_1.default();\n            yield cipher.encryptBlock(tmp);\n            const l = new Array(PRECOMPUTED_BLOCKS);\n            for (let i = 0; i < PRECOMPUTED_BLOCKS; i++) {\n                l[i] = tmp.clone();\n                tmp.dbl();\n            }\n            /**\n             * Compute L(−1) ← L · x⁻¹:\n             *\n             *     a>>1 if lastbit(a)=0\n             *     (a>>1) ⊕ 10¹²⁰1000011 if lastbit(a)=1\n             */\n            const lInv = l[0].clone();\n            const lastBit = lInv.data[block_1.default.SIZE - 1] & 0x01;\n            for (let i = block_1.default.SIZE - 1; i > 0; i--) {\n                const carry = constant_time_1.select(lInv.data[i - 1] & 1, 0x80, 0);\n                lInv.data[i] = (lInv.data[i] >>> 1) | carry;\n            }\n            lInv.data[0] >>>= 1;\n            lInv.data[0] ^= constant_time_1.select(lastBit, 0x80, 0);\n            lInv.data[block_1.default.SIZE - 1] ^= constant_time_1.select(lastBit, block_1.default.R >>> 1, 0);\n            return new PMAC(cipher, l, lInv);\n        });\n    }\n    reset() {\n        this._buffer.clear();\n        this._bufferPos = 0;\n        this._counter = 0;\n        this._offset.clear();\n        this._tag.clear();\n        this._finished = false;\n        return this;\n    }\n    clear() {\n        this.reset();\n        this._cipher.clear();\n    }\n    update(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._finished) {\n                throw new Error(\"pmac: already finished\");\n            }\n            const left = block_1.default.SIZE - this._bufferPos;\n            let dataPos = 0;\n            let dataLength = data.length;\n            // Finish filling the internal buf with the message\n            if (dataLength > left) {\n                this._buffer.data.set(data.slice(0, left), this._bufferPos);\n                dataPos += left;\n                dataLength -= left;\n                yield this._processBuffer();\n            }\n            // So long as we have more than a blocks worth of data, compute\n            // whole-sized blocks at a time.\n            while (dataLength > block_1.default.SIZE) {\n                this._buffer.data.set(data.slice(dataPos, dataPos + block_1.default.SIZE));\n                dataPos += block_1.default.SIZE;\n                dataLength -= block_1.default.SIZE;\n                yield this._processBuffer();\n            }\n            if (dataLength > 0) {\n                this._buffer.data.set(data.slice(dataPos, dataPos + dataLength), this._bufferPos);\n                this._bufferPos += dataLength;\n            }\n            return this;\n        });\n    }\n    finish() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._finished) {\n                throw new Error(\"pmac: already finished\");\n            }\n            if (this._bufferPos === block_1.default.SIZE) {\n                xor_1.xor(this._tag.data, this._buffer.data);\n                xor_1.xor(this._tag.data, this._LInv.data);\n            }\n            else {\n                xor_1.xor(this._tag.data, this._buffer.data.slice(0, this._bufferPos));\n                this._tag.data[this._bufferPos] ^= 0x80;\n            }\n            yield this._cipher.encryptBlock(this._tag);\n            this._finished = true;\n            return this._tag.clone().data;\n        });\n    }\n    // Update the internal tag state based on the buffer contents\n    _processBuffer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            xor_1.xor(this._offset.data, this._L[ctz_1.ctz(this._counter + 1)].data);\n            xor_1.xor(this._buffer.data, this._offset.data);\n            this._counter++;\n            yield this._cipher.encryptBlock(this._buffer);\n            xor_1.xor(this._tag.data, this._buffer.data);\n            this._bufferPos = 0;\n        });\n    }\n}\nexports.PMAC = PMAC;\n"]},"metadata":{},"sourceType":"script"}