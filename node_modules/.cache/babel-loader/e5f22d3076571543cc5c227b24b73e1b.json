{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst block_1 = require(\"../../internals/block\");\n/**\n * Polyfill for the AES-CTR (counter) mode of operation.\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n *\n * Note that CTR mode is malleable and generally should not be used without\n * authentication. Instead, use an authenticated encryption mode, like AES-SIV!\n */\n\n\nclass PolyfillAesCtr {\n  constructor(cipher) {\n    // Set cipher.\n    this._cipher = cipher; // Allocate space for counter.\n\n    this._counter = new block_1.default(); // Allocate buffer for encrypted block.\n\n    this._buffer = new block_1.default();\n  }\n\n  clear() {\n    this._buffer.clear();\n\n    this._counter.clear();\n\n    this._cipher.clear();\n\n    return this;\n  }\n\n  encryptCtr(iv, plaintext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (iv.length !== block_1.default.SIZE) {\n        throw new Error(\"CTR: iv length must be equal to cipher block size\");\n      } // Copy IV to counter, overwriting it.\n\n\n      this._counter.data.set(iv); // Set buffer position to length of buffer\n      // so that the first cipher block is generated.\n\n\n      let bufferPos = block_1.default.SIZE;\n      const result = new Uint8Array(plaintext.length);\n\n      for (let i = 0; i < plaintext.length; i++) {\n        if (bufferPos === block_1.default.SIZE) {\n          this._buffer.copy(this._counter);\n\n          this._cipher.encryptBlock(this._buffer);\n\n          bufferPos = 0;\n          incrementCounter(this._counter);\n        }\n\n        result[i] = plaintext[i] ^ this._buffer.data[bufferPos++];\n      }\n\n      return result;\n    });\n  }\n\n}\n\nexports.default = PolyfillAesCtr; // Increment an AES-CTR mode counter, intentionally wrapping/overflowing\n\nfunction incrementCounter(counter) {\n  let carry = 1;\n\n  for (let i = block_1.default.SIZE - 1; i >= 0; i--) {\n    carry += counter.data[i] & 0xff | 0;\n    counter.data[i] = carry & 0xff;\n    carry >>>= 8;\n  }\n}","map":{"version":3,"sources":["/Users/aidansalzmann/button-minter/6_wallets/reactjs_keplr/secret-dapp/node_modules/miscreant/release/providers/polyfill/aes_ctr.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","block_1","require","PolyfillAesCtr","constructor","cipher","_cipher","_counter","default","_buffer","clear","encryptCtr","iv","plaintext","length","SIZE","Error","data","set","bufferPos","Uint8Array","i","copy","encryptBlock","incrementCounter","counter","carry"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst block_1 = require(\"../../internals/block\");\n/**\n * Polyfill for the AES-CTR (counter) mode of operation.\n *\n * Uses a non-constant-time (lookup table-based) AES polyfill.\n * See polyfill/aes.ts for more information on the security impact.\n *\n * Note that CTR mode is malleable and generally should not be used without\n * authentication. Instead, use an authenticated encryption mode, like AES-SIV!\n */\nclass PolyfillAesCtr {\n    constructor(cipher) {\n        // Set cipher.\n        this._cipher = cipher;\n        // Allocate space for counter.\n        this._counter = new block_1.default();\n        // Allocate buffer for encrypted block.\n        this._buffer = new block_1.default();\n    }\n    clear() {\n        this._buffer.clear();\n        this._counter.clear();\n        this._cipher.clear();\n        return this;\n    }\n    encryptCtr(iv, plaintext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (iv.length !== block_1.default.SIZE) {\n                throw new Error(\"CTR: iv length must be equal to cipher block size\");\n            }\n            // Copy IV to counter, overwriting it.\n            this._counter.data.set(iv);\n            // Set buffer position to length of buffer\n            // so that the first cipher block is generated.\n            let bufferPos = block_1.default.SIZE;\n            const result = new Uint8Array(plaintext.length);\n            for (let i = 0; i < plaintext.length; i++) {\n                if (bufferPos === block_1.default.SIZE) {\n                    this._buffer.copy(this._counter);\n                    this._cipher.encryptBlock(this._buffer);\n                    bufferPos = 0;\n                    incrementCounter(this._counter);\n                }\n                result[i] = plaintext[i] ^ this._buffer.data[bufferPos++];\n            }\n            return result;\n        });\n    }\n}\nexports.default = PolyfillAesCtr;\n// Increment an AES-CTR mode counter, intentionally wrapping/overflowing\nfunction incrementCounter(counter) {\n    let carry = 1;\n    for (let i = block_1.default.SIZE - 1; i >= 0; i--) {\n        carry += (counter.data[i] & 0xff) | 0;\n        counter.data[i] = carry & 0xff;\n        carry >>>= 8;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}