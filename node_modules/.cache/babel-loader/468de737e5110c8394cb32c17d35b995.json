{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/aidansalzmann/redacted-mint/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Hmac = /*#__PURE__*/function () {\n  function Hmac(hashFunctionConstructor, originalKey) {\n    _classCallCheck(this, Hmac);\n\n    // This implementation is based on https://en.wikipedia.org/wiki/HMAC#Implementation\n    // with the addition of incremental hashing support. Thus part of the algorithm\n    // is in the constructor and the rest in digest().\n    var blockSize = new hashFunctionConstructor().blockSize;\n\n    this.hash = function (data) {\n      return new hashFunctionConstructor().update(data).digest();\n    };\n\n    var key = originalKey;\n\n    if (key.length > blockSize) {\n      key = this.hash(key);\n    }\n\n    if (key.length < blockSize) {\n      var zeroPadding = new Uint8Array(blockSize - key.length);\n      key = new Uint8Array([].concat(_toConsumableArray(key), _toConsumableArray(zeroPadding)));\n    } // tslint:disable-next-line:no-bitwise\n\n\n    this.oKeyPad = key.map(function (keyByte) {\n      return keyByte ^ 0x5c;\n    }); // tslint:disable-next-line:no-bitwise\n\n    this.iKeyPad = key.map(function (keyByte) {\n      return keyByte ^ 0x36;\n    });\n    this.messageHasher = new hashFunctionConstructor();\n    this.blockSize = blockSize;\n    this.update(this.iKeyPad);\n  }\n\n  _createClass(Hmac, [{\n    key: \"update\",\n    value: function update(data) {\n      this.messageHasher.update(data);\n      return this;\n    }\n  }, {\n    key: \"digest\",\n    value: function digest() {\n      var innerHash = this.messageHasher.digest();\n      return this.hash(new Uint8Array([].concat(_toConsumableArray(this.oKeyPad), _toConsumableArray(innerHash))));\n    }\n  }]);\n\n  return Hmac;\n}();\n\nexports.Hmac = Hmac;","map":{"version":3,"sources":["../src/hmac.ts"],"names":[],"mappings":";;;;;;;;;;;;IAEa,I;AAQX,gBAAmB,uBAAnB,EAAyD,WAAzD,EAAgF;AAAA;;AAC9E;AACA;AACA;AAEA,QAAM,SAAS,GAAG,IAAI,uBAAJ,GAA8B,SAAhD;;AAEA,SAAK,IAAL,GAAY,UAAA,IAAI;AAAA,aAAI,IAAI,uBAAJ,GAA8B,MAA9B,CAAqC,IAArC,EAA2C,MAA3C,EAAJ;AAAA,KAAhB;;AAEA,QAAI,GAAG,GAAG,WAAV;;AACA,QAAI,GAAG,CAAC,MAAJ,GAAa,SAAjB,EAA4B;AAC1B,MAAA,GAAG,GAAG,KAAK,IAAL,CAAU,GAAV,CAAN;AACD;;AAED,QAAI,GAAG,CAAC,MAAJ,GAAa,SAAjB,EAA4B;AAC1B,UAAM,WAAW,GAAG,IAAI,UAAJ,CAAe,SAAS,GAAG,GAAG,CAAC,MAA/B,CAApB;AACA,MAAA,GAAG,GAAG,IAAI,UAAJ,8BAAmB,GAAnB,sBAA2B,WAA3B,GAAN;AACD,KAjB6E,CAmB9E;;;AACA,SAAK,OAAL,GAAe,GAAG,CAAC,GAAJ,CAAQ,UAAA,OAAO;AAAA,aAAI,OAAO,GAAG,IAAd;AAAA,KAAf,CAAf,CApB8E,CAqB9E;;AACA,SAAK,OAAL,GAAe,GAAG,CAAC,GAAJ,CAAQ,UAAA,OAAO;AAAA,aAAI,OAAO,GAAG,IAAd;AAAA,KAAf,CAAf;AACA,SAAK,aAAL,GAAqB,IAAI,uBAAJ,EAArB;AACA,SAAK,SAAL,GAAiB,SAAjB;AAEA,SAAK,MAAL,CAAY,KAAK,OAAjB;AACD;;;;WAEM,gBAAO,IAAP,EAAuB;AAC5B,WAAK,aAAL,CAAmB,MAAnB,CAA0B,IAA1B;AACA,aAAO,IAAP;AACD;;;WAEM,kBAAM;AACX,UAAM,SAAS,GAAG,KAAK,aAAL,CAAmB,MAAnB,EAAlB;AACA,aAAO,KAAK,IAAL,CAAU,IAAI,UAAJ,8BAAmB,KAAK,OAAxB,sBAAoC,SAApC,GAAV,CAAP;AACD;;;;;;AA7CH,OAAA,CAAA,IAAA,GAAA,IAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Hmac {\n    constructor(hashFunctionConstructor, originalKey) {\n        // This implementation is based on https://en.wikipedia.org/wiki/HMAC#Implementation\n        // with the addition of incremental hashing support. Thus part of the algorithm\n        // is in the constructor and the rest in digest().\n        const blockSize = new hashFunctionConstructor().blockSize;\n        this.hash = data => new hashFunctionConstructor().update(data).digest();\n        let key = originalKey;\n        if (key.length > blockSize) {\n            key = this.hash(key);\n        }\n        if (key.length < blockSize) {\n            const zeroPadding = new Uint8Array(blockSize - key.length);\n            key = new Uint8Array([...key, ...zeroPadding]);\n        }\n        // tslint:disable-next-line:no-bitwise\n        this.oKeyPad = key.map(keyByte => keyByte ^ 0x5c);\n        // tslint:disable-next-line:no-bitwise\n        this.iKeyPad = key.map(keyByte => keyByte ^ 0x36);\n        this.messageHasher = new hashFunctionConstructor();\n        this.blockSize = blockSize;\n        this.update(this.iKeyPad);\n    }\n    update(data) {\n        this.messageHasher.update(data);\n        return this;\n    }\n    digest() {\n        const innerHash = this.messageHasher.digest();\n        return this.hash(new Uint8Array([...this.oKeyPad, ...innerHash]));\n    }\n}\nexports.Hmac = Hmac;\n//# sourceMappingURL=hmac.js.map"]},"metadata":{},"sourceType":"script"}